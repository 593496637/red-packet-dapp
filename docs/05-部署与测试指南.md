# 🚀 部署与测试完整指南

## 📋 部署策略概览

### 部署架构设计

```
部署流水线
├── 开发环境 (本地)
│   ├── Hardhat 本地网络
│   ├── React 开发服务器
│   └── Graph Node 本地节点
├── 测试环境 (Sepolia)
│   ├── 智能合约部署
│   ├── 子图部署到 Graph Studio
│   └── 前端部署到 Vercel Preview
└── 生产环境
    ├── 主网合约部署
    ├── 子图发布到 Graph Network
    └── 前端部署到 CDN
```

### 部署时间线

```
Phase 1: 本地开发环境搭建
Phase 2: 智能合约测试网部署
Phase 3: 子图开发与部署
Phase 4: 前端集成与部署
Phase 5: 集成测试与优化
Phase 6: 生产环境部署（可选）
```

## 🧪 测试策略框架

### 测试金字塔

```
                    /\
                   /  \
                  / E2E \     ← 少量端到端测试
                 /______\
                /        \
               /Integration\ ← 中等数量集成测试
              /__________\
             /            \
            /  Unit Tests  \   ← 大量单元测试
           /________________\
```

### 测试类型详解

1. **单元测试 (Unit Tests)**
   - 智能合约函数测试
   - 前端组件测试
   - 工具函数测试

2. **集成测试 (Integration Tests)**
   - 智能合约与前端交互测试
   - 子图数据索引测试
   - API接口测试

3. **端到端测试 (E2E Tests)**
   - 完整用户流程测试
   - 跨浏览器兼容性测试
   - 性能基准测试

## 🔧 智能合约部署详解

### 1. 本地开发环境

**启动本地网络**:
```bash
cd contracts

# 启动Hardhat网络
npx hardhat node

# 在新终端中部署合约
npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network localhost
```

**本地测试脚本**:
```typescript
// scripts/test-local.ts
import { createPublicClient, createWalletClient, http, parseEther } from "viem"
import { privateKeyToAccount } from "viem/accounts"
import { localhost } from "viem/chains"

async function testLocalDeployment() {
  const account = privateKeyToAccount("0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80")
  
  const publicClient = createPublicClient({
    chain: localhost,
    transport: http()
  })

  const walletClient = createWalletClient({
    account,
    chain: localhost,
    transport: http()
  })

  console.log("🔍 测试本地合约部署...")
  
  // 检查合约是否部署
  const contractAddress = "0x5FbDB2315678afecb367f032d93F642f64180aa3" // 本地部署地址
  const code = await publicClient.getBytecode({ address: contractAddress })
  
  if (code && code !== "0x") {
    console.log("✅ 合约部署成功")
    
    // 测试创建红包
    const hash = await walletClient.writeContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "createRedPacket",
      args: ["本地测试红包", 3n, false],
      value: parseEther("0.1")
    })
    
    console.log(`📝 红包创建交易: ${hash}`)
    
    const receipt = await publicClient.waitForTransactionReceipt({ hash })
    console.log(`⛽ Gas 使用量: ${receipt.gasUsed}`)
  } else {
    console.log("❌ 合约部署失败")
  }
}

testLocalDeployment().catch(console.error)
```

### 2. Sepolia 测试网部署

**环境配置**:
```bash
# 设置环境变量
npx hardhat keystore set SEPOLIA_PRIVATE_KEY
npx hardhat keystore set SEPOLIA_RPC_URL
npx hardhat keystore set ETHERSCAN_API_KEY
```

**部署脚本增强**:
```typescript
// ignition/modules/RedPacketSystem.ts
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules"
import { parseEther } from "viem"

export default buildModule("RedPacketSystemModule", (m) => {
  // 部署参数配置
  const initialOwner = m.getParameter("initialOwner", "0x742d35Cc94C5E06cc4e5E4C5c1bEcaE3c4f5B5f5")
  
  // 部署主合约
  const redPacketSystem = m.contract("RedPacketSystem", [])

  // 部署后验证
  m.call(redPacketSystem, "packetCounter", [], {
    after: [redPacketSystem]
  })

  return {
    redPacketSystem,
  }
})
```

**部署和验证流程**:
```bash
# 编译合约
npx hardhat compile

# 部署到Sepolia
npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network sepolia

# 验证合约（自动）
npx hardhat verify --network sepolia CONTRACT_ADDRESS

# 手动验证（如果自动失败）
npx hardhat verify --network sepolia 0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f
```

**部署后测试脚本**:
```typescript
// scripts/verify-sepolia-deployment.ts
import { createPublicClient, http, parseEther } from "viem"
import { sepolia } from "viem/chains"

async function verifySepolia() {
  const publicClient = createPublicClient({
    chain: sepolia,
    transport: http(process.env.SEPOLIA_RPC_URL)
  })

  const contractAddress = "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"

  console.log("🔍 验证Sepolia部署...")

  try {
    // 检查合约代码
    const code = await publicClient.getBytecode({ address: contractAddress })
    console.log(`📄 合约代码长度: ${code?.length || 0} 字符`)

    // 读取合约状态
    const counter = await publicClient.readContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "packetCounter"
    })
    console.log(`📊 当前红包计数: ${counter}`)

    // 估算创建红包的Gas费用
    const gasEstimate = await publicClient.estimateContractGas({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "createRedPacket",
      args: ["测试红包", 5n, true],
      value: parseEther("0.01"),
      account: "0x742d35Cc94C5E06cc4e5E4C5c1bEcaE3c4f5B5f5"
    })
    console.log(`⛽ 创建红包预估Gas: ${gasEstimate}`)

    console.log("✅ Sepolia部署验证完成")
  } catch (error) {
    console.error("❌ 验证失败:", error)
  }
}

verifySepolia()
```

### 3. 合约升级策略

虽然当前项目使用不可升级合约，但了解升级模式很重要：

**代理模式合约结构**:
```solidity
// contracts/upgrades/RedPacketProxy.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract RedPacketSystemUpgradeable is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    // 存储布局必须保持兼容
    uint256 public packetCounter;
    mapping(uint256 => RedPacket) public packets;
    mapping(uint256 => mapping(address => bool)) public hasClaimed;

    struct RedPacket {
        address owner;
        string message;
        uint256 totalAmount;
        uint256 balance;
        uint256 totalCount;
        uint256 claimedCount;
        bool isEven;
        uint256 creationTime;
    }

    function initialize() public initializer {
        __Ownable_init();
        __UUPSUpgradeable_init();
        packetCounter = 0;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // 其他函数保持不变...
}
```

## 📊 子图部署流程

### 1. 开发环境子图

**本地Graph Node设置**:
```bash
# 克隆Graph Node
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker

# 启动本地节点
docker-compose up -d

# 等待节点启动完成
sleep 30

# 创建本地子图
cd /path/to/subgraph
graph create --node http://localhost:8020/ red-packet-local

# 部署到本地节点
graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 red-packet-local
```

**本地子图测试**:
```bash
# 查询本地子图
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"query": "{ redPackets(first: 5) { id creator message } }"}' \
  http://localhost:8000/subgraphs/name/red-packet-local
```

### 2. Graph Studio 部署

**准备工作**:
```bash
# 安装最新版本Graph CLI
npm install -g @graphprotocol/graph-cli@latest

# 登录Graph Studio
graph auth --studio YOUR_DEPLOY_KEY
```

**部署脚本**:
```bash
#!/bin/bash
# scripts/deploy-subgraph.sh

set -e

echo "🏗️  构建子图..."

# 生成代码
npm run codegen

# 构建子图
npm run build

echo "📤 部署到Graph Studio..."

# 部署到Studio
graph deploy --studio red-packet-subgraph

echo "✅ 子图部署完成"

# 等待同步
echo "⏳ 等待子图同步..."
sleep 10

# 验证部署
echo "🔍 验证子图状态..."
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"query": "{ _meta { block { number } } }"}' \
  "https://api.studio.thegraph.com/query/YOUR_SUBGRAPH_ID/redpacketsystem/version/latest"
```

**子图健康检查**:
```typescript
// scripts/check-subgraph-health.ts
import fetch from 'node-fetch'

async function checkSubgraphHealth() {
  const SUBGRAPH_URL = "https://api.studio.thegraph.com/query/YOUR_SUBGRAPH_ID/redpacketsystem/version/latest"
  
  try {
    console.log("🔍 检查子图健康状态...")
    
    // 查询元数据
    const metaResponse = await fetch(SUBGRAPH_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: `
          query {
            _meta {
              block {
                number
                hash
              }
              deployment
              hasIndexingErrors
            }
          }
        `
      })
    })
    
    const metaData = await metaResponse.json()
    const meta = metaData.data._meta
    
    console.log(`📦 子图部署ID: ${meta.deployment}`)
    console.log(`🧱 最新同步区块: ${meta.block.number}`)
    console.log(`❌ 索引错误: ${meta.hasIndexingErrors}`)
    
    // 查询一些基础数据
    const dataResponse = await fetch(SUBGRAPH_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: `
          query {
            redPackets(first: 1) {
              id
            }
            globalStats(id: "global") {
              totalPackets
              totalAmount
            }
          }
        `
      })
    })
    
    const queryData = await dataResponse.json()
    
    if (queryData.data.globalStats) {
      console.log(`📊 总红包数: ${queryData.data.globalStats.totalPackets}`)
      console.log(`💰 总金额: ${queryData.data.globalStats.totalAmount}`)
    }
    
    console.log("✅ 子图健康检查完成")
  } catch (error) {
    console.error("❌ 子图健康检查失败:", error)
  }
}

checkSubgraphHealth()
```

## 🌐 前端部署详解

### 1. 环境配置

**不同环境的配置文件**:

**.env.local** (开发环境):
```bash
VITE_NETWORK=localhost
VITE_SEPOLIA_RPC_URL=http://127.0.0.1:8545
VITE_RED_PACKET_CONTRACT=0x5FbDB2315678afecb367f032d93F642f64180aa3
VITE_SUBGRAPH_URL=http://localhost:8000/subgraphs/name/red-packet-local
VITE_WALLET_CONNECT_PROJECT_ID=your_local_project_id
```

**.env.staging** (测试环境):
```bash
VITE_NETWORK=sepolia
VITE_SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID
VITE_RED_PACKET_CONTRACT=0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f
VITE_SUBGRAPH_URL=https://api.studio.thegraph.com/query/YOUR_SUBGRAPH_ID/redpacketsystem/version/latest
VITE_WALLET_CONNECT_PROJECT_ID=your_staging_project_id
```

**.env.production** (生产环境):
```bash
VITE_NETWORK=mainnet
VITE_MAINNET_RPC_URL=https://mainnet.infura.io/v3/YOUR_PROJECT_ID
VITE_RED_PACKET_CONTRACT=0xYOUR_MAINNET_CONTRACT_ADDRESS
VITE_SUBGRAPH_URL=https://gateway-arbitrum.network.thegraph.com/api/YOUR_API_KEY/subgraphs/id/YOUR_SUBGRAPH_ID
VITE_WALLET_CONNECT_PROJECT_ID=your_production_project_id
```

### 2. 构建优化

**Vite构建配置增强**:
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig(({ mode }) => {
  return {
    plugins: [react()],
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
      },
    },
    define: {
      global: 'globalThis',
    },
    build: {
      target: 'es2020',
      minify: mode === 'production' ? 'terser' : false,
      terserOptions: mode === 'production' ? {
        compress: {
          drop_console: true,
          drop_debugger: true,
          pure_funcs: ['console.log', 'console.debug']
        },
        mangle: {
          safari10: true
        }
      } : undefined,
      rollupOptions: {
        output: {
          manualChunks: {
            'vendor-react': ['react', 'react-dom'],
            'vendor-web3': ['wagmi', 'viem', '@tanstack/react-query'],
            'vendor-graphql': ['@apollo/client', 'graphql'],
            'vendor-ui': ['lucide-react', 'sonner', 'clsx']
          },
          chunkFileNames: 'assets/[name]-[hash].js',
          assetFileNames: 'assets/[name]-[hash].[ext]'
        },
      },
      sourcemap: mode !== 'production',
      chunkSizeWarningLimit: 1000
    },
    server: {
      port: 3000,
      host: true,
      open: true
    },
    preview: {
      port: 3001,
      host: true
    }
  }
})
```

### 3. 部署到 Vercel

**vercel.json**:
```json
{
  "framework": "vite",
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "installCommand": "npm install",
  "devCommand": "npm run dev",
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ],
  "headers": [
    {
      "source": "/assets/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ],
  "env": {
    "VITE_NETWORK": "sepolia",
    "VITE_RED_PACKET_CONTRACT": "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"
  }
}
```

**部署脚本**:
```bash
#!/bin/bash
# scripts/deploy-frontend.sh

set -e

echo "🏗️  构建前端应用..."

# 安装依赖
npm ci

# 运行测试
npm run test

# 类型检查
npm run typecheck

# 构建应用
npm run build

# 预览构建结果
echo "🔍 预览构建结果..."
ls -la dist/

# 部署到Vercel
echo "🚀 部署到Vercel..."
npx vercel --prod

echo "✅ 前端部署完成"
```

### 4. 部署后验证

**健康检查脚本**:
```javascript
// scripts/health-check.js
const fetch = require('node-fetch');

async function healthCheck() {
  const BASE_URL = process.env.FRONTEND_URL || 'https://red-packet-dapp.vercel.app';
  
  const checks = [
    {
      name: 'Homepage',
      url: `${BASE_URL}/`,
      expectStatus: 200
    },
    {
      name: 'Assets Loading',
      url: `${BASE_URL}/assets/index.js`,
      expectStatus: 200
    },
    {
      name: 'Manifest',
      url: `${BASE_URL}/manifest.json`,
      expectStatus: 200
    }
  ];

  console.log('🔍 开始健康检查...');

  for (const check of checks) {
    try {
      const response = await fetch(check.url);
      if (response.status === check.expectStatus) {
        console.log(`✅ ${check.name}: OK`);
      } else {
        console.log(`❌ ${check.name}: 期望 ${check.expectStatus}, 实际 ${response.status}`);
      }
    } catch (error) {
      console.log(`❌ ${check.name}: 错误 - ${error.message}`);
    }
  }

  console.log('🏁 健康检查完成');
}

healthCheck();
```

## 🔧 集成测试框架

### 1. 端到端测试设置

**安装Playwright**:
```bash
cd frontend
npm install --save-dev @playwright/test
npx playwright install
```

**Playwright配置**:
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  use: {
    baseURL: process.env.FRONTEND_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    }
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://127.0.0.1:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120000
  }
})
```

### 2. E2E测试用例

**红包创建流程测试**:
```typescript
// tests/e2e/red-packet-creation.spec.ts
import { test, expect } from '@playwright/test'

test.describe('红包创建流程', () => {
  test.beforeEach(async ({ page }) => {
    // 访问应用首页
    await page.goto('/')
    
    // 模拟钱包连接
    await page.evaluate(() => {
      // 模拟MetaMask
      window.ethereum = {
        isMetaMask: true,
        request: async (params) => {
          if (params.method === 'eth_requestAccounts') {
            return ['0x742d35Cc94C5E06cc4e5E4C5c1bEcaE3c4f5B5f5']
          }
          if (params.method === 'eth_chainId') {
            return '0xaa36a7' // Sepolia chain ID
          }
          return null
        }
      }
    })
  })

  test('应该能够成功创建红包', async ({ page }) => {
    // 点击连接钱包按钮
    await page.getByRole('button', { name: '连接钱包' }).click()
    
    // 等待钱包连接成功
    await expect(page.getByText(/0x742d/)).toBeVisible()

    // 填写红包信息
    await page.fill('[data-testid="message-input"]', '恭喜发财，红包拿来！')
    await page.fill('[data-testid="amount-input"]', '0.01')
    await page.fill('[data-testid="count-input"]', '3')

    // 选择均分模式
    await page.getByRole('switch', { name: '均分模式' }).click()

    // 点击创建按钮
    await page.getByRole('button', { name: '创建红包' }).click()

    // 验证创建成功提示
    await expect(page.getByText('红包创建交易已提交')).toBeVisible()

    // 等待交易确认（模拟）
    await page.waitForTimeout(2000)

    // 验证红包出现在列表中
    await expect(page.getByText('恭喜发财，红包拿来！')).toBeVisible()
  })

  test('应该验证输入参数', async ({ page }) => {
    // 尝试创建空红包
    await page.getByRole('button', { name: '创建红包' }).click()

    // 验证错误提示
    await expect(page.getByText('请输入祝福语')).toBeVisible()
    await expect(page.getByText('请输入有效的红包金额')).toBeVisible()
    await expect(page.getByText('请输入有效的红包份数')).toBeVisible()
  })

  test('应该正确计算预览信息', async ({ page }) => {
    await page.fill('[data-testid="amount-input"]', '0.1')
    await page.fill('[data-testid="count-input"]', '5')

    // 验证均分模式预览
    await page.getByRole('switch', { name: '均分模式' }).click()
    await expect(page.getByText('每个红包: 0.020000 ETH')).toBeVisible()

    // 验证随机模式预览
    await page.getByRole('switch', { name: '均分模式' }).click()
    await expect(page.getByText(/随机红包: 0.000001 ~ 0.040000 ETH/)).toBeVisible()
  })
})
```

**红包抢夺流程测试**:
```typescript
// tests/e2e/red-packet-claiming.spec.ts
import { test, expect } from '@playwright/test'

test.describe('红包抢夺流程', () => {
  test('用户应该能够抢夺可用的红包', async ({ page }) => {
    await page.goto('/')

    // 模拟已有红包的状态
    await page.evaluate(() => {
      // 模拟GraphQL响应
      window.__mockGraphQLData = {
        redPackets: [{
          id: '1',
          creator: '0x1234567890123456789012345678901234567890',
          message: '测试红包',
          totalAmount: '100000000000000000', // 0.1 ETH
          totalCount: 3,
          claimedCount: 1,
          isEven: false,
          isActive: true,
          creationTime: '1699000000',
          claims: [{
            claimer: '0x9876543210987654321098765432109876543210',
            amount: '30000000000000000',
            timestamp: '1699000100'
          }]
        }]
      }
    })

    // 刷新页面加载模拟数据
    await page.reload()

    // 验证红包卡片显示
    await expect(page.getByText('测试红包')).toBeVisible()
    await expect(page.getByText('1/3')).toBeVisible()
    await expect(page.getByText('可抢取')).toBeVisible()

    // 连接钱包
    await page.getByRole('button', { name: '连接钱包' }).click()

    // 点击抢红包按钮
    await page.getByRole('button', { name: '抢红包' }).click()

    // 验证交易提交提示
    await expect(page.getByText('抢红包交易已提交')).toBeVisible()

    // 验证按钮状态变化
    await expect(page.getByText('抢红包中...')).toBeVisible()
  })

  test('用户不能重复抢同一个红包', async ({ page }) => {
    // 模拟用户已领取的状态
    await page.evaluate(() => {
      window.__userHasClaimed = true
    })

    await page.goto('/')
    
    // 验证已领取状态
    await expect(page.getByText('已领取')).toBeVisible()
    
    // 抢红包按钮应该不可用
    await expect(page.getByRole('button', { name: '抢红包' })).not.toBeVisible()
  })
})
```

### 3. 性能测试

**性能基准测试**:
```typescript
// tests/performance/performance.spec.ts
import { test, expect } from '@playwright/test'

test('性能基准测试', async ({ page }) => {
  // 开启性能追踪
  await page.tracing.start({ screenshots: true, snapshots: true })

  // 访问首页并测量加载时间
  const startTime = Date.now()
  await page.goto('/')
  
  // 等待关键内容加载完成
  await expect(page.getByText('红包大厅')).toBeVisible()
  
  const loadTime = Date.now() - startTime
  console.log(`首屏加载时间: ${loadTime}ms`)
  
  // 验证性能指标
  expect(loadTime).toBeLessThan(3000) // 首屏加载应小于3秒

  // 测量交互性能
  const interactionStart = Date.now()
  await page.getByRole('button', { name: '连接钱包' }).click()
  await page.waitForSelector('[data-testid="wallet-connected"]')
  const interactionTime = Date.now() - interactionStart
  
  console.log(`钱包连接时间: ${interactionTime}ms`)
  expect(interactionTime).toBeLessThan(1000) // 交互响应应小于1秒

  // 停止追踪并保存
  await page.tracing.stop({ path: 'test-results/trace.zip' })

  // 性能API检查
  const performanceMetrics = await page.evaluate(() => {
    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
    return {
      domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
      firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0,
      largestContentfulPaint: performance.getEntriesByName('largest-contentful-paint')[0]?.startTime || 0
    }
  })

  console.log('性能指标:', performanceMetrics)
  
  expect(performanceMetrics.domContentLoaded).toBeLessThan(1500)
  expect(performanceMetrics.firstContentfulPaint).toBeLessThan(2000)
})
```

## 📋 CI/CD 流水线

### 1. GitHub Actions 配置

**.github/workflows/ci.yml**:
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'

jobs:
  test-contracts:
    name: 智能合约测试
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: contracts/package-lock.json
      
      - name: 安装依赖
        run: |
          cd contracts
          npm ci
      
      - name: 运行Solidity测试
        run: |
          cd contracts
          npx hardhat test solidity
      
      - name: 运行Node.js测试
        run: |
          cd contracts
          npx hardhat test nodejs
      
      - name: Gas报告
        run: |
          cd contracts
          REPORT_GAS=true npx hardhat test
      
      - name: 安全性检查
        run: |
          cd contracts
          npm audit --audit-level=moderate

  test-subgraph:
    name: 子图测试
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: subgraph/package-lock.json
      
      - name: 安装Graph CLI
        run: npm install -g @graphprotocol/graph-cli
      
      - name: 安装依赖
        run: |
          cd subgraph
          npm ci
      
      - name: 代码生成
        run: |
          cd subgraph
          graph codegen
      
      - name: 构建子图
        run: |
          cd subgraph
          graph build
      
      - name: 运行测试
        run: |
          cd subgraph
          graph test

  test-frontend:
    name: 前端测试
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: 安装依赖
        run: |
          cd frontend
          npm ci
      
      - name: 类型检查
        run: |
          cd frontend
          npm run typecheck
      
      - name: 运行Linter
        run: |
          cd frontend
          npm run lint
      
      - name: 运行单元测试
        run: |
          cd frontend
          npm run test
      
      - name: 构建应用
        run: |
          cd frontend
          npm run build
        env:
          VITE_NETWORK: sepolia
          VITE_RED_PACKET_CONTRACT: "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"

  e2e-tests:
    name: 端到端测试
    runs-on: ubuntu-latest
    needs: [test-contracts, test-subgraph, test-frontend]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: 安装依赖
        run: |
          cd frontend
          npm ci
      
      - name: 安装Playwright浏览器
        run: |
          cd frontend
          npx playwright install --with-deps
      
      - name: 运行E2E测试
        run: |
          cd frontend
          npm run test:e2e
        env:
          FRONTEND_URL: http://localhost:3000
      
      - name: 上传测试结果
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: frontend/playwright-report/
          retention-days: 30

  deploy-staging:
    name: 部署到测试环境
    runs-on: ubuntu-latest
    needs: [e2e-tests]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - uses: actions/checkout@v4
      
      - name: 部署合约到Sepolia
        run: |
          cd contracts
          npm ci
          npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network sepolia
        env:
          SEPOLIA_PRIVATE_KEY: ${{ secrets.SEPOLIA_PRIVATE_KEY }}
          SEPOLIA_RPC_URL: ${{ secrets.SEPOLIA_RPC_URL }}
      
      - name: 部署子图
        run: |
          cd subgraph
          npm ci
          npm run codegen
          npm run build
          graph deploy --studio red-packet-subgraph-staging
        env:
          GRAPH_DEPLOY_KEY: ${{ secrets.GRAPH_DEPLOY_KEY }}
      
      - name: 部署前端
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          vercel-args: '--prod'
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          working-directory: frontend

  deploy-production:
    name: 部署到生产环境
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      
      # 生产环境部署需要手动触发
      - name: 手动确认部署
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: your-github-username
          minimum-approvals: 1
          issue-title: "部署到生产环境"
      
      - name: 部署到主网（如果需要）
        run: |
          echo "⚠️  主网部署需要额外的安全检查和审计"
          echo "这里只是示例，实际部署需要更严格的流程"
```

### 2. 部署脚本整合

**deploy.sh** (一键部署脚本):
```bash
#!/bin/bash

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查环境变量
check_env() {
    local required_vars=("SEPOLIA_RPC_URL" "SEPOLIA_PRIVATE_KEY" "GRAPH_DEPLOY_KEY" "VERCEL_TOKEN")
    
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var}" ]]; then
            log_error "Environment variable $var is not set"
            exit 1
        fi
    done
}

# 部署智能合约
deploy_contracts() {
    log_info "开始部署智能合约..."
    
    cd contracts
    
    # 安装依赖
    npm ci
    
    # 编译合约
    npx hardhat compile
    
    # 运行测试
    npm run test
    
    # 部署到Sepolia
    npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network sepolia
    
    # 验证合约
    log_info "验证合约..."
    CONTRACT_ADDRESS=$(jq -r '.RedPacketSystemModule.RedPacketSystem' ignition/deployments/sepolia/deployed_addresses.json)
    npx hardhat verify --network sepolia $CONTRACT_ADDRESS
    
    log_info "合约部署完成: $CONTRACT_ADDRESS"
    
    cd ..
}

# 部署子图
deploy_subgraph() {
    log_info "开始部署子图..."
    
    cd subgraph
    
    # 安装依赖
    npm ci
    
    # 代码生成
    npm run codegen
    
    # 构建
    npm run build
    
    # 部署
    graph deploy --studio red-packet-subgraph
    
    log_info "子图部署完成"
    
    cd ..
}

# 部署前端
deploy_frontend() {
    log_info "开始部署前端..."
    
    cd frontend
    
    # 安装依赖
    npm ci
    
    # 类型检查
    npm run typecheck
    
    # 代码检查
    npm run lint
    
    # 构建
    npm run build
    
    # 部署到Vercel
    npx vercel --prod
    
    log_info "前端部署完成"
    
    cd ..
}

# 部署后验证
verify_deployment() {
    log_info "开始部署验证..."
    
    # 验证合约
    node contracts/scripts/verify-deployment.js
    
    # 验证子图
    node subgraph/scripts/check-subgraph-health.js
    
    # 验证前端
    node frontend/scripts/health-check.js
    
    log_info "部署验证完成"
}

# 主函数
main() {
    log_info "开始红包DApp部署流程..."
    
    # 检查环境
    check_env
    
    # 选择部署组件
    if [[ "$1" == "contracts" ]]; then
        deploy_contracts
    elif [[ "$1" == "subgraph" ]]; then
        deploy_subgraph
    elif [[ "$1" == "frontend" ]]; then
        deploy_frontend
    elif [[ "$1" == "verify" ]]; then
        verify_deployment
    else
        # 全量部署
        deploy_contracts
        sleep 10
        deploy_subgraph
        sleep 10
        deploy_frontend
        sleep 10
        verify_deployment
    fi
    
    log_info "🎉 部署完成!"
}

# 执行主函数
main "$@"
```

## 📊 监控与告警

### 1. 应用监控

**Sentry集成** (错误监控):
```typescript
// src/lib/sentry.ts
import * as Sentry from "@sentry/react"
import { BrowserTracing } from "@sentry/tracing"

Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  integrations: [
    new BrowserTracing({
      routingInstrumentation: Sentry.reactRouterV6Instrumentation(
        React.useEffect,
        useLocation,
        useNavigationType,
        createRoutesFromChildren,
        matchRoutes
      ),
    }),
  ],
  tracesSampleRate: 1.0,
  environment: import.meta.env.MODE,
})
```

**性能监控**:
```typescript
// src/hooks/usePerformanceMonitoring.ts
import { useEffect } from 'react'

export function usePerformanceMonitoring() {
  useEffect(() => {
    // 监控页面性能指标
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        console.log(`${entry.name}: ${entry.duration}ms`)
        
        // 发送到分析服务
        if (entry.duration > 1000) {
          // 慢操作告警
          console.warn(`Slow operation detected: ${entry.name}`)
        }
      })
    })
    
    observer.observe({ entryTypes: ['measure', 'navigation'] })
    
    return () => observer.disconnect()
  }, [])
}
```

### 2. 健康检查端点

**前端健康检查**:
```typescript
// src/api/health.ts
export async function healthCheck() {
  const checks = {
    frontend: true,
    web3: false,
    subgraph: false,
    timestamp: new Date().toISOString()
  }

  try {
    // 检查Web3连接
    const { isConnected } = useAccount()
    checks.web3 = isConnected

    // 检查子图连接
    const response = await fetch(SUBGRAPH_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: '{ _meta { block { number } } }'
      })
    })
    checks.subgraph = response.ok

  } catch (error) {
    console.error('Health check failed:', error)
  }

  return checks
}

// 健康检查路由
app.get('/health', (req, res) => {
  res.json(healthCheck())
})
```

## 📚 部署最佳实践总结

### 1. 安全性原则
- **私钥管理**: 使用环境变量，从不提交到代码库
- **网络配置**: 区分开发、测试、生产网络
- **访问控制**: 合理设置API密钥和访问权限
- **审计日志**: 记录所有部署操作和配置更改

### 2. 可靠性保证
- **渐进式部署**: 先测试网，后主网
- **回滚准备**: 保留上一版本，支持快速回滚
- **健康监控**: 实时监控各组件健康状态
- **告警机制**: 异常情况及时通知

### 3. 性能优化
- **缓存策略**: 合理设置各级缓存
- **代码分割**: 减少初始加载体积
- **资源优化**: 压缩图片、字体等资源
- **CDN加速**: 使用CDN提升访问速度

### 4. 维护性考虑
- **文档完整**: 部署文档和操作手册
- **版本管理**: 清晰的版本号和变更记录
- **配置管理**: 集中管理配置，环境隔离
- **自动化程度**: 尽量减少手动操作

通过这套完整的部署与测试体系，我们建立了一个可靠、高效、安全的DApp部署流程，确保了项目从开发到生产的平稳过渡和持续稳定运行。