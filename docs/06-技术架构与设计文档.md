# ğŸ—ï¸ æŠ€æœ¯æ¶æ„ä¸è®¾è®¡å®è·µæ•™ç¨‹

> **ä»é›¶å¼€å§‹å­¦ä¹ Web3å…¨æ ˆæ¶æ„è®¾è®¡**
>
> è¿™ä¸ä»…æ˜¯ä¸€ä»½æŠ€æœ¯æ–‡æ¡£ï¼Œæ›´æ˜¯ä¸€ä¸ªå®Œæ•´çš„æ¶æ„è®¾è®¡å®è·µæŒ‡å—ã€‚ä½ å°†å­¦ä¼šå¦‚ä½•è®¾è®¡ã€å®ç°å’Œä¼˜åŒ–ä¸€ä¸ªç”Ÿäº§çº§çš„åŒºå—é“¾åº”ç”¨ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ•™ç¨‹åï¼Œä½ å°†èƒ½å¤Ÿï¼š

### ğŸ›ï¸ æ¶æ„è®¾è®¡èƒ½åŠ›
- æŒæ¡åˆ†å±‚æ¶æ„è®¾è®¡åŸåˆ™å’Œå®è·µ
- ç†è§£é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)åœ¨Web3ä¸­çš„åº”ç”¨
- å­¦ä¼šCQRSæ¨¡å¼åœ¨åŒºå—é“¾åº”ç”¨ä¸­çš„å®ç°
- æŒæ¡äº‹ä»¶é©±åŠ¨æ¶æ„çš„è®¾è®¡å’Œä¼˜åŒ–

### ğŸ› ï¸ æŠ€æœ¯é€‰å‹èƒ½åŠ›
- å­¦ä¼šä¸ºWeb3é¡¹ç›®é€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ ˆ
- ç†è§£å„ç§æŠ€æœ¯æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹å’Œé€‚ç”¨åœºæ™¯
- æŒæ¡æ€§èƒ½ã€å®‰å…¨æ€§ã€å¯ç»´æŠ¤æ€§çš„å¹³è¡¡

### ğŸ“ˆ ç³»ç»Ÿä¼˜åŒ–èƒ½åŠ›
- æŒæ¡å‰ç«¯æ€§èƒ½ä¼˜åŒ–çš„å®ç”¨æŠ€å·§
- å­¦ä¼šæ™ºèƒ½åˆçº¦Gasä¼˜åŒ–ç­–ç•¥
- ç†è§£åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç›‘æ§å’Œå¯è§‚æµ‹æ€§

### ğŸ”’ å®‰å…¨è®¾è®¡èƒ½åŠ›
- æŒæ¡å¤šå±‚å®‰å…¨é˜²æŠ¤ç­–ç•¥
- å­¦ä¼šæ™ºèƒ½åˆçº¦å®‰å…¨ç¼–ç¨‹å®è·µ
- ç†è§£Web3åº”ç”¨çš„å¸¸è§å®‰å…¨é£é™©å’Œé˜²èŒƒ

## ğŸ“š å‰ç½®çŸ¥è¯†

### å¿…å¤‡çŸ¥è¯† â­â­â­
- JavaScript/TypeScript åŸºç¡€
- React å¼€å‘ç»éªŒ
- æ™ºèƒ½åˆçº¦åŸºæœ¬æ¦‚å¿µ
- åŒºå—é“¾åŸºç¡€çŸ¥è¯†

### æ¨èçŸ¥è¯† â­â­
- åˆ†å¸ƒå¼ç³»ç»Ÿæ¦‚å¿µ
- è®¾è®¡æ¨¡å¼åŸºç¡€
- æ•°æ®åº“è®¾è®¡ç»éªŒ
- GraphQL ä½¿ç”¨ç»éªŒ

### åŠ åˆ†çŸ¥è¯† â­
- é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)
- äº‹ä»¶æº¯æºæ¨¡å¼
- å¾®æœåŠ¡æ¶æ„
- DevOps å®è·µ

## ğŸš€ å®è·µè·¯å¾„

1. **æ¶æ„è®¤çŸ¥** (30min) - ç†è§£æ•´ä½“æ¶æ„è®¾è®¡
2. **è®¾è®¡æ¨¡å¼** (60min) - æŒæ¡æ ¸å¿ƒè®¾è®¡æ¨¡å¼
3. **æŠ€æœ¯é€‰å‹** (45min) - å­¦ä¹ æŠ€æœ¯æ–¹æ¡ˆè¯„ä¼°
4. **æ€§èƒ½ä¼˜åŒ–** (90min) - å®è·µå„å±‚ä¼˜åŒ–ç­–ç•¥
5. **å®‰å…¨åŠ å›º** (75min) - æ„å»ºå®‰å…¨é˜²æŠ¤ä½“ç³»
6. **ç›‘æ§è¿ç»´** (60min) - å»ºç«‹å¯è§‚æµ‹æ€§ç³»ç»Ÿ
7. **æ‰©å±•æ¼”è¿›** (45min) - è®¾è®¡å¯æŒç»­å‘å±•æ¶æ„

**æ€»å­¦ä¹ æ—¶é—´ï¼šçº¦6å°æ—¶**

---

## ğŸ“‹ ç¬¬ä¸€ç« ï¼šç³»ç»Ÿæ¶æ„å…¨æ™¯ (30min)

> **å­¦ä¹ é‡ç‚¹ï¼š** ç†è§£åˆ†å±‚æ¶æ„è®¾è®¡ï¼ŒæŒæ¡å„å±‚èŒè´£åˆ’åˆ†

### 1.1 æ¶æ„è“å›¾è§£è¯»

### ç³»ç»Ÿæ¶æ„å…¨æ™¯å›¾

```
                    ğŸŒ äº’è”ç½‘
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   CDN/Vercel  â”‚ â† å‰ç«¯é™æ€èµ„æºåˆ†å‘
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚      ğŸ¨ å‰ç«¯åº”ç”¨å±‚           â”‚
          â”‚   React + TypeScript        â”‚
          â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
          â”‚   â”‚  UI Components      â”‚   â”‚
          â”‚   â”‚  State Management   â”‚   â”‚
          â”‚   â”‚  Web3 Integration   â”‚   â”‚
          â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚        â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                        â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ“Š æ•°æ®ç´¢å¼•å±‚  â”‚       â”‚ â›“ï¸  åŒºå—é“¾å±‚   â”‚
    â”‚  The Graph    â”‚       â”‚   Ethereum    â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚       â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ Subgraph  â”‚ â”‚â—„â”€â”€â”€â”€â”€â”€â”¤ â”‚  Smart    â”‚ â”‚
    â”‚ â”‚ GraphQL   â”‚ â”‚ äº‹ä»¶ç›‘å¬ â”‚ â”‚ Contract  â”‚ â”‚
    â”‚ â”‚ Database  â”‚ â”‚       â”‚ â”‚  Events   â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                        â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ—„ï¸  æ•°æ®å­˜å‚¨   â”‚       â”‚ ğŸ”— åŒºå—é“¾ç½‘ç»œ  â”‚
    â”‚  PostgreSQL   â”‚       â”‚   Sepolia     â”‚
    â”‚   IPFS Hash   â”‚       â”‚   Mainnet     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

è®©æˆ‘ä»¬ä¸€æ­¥æ­¥åˆ†æè¿™ä¸ªæ¶æ„å›¾ï¼š

```
ğŸ’¡ æ¶æ„åˆ†ææŠ€å·§
1. ä»ä¸Šåˆ°ä¸‹ï¼šç”¨æˆ·è®¿é—®è·¯å¾„
2. ä»å·¦åˆ°å³ï¼šæ•°æ®æµåŠ¨æ–¹å‘
3. å…³æ³¨æ¥å£ï¼šå±‚ä¸å±‚ä¹‹é—´çš„è¿æ¥ç‚¹
4. è¯†åˆ«ä¾èµ–ï¼šå“ªäº›ç»„ä»¶ä¾èµ–å…¶ä»–ç»„ä»¶
```

### 1.2 æ¶æ„è®¾è®¡åŸåˆ™è¯¦è§£

è®©æˆ‘ä»¬æ·±å…¥ç†è§£æ¯ä¸ªè®¾è®¡åŸåˆ™ï¼š

#### ğŸ—ï¸ åŸåˆ™1ï¼šåˆ†å±‚è§£è€¦

**ä¸ºä»€ä¹ˆè¦åˆ†å±‚ï¼Ÿ**
```typescript
// âŒ ç´§è€¦åˆè®¾è®¡ - éš¾ä»¥ç»´æŠ¤
function claimRedPacket(packetId: string) {
  // ç›´æ¥åœ¨UIå±‚å¤„ç†ä¸šåŠ¡é€»è¾‘
  const contract = new ethers.Contract(...)
  const result = await contract.claimRedPacket(packetId)
  
  // ç›´æ¥æ“ä½œæ•°æ®åº“
  database.updatePacketStatus(packetId, 'claimed')
  
  // ç›´æ¥å‘é€é€šçŸ¥
  pushNotification('çº¢åŒ…å·²é¢†å–')
}

// âœ… åˆ†å±‚è®¾è®¡ - æ¸…æ™°å¯ç»´æŠ¤
class RedPacketService {
  constructor(
    private contractService: ContractService,
    private dataService: DataService,
    private notificationService: NotificationService
  ) {}

  async claimRedPacket(packetId: string): Promise<ClaimResult> {
    // å„å±‚èŒè´£æ˜ç¡®ï¼Œæ˜“äºæµ‹è¯•å’Œç»´æŠ¤
    const result = await this.contractService.claim(packetId)
    await this.dataService.updateStatus(packetId, 'claimed')
    await this.notificationService.sendClaimNotification(result)
    
    return result
  }
}
```

**å®è·µç»ƒä¹ ï¼š**
```typescript
// ç»ƒä¹ ï¼šä¸ºä¸‹é¢çš„åŠŸèƒ½è®¾è®¡åˆ†å±‚æ¶æ„
// åŠŸèƒ½ï¼šç”¨æˆ·åˆ›å»ºçº¢åŒ…

// ä½ çš„ä»»åŠ¡ï¼š
// 1. è¯†åˆ«æ¶‰åŠçš„å±‚æ¬¡ï¼ˆUIå±‚ã€ä¸šåŠ¡å±‚ã€æ•°æ®å±‚ã€åˆçº¦å±‚ï¼‰
// 2. å®šä¹‰æ¯å±‚çš„èŒè´£
// 3. è®¾è®¡å±‚é—´æ¥å£

// æç¤ºï¼šè€ƒè™‘å‚æ•°éªŒè¯ã€æƒé™æ£€æŸ¥ã€æ•°æ®å­˜å‚¨ã€åˆçº¦è°ƒç”¨
```

#### âš¡ åŸåˆ™2ï¼šäº‹ä»¶é©±åŠ¨è®¾è®¡

**ä¸ºä»€ä¹ˆé€‰æ‹©äº‹ä»¶é©±åŠ¨ï¼Ÿ**

åœ¨åŒºå—é“¾åº”ç”¨ä¸­ï¼Œäº‹ä»¶é©±åŠ¨æ¶æ„ç‰¹åˆ«é‡è¦ï¼š

```typescript
// ä¼ ç»Ÿæ–¹å¼ï¼šè½®è¯¢æ£€æŸ¥çŠ¶æ€
setInterval(async () => {
  const packets = await getRedPackets()
  packets.forEach(packet => {
    if (packet.status !== lastKnownStatus[packet.id]) {
      updateUI(packet)
    }
  })
}, 5000) // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œæµªè´¹èµ„æº

// äº‹ä»¶é©±åŠ¨æ–¹å¼ï¼šå“åº”å¼æ›´æ–°
contract.on('PacketCreated', (packetId, creator, amount) => {
  // ç«‹å³å“åº”æ–°çº¢åŒ…åˆ›å»º
  addNewPacketToUI({
    id: packetId,
    creator,
    amount
  })
})

contract.on('PacketClaimed', (packetId, claimer, amount) => {
  // ç«‹å³å“åº”çº¢åŒ…è¢«é¢†å–
  updatePacketStatus(packetId, 'claimed')
  showClaimNotification(claimer, amount)
})
```

**å®è·µç»ƒä¹ ï¼šè®¾è®¡äº‹ä»¶å¤„ç†å™¨**
```typescript
// ç»ƒä¹ ï¼šè®¾è®¡ä¸€ä¸ªäº‹ä»¶ç®¡ç†ç³»ç»Ÿ
class EventManager {
  private handlers: Map<string, Function[]> = new Map()

  // TODO: å®ç° on æ–¹æ³• - æ³¨å†Œäº‹ä»¶ç›‘å¬
  on(event: string, handler: Function) {
    // ä½ çš„ä»£ç ...
  }

  // TODO: å®ç° emit æ–¹æ³• - è§¦å‘äº‹ä»¶
  emit(event: string, ...args: any[]) {
    // ä½ çš„ä»£ç ...
  }

  // TODO: å®ç° off æ–¹æ³• - ç§»é™¤ç›‘å¬
  off(event: string, handler?: Function) {
    // ä½ çš„ä»£ç ...
  }
}

// å‚è€ƒç­”æ¡ˆåœ¨æ–‡æ¡£æœ«å°¾
```

#### ğŸ”„ åŸåˆ™3ï¼šæ•°æ®ä¸€è‡´æ€§

**æœ€ç»ˆä¸€è‡´æ€§ vs å¼ºä¸€è‡´æ€§**

```typescript
// Web3åº”ç”¨çš„æ•°æ®ä¸€è‡´æ€§æŒ‘æˆ˜
class DataConsistencyManager {
  async handlePacketClaimed(event: PacketClaimedEvent) {
    try {
      // 1. åŒºå—é“¾æ•°æ®ï¼ˆå¼ºä¸€è‡´æ€§ï¼‰
      const onChainData = await this.getOnChainPacket(event.packetId)
      
      // 2. å­å›¾æ•°æ®ï¼ˆæœ€ç»ˆä¸€è‡´æ€§ï¼Œå¯èƒ½å»¶è¿Ÿï¼‰
      const subgraphData = await this.getSubgraphPacket(event.packetId)
      
      // 3. æœ¬åœ°ç¼“å­˜ï¼ˆéœ€è¦ä¸»åŠ¨æ›´æ–°ï¼‰
      const cachedData = this.getFromCache(event.packetId)
      
      // æ•°æ®åŒæ­¥ç­–ç•¥
      if (this.isDataInconsistent(onChainData, subgraphData, cachedData)) {
        await this.reconcileData(event.packetId)
      }
    } catch (error) {
      // ä¸€è‡´æ€§ä¿è¯ï¼šè®°å½•ä¸ä¸€è‡´çŠ¶æ€ï¼Œç¨åé‡è¯•
      this.scheduleRetry(event.packetId)
    }
  }

  private isDataInconsistent(
    onChain: OnChainData, 
    subgraph: SubgraphData, 
    cache: CacheData
  ): boolean {
    return onChain.claimedCount !== subgraph.claimedCount ||
           subgraph.balance !== cache.balance
  }
}
```

### 1.3 åˆ†å±‚èŒè´£è¯¦è§£

è®©æˆ‘ä»¬è¯¦ç»†åˆ†ææ¯ä¸€å±‚çš„èŒè´£ï¼š

#### ğŸ¨ å‰ç«¯åº”ç”¨å±‚ (UI Layer)

**æ ¸å¿ƒèŒè´£ï¼š**
- ç”¨æˆ·ç•Œé¢å±•ç¤º
- ç”¨æˆ·äº¤äº’å¤„ç†
- çŠ¶æ€ç®¡ç†
- è·¯ç”±æ§åˆ¶

```typescript
// ç¤ºä¾‹ï¼šçº¢åŒ…å¡ç‰‡ç»„ä»¶çš„èŒè´£
function RedPacketCard({ packet }: { packet: RedPacket }) {
  // âœ… æ­£ç¡®ï¼šå¤„ç†UIç›¸å…³é€»è¾‘
  const [isExpanded, setIsExpanded] = useState(false)
  const { theme } = useTheme()
  
  // âœ… æ­£ç¡®ï¼šè°ƒç”¨ä¸šåŠ¡å±‚æœåŠ¡
  const { claimPacket, isLoading } = useRedPacketService()
  
  const handleClaim = () => {
    // âœ… æ­£ç¡®ï¼šUIå±‚åªè´Ÿè´£è°ƒç”¨ï¼Œä¸å¤„ç†ä¸šåŠ¡é€»è¾‘
    claimPacket(packet.id)
  }

  // âŒ é”™è¯¯ï¼šä¸è¦åœ¨UIå±‚å¤„ç†å¤æ‚ä¸šåŠ¡é€»è¾‘
  // const amount = calculateRandomAmount(packet.balance, packet.remainingCount)
  
  return (
    <div className={`packet-card ${theme}`}>
      {/* UIæ¸²æŸ“ */}
    </div>
  )
}
```

#### ğŸ“Š æ•°æ®ç´¢å¼•å±‚ (Data Layer)

**æ ¸å¿ƒèŒè´£ï¼š**
- åŒºå—é“¾æ•°æ®ç´¢å¼•
- æŸ¥è¯¢ä¼˜åŒ–
- æ•°æ®èšåˆ
- ç¼“å­˜ç®¡ç†

```typescript
// ç¤ºä¾‹ï¼šæ•°æ®å±‚çš„æŸ¥è¯¢ä¼˜åŒ–
class RedPacketDataService {
  constructor(
    private apolloClient: ApolloClient,
    private cache: RedisCache
  ) {}

  async getRedPackets(filters: PacketFilters): Promise<RedPacket[]> {
    // 1. æ£€æŸ¥ç¼“å­˜
    const cacheKey = this.generateCacheKey(filters)
    const cached = await this.cache.get(cacheKey)
    if (cached && !this.isCacheStale(cached)) {
      return cached.data
    }

    // 2. ä»å­å›¾æŸ¥è¯¢
    const { data } = await this.apolloClient.query({
      query: GET_RED_PACKETS,
      variables: this.buildQueryVariables(filters),
      fetchPolicy: 'cache-first'
    })

    // 3. æ›´æ–°ç¼“å­˜
    await this.cache.set(cacheKey, {
      data: data.redPackets,
      timestamp: Date.now()
    }, { ttl: 300 }) // 5åˆ†é’Ÿç¼“å­˜

    return data.redPackets
  }

  private generateCacheKey(filters: PacketFilters): string {
    return `packets:${JSON.stringify(filters)}`
  }
}
```

#### â›“ï¸ åŒºå—é“¾å±‚ (Blockchain Layer)

**æ ¸å¿ƒèŒè´£ï¼š**
- æ™ºèƒ½åˆçº¦äº¤äº’
- äº¤æ˜“ç®¡ç†
- äº‹ä»¶ç›‘å¬
- ç½‘ç»œçŠ¶æ€ç®¡ç†

```typescript
// ç¤ºä¾‹ï¼šåŒºå—é“¾äº¤äº’æœåŠ¡
class BlockchainService {
  constructor(
    private publicClient: PublicClient,
    private walletClient: WalletClient
  ) {}

  async createRedPacket(params: CreatePacketParams): Promise<TransactionResult> {
    try {
      // 1. å‚æ•°éªŒè¯
      this.validateParams(params)
      
      // 2. Gasä¼°ç®—
      const gasEstimate = await this.estimateGas('createRedPacket', params)
      
      // 3. å‘é€äº¤æ˜“
      const hash = await this.walletClient.writeContract({
        address: RED_PACKET_ADDRESS,
        abi: RED_PACKET_ABI,
        functionName: 'createRedPacket',
        args: [params.message, params.count, params.isEven],
        value: params.value,
        gas: gasEstimate
      })
      
      // 4. ç­‰å¾…ç¡®è®¤
      const receipt = await this.publicClient.waitForTransactionReceipt({ hash })
      
      return {
        success: true,
        hash,
        receipt
      }
    } catch (error) {
      return this.handleError(error)
    }
  }

  private validateParams(params: CreatePacketParams): void {
    if (params.count <= 0 || params.count > 100) {
      throw new ValidationError('çº¢åŒ…ä»½æ•°å¿…é¡»åœ¨1-100ä¹‹é—´')
    }
    if (params.value <= 0) {
      throw new ValidationError('çº¢åŒ…é‡‘é¢å¿…é¡»å¤§äº0')
    }
    // æ›´å¤šéªŒè¯...
  }
}
```

### ğŸ¯ å°ç»“ä¸ç»ƒä¹ 

**å…³é”®takeawayï¼š**
1. æ¸…æ™°çš„åˆ†å±‚è®©ç³»ç»Ÿæ›´å®¹æ˜“ç†è§£å’Œç»´æŠ¤
2. æ¯å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£è¾¹ç•Œ
3. å±‚é—´é€šè¿‡æ¥å£é€šä¿¡ï¼Œé™ä½è€¦åˆåº¦
4. äº‹ä»¶é©±åŠ¨æé«˜ç³»ç»Ÿå“åº”æ€§

**å®è·µç»ƒä¹ ï¼šæ¶æ„è®¾è®¡**
```typescript
// æŒ‘æˆ˜ï¼šä¸ºçº¢åŒ…åˆ†äº«åŠŸèƒ½è®¾è®¡æ¶æ„
// éœ€æ±‚ï¼š
// - ç”¨æˆ·å¯ä»¥åˆ†äº«çº¢åŒ…é“¾æ¥
// - æ”¯æŒç¤¾äº¤åª’ä½“åˆ†äº«
// - åˆ†äº«é“¾æ¥åŒ…å«é¢„è§ˆä¿¡æ¯
// - æ”¯æŒåˆ†äº«ç»Ÿè®¡

// ä½ çš„ä»»åŠ¡ï¼š
// 1. è®¾è®¡åˆ†å±‚æ¶æ„
// 2. å®šä¹‰å„å±‚æ¥å£
// 3. è€ƒè™‘æ•°æ®æµå‘
// 4. è¯†åˆ«æŠ€æœ¯é€‰å‹

// åœ¨ä¸‹ä¸€èŠ‚æˆ‘ä»¬ä¼šçœ‹åˆ°å‚è€ƒå®ç°
```

---

## ğŸ¯ ç¬¬äºŒç« ï¼šæ ¸å¿ƒè®¾è®¡æ¨¡å¼å®æˆ˜ (60min)

> **å­¦ä¹ é‡ç‚¹ï¼š** æŒæ¡DDDã€CQRSã€äº‹ä»¶æº¯æºåœ¨Web3ä¸­çš„å®é™…åº”ç”¨

è®¾è®¡æ¨¡å¼æ˜¯è§£å†³å¸¸è§é—®é¢˜çš„ç»è¿‡éªŒè¯çš„æ–¹æ¡ˆã€‚åœ¨Web3åº”ç”¨ä¸­ï¼Œåˆé€‚çš„è®¾è®¡æ¨¡å¼èƒ½å¤Ÿæ˜¾è‘—æé«˜ä»£ç è´¨é‡å’Œç³»ç»Ÿå¯ç»´æŠ¤æ€§ã€‚

### 2.1 é¢†åŸŸé©±åŠ¨è®¾è®¡ (DDD) å®æˆ˜

> **ä¸ºä»€ä¹ˆDDDé€‚åˆWeb3ï¼Ÿ** åŒºå—é“¾åº”ç”¨é€šå¸¸æ¶‰åŠå¤æ‚çš„ä¸šåŠ¡é€»è¾‘ï¼ˆé‡‘èã€æ²»ç†ã€NFTç­‰ï¼‰ï¼ŒDDDå¸®åŠ©æˆ‘ä»¬å°†å¤æ‚åº¦æ§åˆ¶åœ¨é¢†åŸŸå±‚ï¼Œä¿æŒä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

#### ğŸ§© æ­¥éª¤1ï¼šè¯†åˆ«é¢†åŸŸæ¦‚å¿µ

è®©æˆ‘ä»¬ä»çº¢åŒ…ç³»ç»Ÿçš„ä¸šåŠ¡éœ€æ±‚å¼€å§‹ï¼š

```typescript
// ä¸šåŠ¡éœ€æ±‚åˆ†æ
/**
 * ç”¨æˆ·æ•…äº‹ï¼š
 * - ä½œä¸ºå‘çº¢åŒ…è€…ï¼Œæˆ‘æƒ³åˆ›å»ºä¸€ä¸ªçº¢åŒ…ï¼Œè®¾ç½®é‡‘é¢å’Œä»½æ•°
 * - ä½œä¸ºé¢†å–è€…ï¼Œæˆ‘æƒ³é¢†å–çº¢åŒ…ï¼Œè·å¾—éšæœºæˆ–å¹³å‡é‡‘é¢  
 * - ä½œä¸ºå‘çº¢åŒ…è€…ï¼Œæˆ‘æƒ³åœ¨24å°æ—¶åæå–æœªé¢†å®Œçš„çº¢åŒ…
 * 
 * ä»ä¸­æˆ‘ä»¬å¯ä»¥è¯†åˆ«å‡ºï¼š
 * å®ä½“ï¼šRedPacketï¼ˆçº¢åŒ…ï¼‰ã€Userï¼ˆç”¨æˆ·ï¼‰ã€Claimï¼ˆé¢†å–è®°å½•ï¼‰
 * å€¼å¯¹è±¡ï¼šMoneyï¼ˆé‡‘é¢ï¼‰ã€Messageï¼ˆæ¶ˆæ¯ï¼‰ã€ClaimStatusï¼ˆçŠ¶æ€ï¼‰
 * èšåˆæ ¹ï¼šRedPacketï¼ˆçº¢åŒ…èšåˆï¼‰
 * é¢†åŸŸæœåŠ¡ï¼šDistributionServiceï¼ˆåˆ†é…æœåŠ¡ï¼‰
 */
```

#### ğŸ—ï¸ æ­¥éª¤2ï¼šè®¾è®¡å€¼å¯¹è±¡ (Value Objects)

å€¼å¯¹è±¡æ˜¯ä¸å¯å˜çš„ï¼Œç”¨æ¥è¡¨ç¤ºé¢†åŸŸæ¦‚å¿µï¼š

```typescript
// ğŸ’° Moneyå€¼å¯¹è±¡ - å¤„ç†æ‰€æœ‰é‡‘é’±ç›¸å…³é€»è¾‘
class Money {
  private constructor(
    private readonly amount: bigint,
    private readonly decimals: number = 18
  ) {
    // ä¸å˜æ€§æ£€æŸ¥
    if (amount < 0n) {
      throw new Error('é‡‘é¢ä¸èƒ½ä¸ºè´Ÿæ•°')
    }
  }

  // å·¥å‚æ–¹æ³•
  static fromEther(ether: string): Money {
    return new Money(parseEther(ether))
  }

  static fromWei(wei: bigint): Money {
    return new Money(wei)
  }

  // ä¸šåŠ¡æ–¹æ³•
  add(other: Money): Money {
    return new Money(this.amount + other.amount, this.decimals)
  }

  subtract(other: Money): Money {
    if (this.amount < other.amount) {
      throw new Error('ä½™é¢ä¸è¶³')
    }
    return new Money(this.amount - other.amount, this.decimals)
  }

  multiply(factor: number): Money {
    return new Money(this.amount * BigInt(Math.floor(factor * 1000)) / 1000n, this.decimals)
  }

  // æŸ¥è¯¢æ–¹æ³•
  toWei(): bigint { return this.amount }
  toEther(): string { return formatEther(this.amount) }
  isZero(): boolean { return this.amount === 0n }
  isGreaterThan(other: Money): boolean { return this.amount > other.amount }
  equals(other: Money): boolean { return this.amount === other.amount }

  // æ ¼å¼åŒ–æ˜¾ç¤º
  format(precision: number = 4): string {
    const ether = this.toEther()
    return parseFloat(ether).toFixed(precision)
  }
}

// ğŸ“ Messageå€¼å¯¹è±¡ - å¤„ç†æ¶ˆæ¯éªŒè¯å’Œæ ¼å¼åŒ–
class Message {
  private constructor(private readonly content: string) {
    this.validate(content)
  }

  static create(content: string): Message {
    return new Message(content.trim())
  }

  private validate(content: string): void {
    if (!content || content.trim().length === 0) {
      throw new Error('ç¥ç¦è¯­ä¸èƒ½ä¸ºç©º')
    }
    if (content.length > 200) {
      throw new Error('ç¥ç¦è¯­ä¸èƒ½è¶…è¿‡200ä¸ªå­—ç¬¦')
    }
    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ¶æ„å†…å®¹
    if (this.containsMaliciousContent(content)) {
      throw new Error('ç¥ç¦è¯­åŒ…å«ä¸å½“å†…å®¹')
    }
  }

  private containsMaliciousContent(content: string): boolean {
    const maliciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+\s*=/i
    ]
    return maliciousPatterns.some(pattern => pattern.test(content))
  }

  toString(): string { return this.content }
  length(): number { return this.content.length }
  isEmpty(): boolean { return this.content.trim().length === 0 }
}

// ğŸ¯ ç»ƒä¹ ï¼šè®¾è®¡ClaimStatuså€¼å¯¹è±¡
// TODO: å®ç°ClaimStatuså€¼å¯¹è±¡ï¼ŒåŒ…å«ä»¥ä¸‹çŠ¶æ€ï¼š
// - AVAILABLE: å¯é¢†å–
// - CLAIMED: å·²é¢†å–  
// - EXPIRED: å·²è¿‡æœŸ
// - EMPTY: å·²æŠ¢å®Œ
// è¦æ±‚ï¼šåŒ…å«çŠ¶æ€è½¬æ¢é€»è¾‘å’ŒéªŒè¯
```

#### ğŸª æ­¥éª¤3ï¼šæ„å»ºèšåˆæ ¹

èšåˆæ ¹æ˜¯ä¸šåŠ¡é€»è¾‘çš„æ ¸å¿ƒï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼š

```typescript
// ğŸ§§ RedPacketèšåˆæ ¹ - çº¢åŒ…çš„å®Œæ•´ä¸šåŠ¡é€»è¾‘
class RedPacket {
  // ç§æœ‰æ„é€ å‡½æ•°ï¼Œå¼ºåˆ¶ä½¿ç”¨å·¥å‚æ–¹æ³•
  private constructor(
    private readonly id: RedPacketId,
    private readonly creator: Address,
    private readonly message: Message,
    private totalAmount: Money,
    private balance: Money,
    private readonly totalCount: number,
    private claimedCount: number,
    private readonly isEven: boolean,
    private readonly creationTime: Date,
    private claims: Claim[] = [],
    private version: number = 1 // ç”¨äºå¹¶å‘æ§åˆ¶
  ) {}

  // å·¥å‚æ–¹æ³• - åˆ›å»ºæ–°çº¢åŒ…
  static create(
    id: RedPacketId,
    creator: Address,
    message: Message,
    amount: Money,
    count: number,
    isEven: boolean
  ): RedPacket {
    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if (count <= 0 || count > 100) {
      throw new Error('çº¢åŒ…ä»½æ•°å¿…é¡»åœ¨1-100ä¹‹é—´')
    }
    
    const minAmountPerPacket = Money.fromWei(1000n) // æœ€å°0.000001 ETH
    if (amount.toWei() / BigInt(count) < minAmountPerPacket.toWei()) {
      throw new Error('æ¯ä»½çº¢åŒ…é‡‘é¢è¿‡å°')
    }

    return new RedPacket(
      id, creator, message, amount, amount, // åˆå§‹ä½™é¢=æ€»é‡‘é¢
      count, 0, isEven, new Date()
    )
  }

  // æ ¸å¿ƒä¸šåŠ¡æ–¹æ³• - é¢†å–çº¢åŒ…
  claim(claimer: Address, distributionService: DistributionService): ClaimResult {
    // å‰ç½®æ¡ä»¶æ£€æŸ¥
    if (!this.canBeClaimed()) {
      return ClaimResult.failure(
        this.isExpired() ? 'çº¢åŒ…å·²è¿‡æœŸ' :
        this.isEmpty() ? 'çº¢åŒ…å·²è¢«æŠ¢å®Œ' :
        'çº¢åŒ…ä¸å¯é¢†å–'
      )
    }

    if (this.hasBeenClaimedBy(claimer)) {
      return ClaimResult.failure('æ‚¨å·²ç»é¢†å–è¿‡è¿™ä¸ªçº¢åŒ…')
    }

    // è®¡ç®—é¢†å–é‡‘é¢
    const amount = distributionService.calculateClaimAmount(
      this.balance,
      this.totalCount - this.claimedCount,
      this.isEven
    )

    // åˆ›å»ºé¢†å–è®°å½•
    const claim = Claim.create(
      this.id,
      claimer,
      amount,
      this.claimedCount + 1
    )

    // æ›´æ–°èšåˆçŠ¶æ€ï¼ˆåŸå­æ“ä½œï¼‰
    this.claims.push(claim)
    this.claimedCount++
    this.balance = this.balance.subtract(amount)
    this.version++ // ç‰ˆæœ¬å·é€’å¢

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.publishEvent(new PacketClaimedEvent(
      this.id.toString(),
      claimer,
      amount.toWei(),
      this.claimedCount
    ))

    return ClaimResult.success(claim)
  }

  // æŸ¥è¯¢æ–¹æ³•
  canBeClaimed(): boolean {
    return !this.isEmpty() && !this.isExpired() && this.balance.isGreaterThan(Money.fromWei(0n))
  }

  isEmpty(): boolean {
    return this.claimedCount >= this.totalCount
  }

  isExpired(): boolean {
    const expirationTime = new Date(this.creationTime.getTime() + 24 * 60 * 60 * 1000)
    return new Date() > expirationTime
  }

  hasBeenClaimedBy(address: Address): boolean {
    return this.claims.some(claim => claim.claimer === address)
  }

  // Getteræ–¹æ³•ï¼ˆåªè¯»è®¿é—®ï¼‰
  getId(): RedPacketId { return this.id }
  getCreator(): Address { return this.creator }
  getMessage(): Message { return this.message }
  getTotalAmount(): Money { return this.totalAmount }
  getBalance(): Money { return this.balance }
  getClaimedCount(): number { return this.claimedCount }
  getTotalCount(): number { return this.totalCount }
  getClaims(): ReadonlyArray<Claim> { return this.claims }
  getVersion(): number { return this.version }

  // é¢†åŸŸäº‹ä»¶å‘å¸ƒï¼ˆç®€åŒ–å®ç°ï¼‰
  private events: DomainEvent[] = []
  
  private publishEvent(event: DomainEvent): void {
    this.events.push(event)
  }

  getUncommittedEvents(): DomainEvent[] {
    return [...this.events]
  }

  markEventsAsCommitted(): void {
    this.events = []
  }
}

// ğŸ¯ å®è·µç»ƒä¹ ï¼šå®ç°æå–åŠŸèƒ½
// TODO: åœ¨RedPacketèšåˆæ ¹ä¸­æ·»åŠ withdrawæ–¹æ³•
// è¦æ±‚ï¼š
// 1. åªæœ‰åˆ›å»ºè€…å¯ä»¥æå–
// 2. åªæœ‰è¿‡æœŸåæ‰èƒ½æå–
// 3. åªèƒ½æå–å‰©ä½™é‡‘é¢
// 4. æ›´æ–°èšåˆçŠ¶æ€
// 5. å‘å¸ƒWithdrawEventäº‹ä»¶
```

#### ğŸ› ï¸ æ­¥éª¤4ï¼šå®ç°é¢†åŸŸæœåŠ¡

é¢†åŸŸæœåŠ¡å¤„ç†è·¨èšåˆçš„ä¸šåŠ¡é€»è¾‘ï¼š

```typescript
// ğŸ“Š åˆ†é…æœåŠ¡ - å¤„ç†çº¢åŒ…é‡‘é¢åˆ†é…é€»è¾‘
class DistributionService {
  calculateClaimAmount(
    remainingBalance: Money,
    remainingCount: number,
    isEven: boolean
  ): Money {
    if (remainingCount <= 0) {
      throw new Error('æ²¡æœ‰å‰©ä½™çº¢åŒ…å¯é¢†å–')
    }

    if (isEven) {
      return this.calculateEvenAmount(remainingBalance, remainingCount)
    } else {
      return this.calculateRandomAmount(remainingBalance, remainingCount)
    }
  }

  private calculateEvenAmount(balance: Money, count: number): Money {
    // å¹³å‡åˆ†é…ï¼Œå¤„ç†é™¤ä¸å°½çš„æƒ…å†µ
    const baseAmount = balance.toWei() / BigInt(count)
    return Money.fromWei(baseAmount)
  }

  private calculateRandomAmount(balance: Money, count: number): Money {
    if (count === 1) {
      // æœ€åä¸€ä¸ªçº¢åŒ…ï¼Œè¿”å›å…¨éƒ¨ä½™é¢
      return balance
    }

    // éšæœºç®—æ³•ï¼šç¡®ä¿æ¯ä¸ªçº¢åŒ…è‡³å°‘1weiï¼Œå‰©ä½™éƒ¨åˆ†éšæœºåˆ†é…
    const minAmount = Money.fromWei(1n)
    const maxAmount = balance.toWei() - BigInt(count - 1) // ä¿è¯å‰©ä½™çº¢åŒ…è‡³å°‘1wei
    
    // ä½¿ç”¨çº¿æ€§åŒä½™ç”Ÿæˆå™¨ï¼ˆåœ¨æ™ºèƒ½åˆçº¦ä¸­å¸¸ç”¨ï¼‰
    const seed = BigInt(Date.now()) + balance.toWei()
    const randomValue = (seed * 1103515245n + 12345n) % maxAmount
    
    const amount = randomValue < minAmount.toWei() ? minAmount.toWei() : randomValue
    return Money.fromWei(amount)
  }

  // ğŸ¯ ç»ƒä¹ æ–¹æ³•ï¼šéªŒè¯åˆ†é…ç®—æ³•
  validateDistribution(
    totalAmount: Money,
    amounts: Money[],
    isEven: boolean
  ): ValidationResult {
    // TODO: å®ç°åˆ†é…éªŒè¯é€»è¾‘
    // 1. éªŒè¯æ€»é‡‘é¢æ˜¯å¦åŒ¹é…
    // 2. éªŒè¯æ¯ä»½é‡‘é¢æ˜¯å¦åˆç†
    // 3. å¯¹äºå¹³å‡åˆ†é…ï¼ŒéªŒè¯å·®å¼‚æ˜¯å¦åœ¨å…è®¸èŒƒå›´å†…
    // è¿”å›éªŒè¯ç»“æœå’Œè¯¦ç»†ä¿¡æ¯
  }
}

// ğŸ” è¿‡æœŸæ£€æŸ¥æœåŠ¡
class ExpirationService {
  isExpired(creationTime: Date, expirationHours: number = 24): boolean {
    const expirationTime = new Date(
      creationTime.getTime() + expirationHours * 60 * 60 * 1000
    )
    return new Date() > expirationTime
  }

  getTimeUntilExpiration(creationTime: Date): TimeRemaining {
    const expirationTime = new Date(creationTime.getTime() + 24 * 60 * 60 * 1000)
    const now = new Date()
    const remaining = expirationTime.getTime() - now.getTime()

    if (remaining <= 0) {
      return { expired: true, hours: 0, minutes: 0, seconds: 0 }
    }

    const hours = Math.floor(remaining / (1000 * 60 * 60))
    const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60))
    const seconds = Math.floor((remaining % (1000 * 60)) / 1000)

    return { expired: false, hours, minutes, seconds }
  }
}

interface TimeRemaining {
  expired: boolean
  hours: number
  minutes: number
  seconds: number
}
```

### ğŸ’¡ DDDæœ€ä½³å®è·µæ€»ç»“

1. **èšåˆè¾¹ç•Œè¦å°** - ä¸€ä¸ªèšåˆåº”è¯¥èƒ½åœ¨å•ä¸ªäº‹åŠ¡ä¸­ä¿æŒä¸€è‡´æ€§
2. **é€šè¿‡IDå¼•ç”¨å…¶ä»–èšåˆ** - ä¸è¦ç›´æ¥æŒæœ‰å…¶ä»–èšåˆçš„å¼•ç”¨
3. **ä½¿ç”¨å·¥å‚æ–¹æ³•** - ç¡®ä¿èšåˆåˆ›å»ºæ—¶çš„ä¸šåŠ¡è§„åˆ™
4. **ä¸å¯å˜å€¼å¯¹è±¡** - å€¼å¯¹è±¡åˆ›å»ºåä¸åº”è¯¥æ”¹å˜
5. **å‘å¸ƒé¢†åŸŸäº‹ä»¶** - è®©å…¶ä»–è¾¹ç•Œä¸Šä¸‹æ–‡çŸ¥é“é‡è¦çš„ä¸šåŠ¡å˜åŒ–

```
çº¢åŒ…ç³»ç»Ÿé¢†åŸŸæ¨¡å‹
â”œâ”€â”€ èšåˆæ ¹ (Aggregate Root)
â”‚   â””â”€â”€ RedPacket çº¢åŒ…èšåˆ
â”‚       â”œâ”€â”€ å€¼å¯¹è±¡ (Value Objects)
â”‚       â”‚   â”œâ”€â”€ Money (é‡‘é¢)
â”‚       â”‚   â”œâ”€â”€ Message (ç¥ç¦è¯­)
â”‚       â”‚   â””â”€â”€ ClaimStatus (é¢†å–çŠ¶æ€)
â”‚       â””â”€â”€ å®ä½“ (Entities)
â”‚           â””â”€â”€ Claim (é¢†å–è®°å½•)
â”œâ”€â”€ é¢†åŸŸæœåŠ¡ (Domain Services)
â”‚   â”œâ”€â”€ RedPacketDistributionService
â”‚   â”œâ”€â”€ RandomAmountCalculator
â”‚   â””â”€â”€ ExpirationChecker
â””â”€â”€ ä»“å‚¨ (Repository)
    â”œâ”€â”€ RedPacketRepository
    â””â”€â”€ UserRepository
```

**é¢†åŸŸæ¨¡å‹å®ç°**:
```typescript
// å€¼å¯¹è±¡ - é‡‘é¢
class Money {
  constructor(
    private readonly amount: bigint,
    private readonly decimals: number = 18
  ) {
    if (amount < 0n) {
      throw new Error('Amount cannot be negative')
    }
  }

  toWei(): bigint {
    return this.amount
  }

  toEther(): string {
    return formatEther(this.amount)
  }

  add(other: Money): Money {
    return new Money(this.amount + other.amount, this.decimals)
  }

  subtract(other: Money): Money {
    if (this.amount < other.amount) {
      throw new Error('Insufficient balance')
    }
    return new Money(this.amount - other.amount, this.decimals)
  }

  equals(other: Money): boolean {
    return this.amount === other.amount
  }

  isZero(): boolean {
    return this.amount === 0n
  }
}

// èšåˆæ ¹ - çº¢åŒ…
class RedPacket {
  private constructor(
    public readonly id: RedPacketId,
    public readonly creator: Address,
    public readonly message: Message,
    private totalAmount: Money,
    private balance: Money,
    public readonly totalCount: number,
    private claimedCount: number,
    public readonly isEven: boolean,
    public readonly creationTime: Date,
    private claims: Claim[] = []
  ) {}

  static create(
    id: RedPacketId,
    creator: Address,
    message: Message,
    amount: Money,
    count: number,
    isEven: boolean
  ): RedPacket {
    return new RedPacket(
      id,
      creator,
      message,
      amount,
      amount, // åˆå§‹ä½™é¢ç­‰äºæ€»é‡‘é¢
      count,
      0,
      isEven,
      new Date()
    )
  }

  canBeClaimed(): boolean {
    return this.claimedCount < this.totalCount && !this.balance.isZero()
  }

  hasBeenClaimedBy(address: Address): boolean {
    return this.claims.some(claim => claim.claimer === address)
  }

  claim(claimer: Address, distributionService: RedPacketDistributionService): ClaimResult {
    if (!this.canBeClaimed()) {
      return ClaimResult.failure('No packets left')
    }

    if (this.hasBeenClaimedBy(claimer)) {
      return ClaimResult.failure('Already claimed')
    }

    const amount = distributionService.calculateClaimAmount(
      this.balance,
      this.totalCount - this.claimedCount,
      this.isEven
    )

    const claim = new Claim(
      this.id,
      claimer,
      amount,
      new Date(),
      this.claimedCount + 1
    )

    this.claims.push(claim)
    this.claimedCount++
    this.balance = this.balance.subtract(amount)

    return ClaimResult.success(claim)
  }

  isExpired(): boolean {
    const expirationTime = new Date(this.creationTime.getTime() + 24 * 60 * 60 * 1000)
    return new Date() > expirationTime
  }

  withdraw(requester: Address): WithdrawResult {
    if (requester !== this.creator) {
      return WithdrawResult.failure('Not owner')
    }

    if (!this.isExpired()) {
      return WithdrawResult.failure('Not expired yet')
    }

    if (this.balance.isZero()) {
      return WithdrawResult.failure('No balance to withdraw')
    }

    const amount = this.balance
    this.balance = new Money(0n)

    return WithdrawResult.success(amount)
  }
}
```

### 2.2 CQRS æ¨¡å¼å®æˆ˜åº”ç”¨

> **ä¸ºä»€ä¹ˆWeb3éœ€è¦CQRSï¼Ÿ** åŒºå—é“¾çš„è¯»å†™ç‰¹æ€§å¤©ç„¶é€‚åˆCQRSï¼šå†™æ“ä½œï¼ˆäº¤æ˜“ï¼‰æ˜‚è´µä¸”æ…¢ï¼Œè¯»æ“ä½œï¼ˆæŸ¥è¯¢ï¼‰éœ€è¦å¿«é€Ÿä¸”å¤æ‚ã€‚CQRSè®©æˆ‘ä»¬å¯ä»¥åˆ†åˆ«ä¼˜åŒ–è¯»å†™è·¯å¾„ã€‚

#### âš¡ æ ¸å¿ƒæ¦‚å¿µç†è§£

```typescript
// ä¼ ç»Ÿæ–¹å¼ï¼šè¯»å†™ä½¿ç”¨ç›¸åŒæ¨¡å‹
class TraditionalRedPacketService {
  // âŒ è¯»å†™è€¦åˆï¼Œéš¾ä»¥åˆ†åˆ«ä¼˜åŒ–
  async getRedPacket(id: string): Promise<RedPacket> {
    // ä»æ•°æ®åº“è·å–ï¼Œå¯èƒ½åŒ…å«ä¸å¿…è¦çš„å­—æ®µ
    return await this.repository.findById(id)
  }

  async createRedPacket(params: CreateParams): Promise<RedPacket> {
    // å†™æ“ä½œï¼Œä½†è¿”å›å®Œæ•´å¯¹è±¡ç”¨äºæ˜¾ç¤º
    const packet = new RedPacket(params)
    await this.repository.save(packet)
    return packet // å¯èƒ½éœ€è¦é¢å¤–æŸ¥è¯¢æ¥è·å–æ˜¾ç¤ºæ•°æ®
  }
}

// CQRSæ–¹å¼ï¼šè¯»å†™åˆ†ç¦»
class CQRSRedPacketService {
  constructor(
    private commandHandler: RedPacketCommandHandler,
    private queryHandler: RedPacketQueryHandler
  ) {}

  // âœ… å†™æ“ä½œï¼šä¸“æ³¨äºä¸šåŠ¡é€»è¾‘æ‰§è¡Œ
  async createRedPacket(command: CreateRedPacketCommand): Promise<CommandResult> {
    return await this.commandHandler.handle(command)
  }

  // âœ… è¯»æ“ä½œï¼šä¸“æ³¨äºæ•°æ®è·å–å’Œå±•ç¤ºä¼˜åŒ–
  async getRedPacketSummary(query: GetRedPacketQuery): Promise<RedPacketSummary> {
    return await this.queryHandler.handle(query)
  }
}
```

#### ğŸ¯ æ­¥éª¤1ï¼šè®¾è®¡å‘½ä»¤ç«¯ (Write Side)

å‘½ä»¤ç«¯ä¸“æ³¨äºä¸šåŠ¡é€»è¾‘æ‰§è¡Œå’ŒçŠ¶æ€å˜æ›´ï¼š

```typescript
// å‘½ä»¤æ¥å£å®šä¹‰
abstract class Command {
  abstract readonly commandId: string
  abstract readonly timestamp: Date
  abstract validate(): ValidationResult
}

// å…·ä½“å‘½ä»¤å®ç°
class CreateRedPacketCommand extends Command {
  readonly commandId: string
  readonly timestamp: Date

  constructor(
    public readonly creator: Address,
    public readonly message: string,
    public readonly totalAmount: bigint,
    public readonly count: number,
    public readonly isEven: boolean
  ) {
    super()
    this.commandId = crypto.randomUUID()
    this.timestamp = new Date()
  }

  validate(): ValidationResult {
    const errors: string[] = []

    if (!this.message || this.message.trim().length === 0) {
      errors.push('ç¥ç¦è¯­ä¸èƒ½ä¸ºç©º')
    }

    if (this.count <= 0 || this.count > 100) {
      errors.push('çº¢åŒ…ä»½æ•°å¿…é¡»åœ¨1-100ä¹‹é—´')
    }

    if (this.totalAmount <= 0n) {
      errors.push('çº¢åŒ…é‡‘é¢å¿…é¡»å¤§äº0')
    }

    const minAmountPerPacket = this.totalAmount / BigInt(this.count)
    if (minAmountPerPacket < 1000n) { // æœ€å°0.000001 ETH
      errors.push('æ¯ä»½çº¢åŒ…é‡‘é¢è¿‡å°')
    }

    return {
      isValid: errors.length === 0,
      errors
    }
  }
}

class ClaimRedPacketCommand extends Command {
  readonly commandId: string
  readonly timestamp: Date

  constructor(
    public readonly packetId: string,
    public readonly claimer: Address
  ) {
    super()
    this.commandId = crypto.randomUUID()
    this.timestamp = new Date()
  }

  validate(): ValidationResult {
    const errors: string[] = []

    if (!this.packetId) {
      errors.push('çº¢åŒ…IDä¸èƒ½ä¸ºç©º')
    }

    if (!this.claimer || this.claimer.length !== 42) {
      errors.push('æ— æ•ˆçš„é¢†å–è€…åœ°å€')
    }

    return {
      isValid: errors.length === 0,
      errors
    }
  }
}

// å‘½ä»¤å¤„ç†å™¨
class RedPacketCommandHandler {
  constructor(
    private walletClient: WalletClient,
    private repository: RedPacketRepository,
    private eventBus: EventBus
  ) {}

  async handle(command: CreateRedPacketCommand): Promise<CommandResult> {
    try {
      // 1. éªŒè¯å‘½ä»¤
      const validation = command.validate()
      if (!validation.isValid) {
        return CommandResult.validationFailure(validation.errors)
      }

      // 2. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
      const redPacket = RedPacket.create(
        RedPacketId.generate(),
        command.creator,
        Message.create(command.message),
        Money.fromWei(command.totalAmount),
        command.count,
        command.isEven
      )

      // 3. è°ƒç”¨æ™ºèƒ½åˆçº¦
      const hash = await this.walletClient.writeContract({
        address: RED_PACKET_ADDRESS,
        abi: RED_PACKET_ABI,
        functionName: 'createRedPacket',
        args: [command.message, command.count, command.isEven],
        value: command.totalAmount
      })

      // 4. ä¿å­˜åˆ°äº‹ä»¶å­˜å‚¨ï¼ˆå¯é€‰ï¼‰
      await this.repository.save(redPacket)

      // 5. å‘å¸ƒäº‹ä»¶
      const events = redPacket.getUncommittedEvents()
      await this.eventBus.publishAll(events)
      redPacket.markEventsAsCommitted()

      return CommandResult.success({
        transactionHash: hash,
        redPacketId: redPacket.getId().toString()
      })

    } catch (error) {
      // 6. é”™è¯¯å¤„ç†
      if (error.message?.includes('User rejected')) {
        return CommandResult.userRejection('ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“')
      }
      
      return CommandResult.failure(error.message)
    }
  }

  async handle(command: ClaimRedPacketCommand): Promise<CommandResult> {
    // ğŸ¯ ç»ƒä¹ ï¼šå®ç°ClaimRedPacketCommandçš„å¤„ç†é€»è¾‘
    // TODO: 
    // 1. éªŒè¯å‘½ä»¤
    // 2. ä»ä»“å‚¨è·å–çº¢åŒ…èšåˆ
    // 3. è°ƒç”¨èšåˆçš„claimæ–¹æ³•
    // 4. æ‰§è¡Œæ™ºèƒ½åˆçº¦è°ƒç”¨
    // 5. ä¿å­˜èšåˆçŠ¶æ€
    // 6. å‘å¸ƒäº‹ä»¶
    // å‚è€ƒCreateRedPacketCommandçš„å®ç°æ¨¡å¼
  }
}

// å‘½ä»¤ç»“æœç±»å‹
class CommandResult {
  private constructor(
    public readonly success: boolean,
    public readonly data?: any,
    public readonly error?: string,
    public readonly type?: 'validation' | 'business' | 'technical' | 'user_rejection'
  ) {}

  static success(data?: any): CommandResult {
    return new CommandResult(true, data)
  }

  static failure(error: string): CommandResult {
    return new CommandResult(false, undefined, error, 'technical')
  }

  static validationFailure(errors: string[]): CommandResult {
    return new CommandResult(false, undefined, errors.join(', '), 'validation')
  }

  static userRejection(message: string): CommandResult {
    return new CommandResult(false, undefined, message, 'user_rejection')
  }
}
```

#### ğŸ“Š æ­¥éª¤2ï¼šè®¾è®¡æŸ¥è¯¢ç«¯ (Read Side)

æŸ¥è¯¢ç«¯ä¸“æ³¨äºæ•°æ®æ£€ç´¢å’Œå±•ç¤ºä¼˜åŒ–ï¼š

```typescript
// æŸ¥è¯¢æ¥å£å®šä¹‰
interface Query {
  readonly queryId: string
  readonly timestamp: Date
}

// æŸ¥è¯¢å¯¹è±¡ - ä¸“ä¸ºUIå±•ç¤ºä¼˜åŒ–
interface RedPacketSummary {
  id: string
  creator: Address
  creatorENS?: string
  message: string
  totalAmount: string // æ ¼å¼åŒ–çš„ETHé‡‘é¢
  totalCount: number
  claimedCount: number
  remainingCount: number
  isActive: boolean
  expirationTime: Date
  timeRemaining?: {
    hours: number
    minutes: number
    seconds: number
  }
  canClaim: boolean
  averageAmount?: string
  distributionType: 'random' | 'even'
}

interface RedPacketDetail extends RedPacketSummary {
  claims: ClaimSummary[]
  creationTransaction: string
  claimHistory: {
    hourly: number[]
    daily: number[]
  }
}

interface ClaimSummary {
  claimer: Address
  claimerENS?: string
  amount: string
  claimTime: Date
  claimIndex: number
  transactionHash: string
}

// å…·ä½“æŸ¥è¯¢å®ç°
class GetRedPacketsQuery implements Query {
  readonly queryId: string = crypto.randomUUID()
  readonly timestamp: Date = new Date()

  constructor(
    public readonly filters: {
      creator?: Address
      isActive?: boolean
      minAmount?: string
      maxAmount?: string
    } = {},
    public readonly pagination: {
      first: number
      skip: number
    } = { first: 20, skip: 0 },
    public readonly sorting: {
      field: 'creationTime' | 'totalAmount' | 'claimedCount'
      direction: 'asc' | 'desc'
    } = { field: 'creationTime', direction: 'desc' }
  ) {}
}

class GetRedPacketDetailQuery implements Query {
  readonly queryId: string = crypto.randomUUID()
  readonly timestamp: Date = new Date()

  constructor(
    public readonly packetId: string,
    public readonly includeHistory: boolean = false
  ) {}
}

// æŸ¥è¯¢å¤„ç†å™¨
class RedPacketQueryHandler {
  constructor(
    private apolloClient: ApolloClient<any>,
    private cacheService: CacheService,
    private ensService: ENSService
  ) {}

  async handle(query: GetRedPacketsQuery): Promise<RedPacketSummary[]> {
    // 1. æ£€æŸ¥ç¼“å­˜
    const cacheKey = this.buildCacheKey('red_packets', query)
    const cached = await this.cacheService.get<RedPacketSummary[]>(cacheKey)
    if (cached) {
      return cached
    }

    // 2. æ„å»ºGraphQLæŸ¥è¯¢
    const gqlQuery = this.buildGraphQLQuery(query)
    const { data } = await this.apolloClient.query({
      query: gqlQuery.query,
      variables: gqlQuery.variables,
      fetchPolicy: 'cache-first'
    })

    // 3. æ•°æ®è½¬æ¢å’Œå¢å¼º
    const packets = await this.enhancePacketsData(data.redPackets)

    // 4. æ›´æ–°ç¼“å­˜
    await this.cacheService.set(cacheKey, packets, { ttl: 60 }) // 1åˆ†é’Ÿç¼“å­˜

    return packets
  }

  async handle(query: GetRedPacketDetailQuery): Promise<RedPacketDetail> {
    const cacheKey = this.buildCacheKey('red_packet_detail', query)
    const cached = await this.cacheService.get<RedPacketDetail>(cacheKey)
    if (cached) {
      return cached
    }

    const { data } = await this.apolloClient.query({
      query: GET_RED_PACKET_DETAIL,
      variables: { 
        id: query.packetId,
        includeHistory: query.includeHistory
      }
    })

    const detail = await this.enhancePacketDetail(data.redPacket)
    await this.cacheService.set(cacheKey, detail, { ttl: 30 }) // 30ç§’ç¼“å­˜

    return detail
  }

  private async enhancePacketsData(rawPackets: any[]): Promise<RedPacketSummary[]> {
    // æ‰¹é‡è·å–ENSåç§°
    const addresses = [...new Set(rawPackets.map(p => p.creator))]
    const ensNames = await this.ensService.batchResolveNames(addresses)

    return rawPackets.map(packet => ({
      id: packet.id,
      creator: packet.creator,
      creatorENS: ensNames.get(packet.creator),
      message: packet.message,
      totalAmount: formatEther(packet.totalAmount),
      totalCount: packet.totalCount,
      claimedCount: packet.claimedCount,
      remainingCount: packet.totalCount - packet.claimedCount,
      isActive: packet.claimedCount < packet.totalCount && !this.isExpired(packet.creationTime),
      expirationTime: new Date(packet.creationTime * 1000 + 24 * 60 * 60 * 1000),
      canClaim: this.canUserClaim(packet),
      averageAmount: packet.isEven ? 
        formatEther(BigInt(packet.totalAmount) / BigInt(packet.totalCount)) : 
        undefined,
      distributionType: packet.isEven ? 'even' : 'random'
    }))
  }

  // ğŸ¯ ç»ƒä¹ æ–¹æ³•ï¼šå®ç°æŸ¥è¯¢ä¼˜åŒ–
  private buildGraphQLQuery(query: GetRedPacketsQuery) {
    // TODO: æ ¹æ®æŸ¥è¯¢å‚æ•°åŠ¨æ€æ„å»ºGraphQLæŸ¥è¯¢
    // 1. å¤„ç†è¿‡æ»¤æ¡ä»¶
    // 2. å¤„ç†åˆ†é¡µå‚æ•°
    // 3. å¤„ç†æ’åºå‚æ•°
    // 4. åªé€‰æ‹©å¿…è¦çš„å­—æ®µ
    // è¿”å› { query: DocumentNode, variables: any }
  }
}

// GraphQLæŸ¥è¯¢å®šä¹‰
const GET_RED_PACKETS = gql`
  query GetRedPackets(
    $first: Int!
    $skip: Int!
    $where: RedPacket_filter
    $orderBy: RedPacket_orderBy
    $orderDirection: OrderDirection
  ) {
    redPackets(
      first: $first
      skip: $skip
      where: $where
      orderBy: $orderBy
      orderDirection: $orderDirection
    ) {
      id
      creator
      message
      totalAmount
      totalCount
      claimedCount
      isEven
      creationTime
      # ä¸è·å–claimsä»¥å‡å°‘æ•°æ®ä¼ è¾“
    }
  }
`

const GET_RED_PACKET_DETAIL = gql`
  query GetRedPacketDetail($id: ID!, $includeHistory: Boolean!) {
    redPacket(id: $id) {
      id
      creator
      message
      totalAmount
      balance
      totalCount
      claimedCount
      isEven
      creationTime
      claims {
        id
        claimer
        amount
        claimTime
        claimIndex
        transactionHash
      }
      # æ¡ä»¶æŸ¥è¯¢å†å²æ•°æ®
      history @include(if: $includeHistory) {
        hourlyData {
          hour
          claimsCount
          totalAmount
        }
      }
    }
  }
`
```

#### ğŸ”„ æ­¥éª¤3ï¼šäº‹ä»¶é©±åŠ¨åŒæ­¥

ç¡®ä¿è¯»å†™æ¨¡å‹ä¹‹é—´çš„æ•°æ®ä¸€è‡´æ€§ï¼š

```typescript
// äº‹ä»¶å¤„ç†å™¨ - åŒæ­¥è¯»å†™æ¨¡å‹
class RedPacketReadModelUpdater {
  constructor(
    private readDatabase: ReadDatabase,
    private cacheService: CacheService
  ) {}

  // å¤„ç†çº¢åŒ…åˆ›å»ºäº‹ä»¶
  async handlePacketCreated(event: PacketCreatedEvent): Promise<void> {
    // 1. æ›´æ–°è¯»æ¨¡å‹æ•°æ®åº“
    await this.readDatabase.redPackets.upsert({
      where: { id: event.packetId },
      create: {
        id: event.packetId,
        creator: event.creator,
        message: event.message,
        totalAmount: event.totalAmount.toString(),
        totalCount: event.totalCount,
        claimedCount: 0,
        isEven: event.isEven,
        creationTime: event.creationTime,
        isActive: true,
        balance: event.totalAmount.toString()
      },
      update: {} // åˆ›å»ºäº‹ä»¶ä¸åº”è¯¥æ›´æ–°å·²å­˜åœ¨çš„è®°å½•
    })

    // 2. æ¸…ç†ç›¸å…³ç¼“å­˜
    await this.invalidateCache([
      'red_packets:*', // æ¸…ç†æ‰€æœ‰çº¢åŒ…åˆ—è¡¨ç¼“å­˜
      `red_packet_detail:${event.packetId}` // æ¸…ç†è¯¥çº¢åŒ…è¯¦æƒ…ç¼“å­˜
    ])

    // 3. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    await this.updateStatistics({
      type: 'packet_created',
      creator: event.creator,
      amount: event.totalAmount
    })
  }

  // å¤„ç†çº¢åŒ…é¢†å–äº‹ä»¶
  async handlePacketClaimed(event: PacketClaimedEvent): Promise<void> {
    // å¼€å¯äº‹åŠ¡ç¡®ä¿ä¸€è‡´æ€§
    await this.readDatabase.$transaction(async (tx) => {
      // 1. æ›´æ–°çº¢åŒ…çŠ¶æ€
      await tx.redPackets.update({
        where: { id: event.packetId },
        data: {
          claimedCount: { increment: 1 },
          balance: { decrement: event.amount.toString() },
          isActive: event.claimedCount < event.totalCount
        }
      })

      // 2. æ·»åŠ é¢†å–è®°å½•
      await tx.claims.create({
        data: {
          id: `${event.packetId}-${event.claimedIndex}`,
          packetId: event.packetId,
          claimer: event.claimer,
          amount: event.amount.toString(),
          claimTime: event.claimTime,
          claimIndex: event.claimedIndex,
          transactionHash: event.transactionHash
        }
      })

      // 3. æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
      await tx.userStats.upsert({
        where: { address: event.claimer },
        create: {
          address: event.claimer,
          totalClaimed: event.amount.toString(),
          claimsCount: 1,
          lastClaimTime: event.claimTime
        },
        update: {
          totalClaimed: { increment: event.amount.toString() },
          claimsCount: { increment: 1 },
          lastClaimTime: event.claimTime
        }
      })
    })

    // 4. æ¸…ç†ç¼“å­˜
    await this.invalidateCache([
      'red_packets:*',
      `red_packet_detail:${event.packetId}`,
      `user_stats:${event.claimer}`
    ])
  }

  private async invalidateCache(patterns: string[]): Promise<void> {
    for (const pattern of patterns) {
      await this.cacheService.deleteByPattern(pattern)
    }
  }

  // ğŸ¯ ç»ƒä¹ æ–¹æ³•ï¼šå®ç°ç»Ÿè®¡æ›´æ–°
  private async updateStatistics(event: StatisticsEvent): Promise<void> {
    // TODO: å®ç°ç»Ÿè®¡ä¿¡æ¯æ›´æ–°é€»è¾‘
    // 1. æ›´æ–°æ€»ä½“ç»Ÿè®¡ï¼ˆæ€»é‡‘é¢ã€æ€»çº¢åŒ…æ•°ç­‰ï¼‰
    // 2. æ›´æ–°æ—¶é—´æ®µç»Ÿè®¡ï¼ˆæ¯æ—¥ã€æ¯æœˆç»Ÿè®¡ï¼‰
    // 3. æ›´æ–°ç”¨æˆ·æ’è¡Œæ¦œ
    // 4. æ›´æ–°çƒ­é—¨çº¢åŒ…åˆ—è¡¨
  }
}
```

### ğŸ¯ CQRSæœ€ä½³å®è·µæ€»ç»“

1. **å‘½ä»¤è¦è¡¨è¾¾æ„å›¾** - ä½¿ç”¨ä¸šåŠ¡è¯­è¨€å‘½åå‘½ä»¤
2. **æŸ¥è¯¢è¦é’ˆå¯¹UIä¼˜åŒ–** - æŸ¥è¯¢å¯¹è±¡åº”è¯¥åŒ¹é…UIéœ€æ±‚
3. **å¼‚æ­¥äº‹ä»¶åŒæ­¥** - ä½¿ç”¨äº‹ä»¶ç¡®ä¿æœ€ç»ˆä¸€è‡´æ€§
4. **ç¼“å­˜ç­–ç•¥è¦åˆç†** - æ ¹æ®æ•°æ®æ›´æ–°é¢‘ç‡è®¾ç½®ç¼“å­˜æ—¶é—´
5. **é”™è¯¯å¤„ç†è¦å®Œæ•´** - åŒºåˆ†éªŒè¯é”™è¯¯ã€ä¸šåŠ¡é”™è¯¯ã€æŠ€æœ¯é”™è¯¯

```
å‘½ä»¤ç«¯ (å†™æ“ä½œ)            æŸ¥è¯¢ç«¯ (è¯»æ“ä½œ)
â”œâ”€â”€ CreateRedPacket       â”œâ”€â”€ GetRedPackets
â”œâ”€â”€ ClaimRedPacket        â”œâ”€â”€ GetUserPackets  
â””â”€â”€ WithdrawFunds         â”œâ”€â”€ GetPacketDetails
     â”‚                    â””â”€â”€ GetUserStats
     â–¼                         â–²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Smart       â”‚          â”‚  Subgraph   â”‚
â”‚ Contract    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Database   â”‚
â”‚ (Write)     â”‚  Events  â”‚  (Read)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å‘½ä»¤æ¨¡å¼å®ç°**:
```typescript
// å‘½ä»¤æ¥å£
interface Command {
  execute(): Promise<CommandResult>
}

// åˆ›å»ºçº¢åŒ…å‘½ä»¤
class CreateRedPacketCommand implements Command {
  constructor(
    private readonly walletClient: WalletClient,
    private readonly params: {
      message: string
      count: number
      isEven: boolean
      value: bigint
    }
  ) {}

  async execute(): Promise<CommandResult> {
    try {
      const hash = await this.walletClient.writeContract({
        address: RED_PACKET_ADDRESS,
        abi: RED_PACKET_ABI,
        functionName: 'createRedPacket',
        args: [this.params.message, BigInt(this.params.count), this.params.isEven],
        value: this.params.value
      })

      return CommandResult.success(hash)
    } catch (error) {
      return CommandResult.failure(error.message)
    }
  }
}

// æŸ¥è¯¢æ¨¡å¼å®ç°
class RedPacketQueryService {
  constructor(
    private readonly apolloClient: ApolloClient<any>
  ) {}

  async getRedPackets(params: GetRedPacketsParams): Promise<RedPacket[]> {
    const { data } = await this.apolloClient.query({
      query: GET_RED_PACKETS,
      variables: params,
      fetchPolicy: 'cache-first'
    })

    return data.redPackets.map(this.mapToRedPacket)
  }

  async getUserStats(address: string): Promise<UserStats> {
    const { data } = await this.apolloClient.query({
      query: GET_USER_STATS,
      variables: { userId: address.toLowerCase() }
    })

    return this.mapToUserStats(data.user)
  }

  private mapToRedPacket(raw: any): RedPacket {
    return {
      id: raw.id,
      creator: raw.creator,
      message: raw.message,
      totalAmount: BigInt(raw.totalAmount),
      balance: BigInt(raw.balance),
      totalCount: raw.totalCount,
      claimedCount: raw.claimedCount,
      isEven: raw.isEven,
      creationTime: new Date(raw.creationTime * 1000),
      claims: raw.claims.map(this.mapToClaim)
    }
  }
}
```

### 2.3 äº‹ä»¶æº¯æºæ¨¡å¼æ·±åº¦å®è·µ

> **äº‹ä»¶æº¯æºçš„å¨åŠ›** åœ¨åŒºå—é“¾ä¸–ç•Œä¸­ï¼Œäº‹ä»¶æº¯æºç‰¹åˆ«æœ‰æ„ä¹‰ï¼šåŒºå—é“¾æœ¬èº«å°±æ˜¯ä¸€ä¸ªå·¨å¤§çš„äº‹ä»¶æ—¥å¿—ï¼Œæ¯ä¸ªäº¤æ˜“éƒ½æ˜¯ä¸€ä¸ªäº‹ä»¶ã€‚é€šè¿‡äº‹ä»¶æº¯æºï¼Œæˆ‘ä»¬å¯ä»¥é‡ç°ä»»ä½•æ—¶åˆ»çš„ç³»ç»ŸçŠ¶æ€ï¼Œè¿™å¯¹å®¡è®¡å’Œè°ƒè¯•éå¸¸æœ‰ä»·å€¼ã€‚

#### ğŸ¬ æ ¸å¿ƒç†å¿µï¼šç³»ç»ŸçŠ¶æ€ = äº‹ä»¶åºåˆ—é‡æ”¾

```typescript
// ä¼ ç»Ÿæ–¹å¼ï¼šç›´æ¥ä¿®æ”¹çŠ¶æ€
class TraditionalRedPacket {
  private balance: number = 1000
  private claims: string[] = []

  claim(user: string, amount: number) {
    // âŒ ç›´æ¥ä¿®æ”¹çŠ¶æ€ï¼Œä¸¢å¤±å†å²ä¿¡æ¯
    this.balance -= amount
    this.claims.push(user)
    
    // æˆ‘ä»¬æ°¸è¿œæ— æ³•çŸ¥é“ï¼š
    // - è¿™æ¬¡æ“ä½œå‰çš„ç¡®åˆ‡çŠ¶æ€æ˜¯ä»€ä¹ˆï¼Ÿ
    // - æ“ä½œæ˜¯åœ¨ä»€ä¹ˆæ—¶å€™å‘ç”Ÿçš„ï¼Ÿ
    // - æ˜¯å¦æœ‰å…¶ä»–ç›¸å…³çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Ÿ
  }
}

// äº‹ä»¶æº¯æºæ–¹å¼ï¼šè®°å½•æ‰€æœ‰äº‹ä»¶
class EventSourcedRedPacket {
  private events: DomainEvent[] = []
  private version: number = 0

  // é€šè¿‡é‡æ”¾äº‹ä»¶æ„å»ºå½“å‰çŠ¶æ€
  static fromEvents(events: DomainEvent[]): EventSourcedRedPacket {
    const packet = new EventSourcedRedPacket()
    events.forEach(event => packet.applyEvent(event))
    return packet
  }

  claim(user: string, amount: number) {
    // âœ… åˆ›å»ºäº‹ä»¶è€Œä¸æ˜¯ç›´æ¥ä¿®æ”¹çŠ¶æ€
    const event = new PacketClaimedEvent(
      this.version + 1,
      user,
      amount,
      new Date()
    )
    
    this.applyEvent(event)
    this.events.push(event) // ä¿å­˜æœªæäº¤çš„äº‹ä»¶
  }

  // ç°åœ¨æˆ‘ä»¬å¯ä»¥ï¼š
  // - é‡ç°ä»»ä½•æ—¶åˆ»çš„çŠ¶æ€
  // - å®¡è®¡æ‰€æœ‰æ“ä½œ
  // - å®ç°æ—¶é—´æ—…è¡Œè°ƒè¯•
  // - è½»æ¾å®ç°æ’¤é”€/é‡åš
}
```

#### ğŸ—ï¸ æ­¥éª¤1ï¼šè®¾è®¡äº‹ä»¶æ¨¡å‹

äº‹ä»¶æ˜¯ä¸šåŠ¡å‘ç”Ÿçš„äº‹å®ï¼Œåº”è¯¥ç”¨è¿‡å»å¼å‘½åï¼š

```typescript
// äº‹ä»¶åŸºç±»
abstract class DomainEvent {
  constructor(
    public readonly eventId: string,
    public readonly aggregateId: string,
    public readonly aggregateVersion: number,
    public readonly occurredAt: Date,
    public readonly eventType: string
  ) {}

  // äº‹ä»¶å…ƒæ•°æ®
  abstract getEventData(): any
  
  // åºåˆ—åŒ–æ”¯æŒ
  toJSON(): EventJson {
    return {
      eventId: this.eventId,
      aggregateId: this.aggregateId,
      aggregateVersion: this.aggregateVersion,
      occurredAt: this.occurredAt.toISOString(),
      eventType: this.eventType,
      eventData: this.getEventData()
    }
  }
}

// å…·ä½“äº‹ä»¶ç±»å‹
class RedPacketCreatedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    version: number,
    public readonly creator: Address,
    public readonly message: string,
    public readonly totalAmount: bigint,
    public readonly totalCount: number,
    public readonly isEven: boolean,
    public readonly creationTransaction: string
  ) {
    super(
      crypto.randomUUID(),
      aggregateId,
      version,
      new Date(),
      'RedPacketCreated'
    )
  }

  getEventData() {
    return {
      creator: this.creator,
      message: this.message,
      totalAmount: this.totalAmount.toString(),
      totalCount: this.totalCount,
      isEven: this.isEven,
      creationTransaction: this.creationTransaction
    }
  }
}

class RedPacketClaimedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    version: number,
    public readonly claimer: Address,
    public readonly amount: bigint,
    public readonly claimIndex: number,
    public readonly claimTransaction: string,
    public readonly remainingBalance: bigint
  ) {
    super(
      crypto.randomUUID(),
      aggregateId,
      version,
      new Date(),
      'RedPacketClaimed'
    )
  }

  getEventData() {
    return {
      claimer: this.claimer,
      amount: this.amount.toString(),
      claimIndex: this.claimIndex,
      claimTransaction: this.claimTransaction,
      remainingBalance: this.remainingBalance.toString()
    }
  }
}

class RedPacketExpiredEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    version: number,
    public readonly expiredAt: Date,
    public readonly remainingBalance: bigint
  ) {
    super(
      crypto.randomUUID(),
      aggregateId,
      version,
      new Date(),
      'RedPacketExpired'
    )
  }

  getEventData() {
    return {
      expiredAt: this.expiredAt.toISOString(),
      remainingBalance: this.remainingBalance.toString()
    }
  }
}

// æå–èµ„é‡‘äº‹ä»¶
class FundsWithdrawnEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    version: number,
    public readonly withdrawer: Address,
    public readonly amount: bigint,
    public readonly withdrawalTransaction: string
  ) {
    super(
      crypto.randomUUID(),
      aggregateId,
      version,
      new Date(),
      'FundsWithdrawn'
    )
  }

  getEventData() {
    return {
      withdrawer: this.withdrawer,
      amount: this.amount.toString(),
      withdrawalTransaction: this.withdrawalTransaction
    }
  }
}
```

#### ğŸ—„ï¸ æ­¥éª¤2ï¼šå®ç°äº‹ä»¶å­˜å‚¨

äº‹ä»¶å­˜å‚¨æ˜¯äº‹ä»¶æº¯æºçš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼š

```typescript
// äº‹ä»¶å­˜å‚¨æ¥å£
interface EventStore {
  // ä¿å­˜äº‹ä»¶æµ
  saveEvents(aggregateId: string, events: DomainEvent[], expectedVersion: number): Promise<void>
  
  // è·å–äº‹ä»¶æµ
  getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]>
  
  // è·å–æ‰€æœ‰äº‹ä»¶ï¼ˆç”¨äºé‡å»ºè¯»æ¨¡å‹ï¼‰
  getAllEvents(fromTimestamp?: Date): Promise<DomainEvent[]>
  
  // è·å–äº‹ä»¶å¿«ç…§
  getSnapshot(aggregateId: string): Promise<AggregateSnapshot | null>
  
  // ä¿å­˜å¿«ç…§ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
  saveSnapshot(snapshot: AggregateSnapshot): Promise<void>
}

// å†…å­˜äº‹ä»¶å­˜å‚¨å®ç°ï¼ˆç”¨äºæµ‹è¯•ï¼‰
class InMemoryEventStore implements EventStore {
  private events: Map<string, DomainEvent[]> = new Map()
  private snapshots: Map<string, AggregateSnapshot> = new Map()

  async saveEvents(
    aggregateId: string, 
    events: DomainEvent[], 
    expectedVersion: number
  ): Promise<void> {
    const existingEvents = this.events.get(aggregateId) || []
    
    // å¹¶å‘å†²çªæ£€æŸ¥
    if (existingEvents.length !== expectedVersion) {
      throw new ConcurrencyError(
        `Expected version ${expectedVersion}, but current version is ${existingEvents.length}`
      )
    }

    // ç‰ˆæœ¬å·éªŒè¯
    events.forEach((event, index) => {
      if (event.aggregateVersion !== expectedVersion + index + 1) {
        throw new Error(`Event version mismatch at index ${index}`)
      }
    })

    // ä¿å­˜äº‹ä»¶
    this.events.set(aggregateId, [...existingEvents, ...events])
  }

  async getEvents(aggregateId: string, fromVersion = 0): Promise<DomainEvent[]> {
    const events = this.events.get(aggregateId) || []
    return events.filter(event => event.aggregateVersion > fromVersion)
  }

  async getAllEvents(fromTimestamp?: Date): Promise<DomainEvent[]> {
    const allEvents = Array.from(this.events.values()).flat()
    
    if (!fromTimestamp) {
      return allEvents
    }

    return allEvents.filter(event => event.occurredAt >= fromTimestamp)
  }

  async getSnapshot(aggregateId: string): Promise<AggregateSnapshot | null> {
    return this.snapshots.get(aggregateId) || null
  }

  async saveSnapshot(snapshot: AggregateSnapshot): Promise<void> {
    this.snapshots.set(snapshot.aggregateId, snapshot)
  }
}

// ç”Ÿäº§ç¯å¢ƒçš„æ•°æ®åº“äº‹ä»¶å­˜å‚¨
class DatabaseEventStore implements EventStore {
  constructor(private database: PrismaClient) {}

  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<void> {
    // ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§
    await this.database.$transaction(async (tx) => {
      // 1. æ£€æŸ¥å½“å‰ç‰ˆæœ¬
      const currentVersion = await tx.event.count({
        where: { aggregateId }
      })

      if (currentVersion !== expectedVersion) {
        throw new ConcurrencyError(
          `Concurrency conflict: expected ${expectedVersion}, actual ${currentVersion}`
        )
      }

      // 2. ä¿å­˜äº‹ä»¶
      const eventData = events.map(event => ({
        id: event.eventId,
        aggregateId: event.aggregateId,
        aggregateVersion: event.aggregateVersion,
        eventType: event.eventType,
        eventData: JSON.stringify(event.getEventData()),
        occurredAt: event.occurredAt
      }))

      await tx.event.createMany({ data: eventData })

      // 3. æ›´æ–°èšåˆå…ƒæ•°æ®
      await tx.aggregate.upsert({
        where: { id: aggregateId },
        create: {
          id: aggregateId,
          type: 'RedPacket',
          version: expectedVersion + events.length,
          lastModified: new Date()
        },
        update: {
          version: expectedVersion + events.length,
          lastModified: new Date()
        }
      })
    })
  }

  async getEvents(aggregateId: string, fromVersion = 0): Promise<DomainEvent[]> {
    const rawEvents = await this.database.event.findMany({
      where: {
        aggregateId,
        aggregateVersion: { gt: fromVersion }
      },
      orderBy: { aggregateVersion: 'asc' }
    })

    return rawEvents.map(this.deserializeEvent)
  }

  private deserializeEvent(rawEvent: any): DomainEvent {
    const eventData = JSON.parse(rawEvent.eventData)
    
    // å·¥å‚æ–¹æ³•æ ¹æ®ç±»å‹åˆ›å»ºå…·ä½“äº‹ä»¶
    switch (rawEvent.eventType) {
      case 'RedPacketCreated':
        return new RedPacketCreatedEvent(
          rawEvent.aggregateId,
          rawEvent.aggregateVersion,
          eventData.creator,
          eventData.message,
          BigInt(eventData.totalAmount),
          eventData.totalCount,
          eventData.isEven,
          eventData.creationTransaction
        )
      
      case 'RedPacketClaimed':
        return new RedPacketClaimedEvent(
          rawEvent.aggregateId,
          rawEvent.aggregateVersion,
          eventData.claimer,
          BigInt(eventData.amount),
          eventData.claimIndex,
          eventData.claimTransaction,
          BigInt(eventData.remainingBalance)
        )
      
      // æ›´å¤šäº‹ä»¶ç±»å‹...
      
      default:
        throw new Error(`Unknown event type: ${rawEvent.eventType}`)
    }
  }
}
```

#### ğŸ”„ æ­¥éª¤3ï¼šå®ç°äº‹ä»¶æº¯æºèšåˆ

è®©èšåˆæ ¹æ”¯æŒäº‹ä»¶æº¯æºï¼š

```typescript
// äº‹ä»¶æº¯æºèšåˆåŸºç±»
abstract class EventSourcedAggregate {
  protected uncommittedEvents: DomainEvent[] = []
  protected version: number = 0
  protected id: string = ''

  // ä»äº‹ä»¶é‡å»ºèšåˆ
  static fromHistory<T extends EventSourcedAggregate>(
    aggregateClass: new () => T,
    events: DomainEvent[]
  ): T {
    const aggregate = new aggregateClass()
    
    events.forEach(event => {
      aggregate.applyEvent(event)
      aggregate.version = event.aggregateVersion
    })
    
    return aggregate
  }

  // åº”ç”¨äº‹ä»¶ï¼ˆä¸ä¿å­˜åˆ°æœªæäº¤åˆ—è¡¨ï¼‰
  protected applyEvent(event: DomainEvent): void {
    const methodName = `apply${event.eventType}`
    const method = (this as any)[methodName]
    
    if (typeof method === 'function') {
      method.call(this, event)
    } else {
      throw new Error(`No handler for event type: ${event.eventType}`)
    }
  }

  // æ·»åŠ äº‹ä»¶åˆ°æœªæäº¤åˆ—è¡¨
  protected addEvent(event: DomainEvent): void {
    this.applyEvent(event)
    this.uncommittedEvents.push(event)
    this.version = event.aggregateVersion
  }

  // è·å–æœªæäº¤çš„äº‹ä»¶
  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents]
  }

  // æ ‡è®°äº‹ä»¶ä¸ºå·²æäº¤
  markEventsAsCommitted(): void {
    this.uncommittedEvents = []
  }

  // è·å–å½“å‰ç‰ˆæœ¬
  getVersion(): number {
    return this.version
  }

  getId(): string {
    return this.id
  }
}

// äº‹ä»¶æº¯æºçº¢åŒ…èšåˆ
class EventSourcedRedPacket extends EventSourcedAggregate {
  private creator: Address = ''
  private message: string = ''
  private totalAmount: bigint = 0n
  private balance: bigint = 0n
  private totalCount: number = 0
  private claimedCount: number = 0
  private isEven: boolean = false
  private creationTime: Date = new Date()
  private claims: Map<Address, ClaimInfo> = new Map()
  private isExpired: boolean = false
  private isWithdrawn: boolean = false

  // åˆ›å»ºçº¢åŒ…ï¼ˆå‘½ä»¤å¤„ç†ï¼‰
  static create(
    id: string,
    creator: Address,
    message: string,
    totalAmount: bigint,
    totalCount: number,
    isEven: boolean,
    transactionHash: string
  ): EventSourcedRedPacket {
    const packet = new EventSourcedRedPacket()
    packet.id = id
    
    const event = new RedPacketCreatedEvent(
      id,
      1,
      creator,
      message,
      totalAmount,
      totalCount,
      isEven,
      transactionHash
    )
    
    packet.addEvent(event)
    return packet
  }

  // é¢†å–çº¢åŒ…ï¼ˆå‘½ä»¤å¤„ç†ï¼‰
  claim(claimer: Address, transactionHash: string): void {
    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if (this.claims.has(claimer)) {
      throw new Error('ç”¨æˆ·å·²ç»é¢†å–è¿‡æ­¤çº¢åŒ…')
    }
    
    if (this.claimedCount >= this.totalCount) {
      throw new Error('çº¢åŒ…å·²è¢«å…¨éƒ¨é¢†å–')
    }
    
    if (this.isExpired) {
      throw new Error('çº¢åŒ…å·²è¿‡æœŸ')
    }

    if (this.balance <= 0) {
      throw new Error('çº¢åŒ…ä½™é¢ä¸è¶³')
    }

    // è®¡ç®—é¢†å–é‡‘é¢
    const claimAmount = this.calculateClaimAmount()
    
    // åˆ›å»ºäº‹ä»¶
    const event = new RedPacketClaimedEvent(
      this.id,
      this.version + 1,
      claimer,
      claimAmount,
      this.claimedCount + 1,
      transactionHash,
      this.balance - claimAmount
    )
    
    this.addEvent(event)
  }

  // æ ‡è®°è¿‡æœŸï¼ˆå¯ä»¥ç”±å®šæ—¶ä»»åŠ¡è§¦å‘ï¼‰
  markAsExpired(): void {
    if (this.isExpired) {
      return // å·²ç»è¿‡æœŸ
    }
    
    const event = new RedPacketExpiredEvent(
      this.id,
      this.version + 1,
      new Date(),
      this.balance
    )
    
    this.addEvent(event)
  }

  // æå–èµ„é‡‘ï¼ˆå‘½ä»¤å¤„ç†ï¼‰
  withdraw(withdrawer: Address, transactionHash: string): void {
    if (withdrawer !== this.creator) {
      throw new Error('åªæœ‰åˆ›å»ºè€…å¯ä»¥æå–èµ„é‡‘')
    }
    
    if (!this.isExpired) {
      throw new Error('çº¢åŒ…å°šæœªè¿‡æœŸï¼Œæ— æ³•æå–')
    }
    
    if (this.balance <= 0) {
      throw new Error('æ²¡æœ‰ä½™é¢å¯æå–')
    }
    
    if (this.isWithdrawn) {
      throw new Error('èµ„é‡‘å·²è¢«æå–')
    }
    
    const event = new FundsWithdrawnEvent(
      this.id,
      this.version + 1,
      withdrawer,
      this.balance,
      transactionHash
    )
    
    this.addEvent(event)
  }

  // äº‹ä»¶åº”ç”¨æ–¹æ³•
  private applyRedPacketCreatedEvent(event: RedPacketCreatedEvent): void {
    this.creator = event.creator
    this.message = event.message
    this.totalAmount = event.totalAmount
    this.balance = event.totalAmount
    this.totalCount = event.totalCount
    this.isEven = event.isEven
    this.creationTime = event.occurredAt
    this.claimedCount = 0
  }

  private applyRedPacketClaimedEvent(event: RedPacketClaimedEvent): void {
    this.claims.set(event.claimer, {
      amount: event.amount,
      claimTime: event.occurredAt,
      claimIndex: event.claimIndex
    })
    this.claimedCount++
    this.balance = event.remainingBalance
  }

  private applyRedPacketExpiredEvent(event: RedPacketExpiredEvent): void {
    this.isExpired = true
  }

  private applyFundsWithdrawnEvent(event: FundsWithdrawnEvent): void {
    this.balance = 0n
    this.isWithdrawn = true
  }

  // è¾…åŠ©æ–¹æ³•
  private calculateClaimAmount(): bigint {
    if (this.isEven) {
      // å¹³å‡åˆ†é…
      return this.balance / BigInt(this.totalCount - this.claimedCount)
    } else {
      // éšæœºåˆ†é…ï¼ˆç®€åŒ–ç‰ˆï¼‰
      if (this.claimedCount === this.totalCount - 1) {
        return this.balance // æœ€åä¸€ä¸ªé¢†å–å…¨éƒ¨ä½™é¢
      }
      
      // éšæœºç®—æ³•ç¡®ä¿æ¯ä¸ªåç»­çº¢åŒ…è‡³å°‘1wei
      const maxAmount = this.balance - BigInt(this.totalCount - this.claimedCount - 1)
      const seed = BigInt(Date.now()) + BigInt(this.claimedCount)
      return (seed % maxAmount) + 1n
    }
  }

  // æŸ¥è¯¢æ–¹æ³•
  getState(): RedPacketState {
    return {
      id: this.id,
      creator: this.creator,
      message: this.message,
      totalAmount: this.totalAmount,
      balance: this.balance,
      totalCount: this.totalCount,
      claimedCount: this.claimedCount,
      isEven: this.isEven,
      creationTime: this.creationTime,
      claims: Array.from(this.claims.entries()).map(([claimer, info]) => ({
        claimer,
        ...info
      })),
      isExpired: this.isExpired,
      isWithdrawn: this.isWithdrawn
    }
  }
}

interface ClaimInfo {
  amount: bigint
  claimTime: Date
  claimIndex: number
}

interface RedPacketState {
  id: string
  creator: Address
  message: string
  totalAmount: bigint
  balance: bigint
  totalCount: number
  claimedCount: number
  isEven: boolean
  creationTime: Date
  claims: Array<{
    claimer: Address
    amount: bigint
    claimTime: Date
    claimIndex: number
  }>
  isExpired: boolean
  isWithdrawn: boolean
}
```

#### ğŸš€ æ­¥éª¤4ï¼šå®ç°ä»“å‚¨æ¨¡å¼

è¿æ¥èšåˆä¸äº‹ä»¶å­˜å‚¨ï¼š

```typescript
// äº‹ä»¶æº¯æºä»“å‚¨
class EventSourcedRedPacketRepository {
  constructor(
    private eventStore: EventStore,
    private snapshotFrequency: number = 10 // æ¯10ä¸ªäº‹ä»¶åˆ›å»ºä¸€æ¬¡å¿«ç…§
  ) {}

  async save(aggregate: EventSourcedRedPacket): Promise<void> {
    const events = aggregate.getUncommittedEvents()
    if (events.length === 0) {
      return // æ²¡æœ‰éœ€è¦ä¿å­˜çš„äº‹ä»¶
    }

    try {
      // ä¿å­˜äº‹ä»¶
      await this.eventStore.saveEvents(
        aggregate.getId(),
        events,
        aggregate.getVersion() - events.length // æœŸæœ›çš„ç‰ˆæœ¬å·
      )

      // æ ‡è®°äº‹ä»¶ä¸ºå·²æäº¤
      aggregate.markEventsAsCommitted()

      // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºå¿«ç…§
      if (aggregate.getVersion() % this.snapshotFrequency === 0) {
        await this.createSnapshot(aggregate)
      }
    } catch (error) {
      if (error instanceof ConcurrencyError) {
        throw new Error('çº¢åŒ…çŠ¶æ€å·²è¢«å…¶ä»–ç”¨æˆ·ä¿®æ”¹ï¼Œè¯·åˆ·æ–°åé‡è¯•')
      }
      throw error
    }
  }

  async getById(id: string): Promise<EventSourcedRedPacket | null> {
    // 1. å°è¯•ä»å¿«ç…§åŠ è½½
    const snapshot = await this.eventStore.getSnapshot(id)
    let aggregate: EventSourcedRedPacket
    let fromVersion = 0

    if (snapshot) {
      aggregate = this.restoreFromSnapshot(snapshot)
      fromVersion = snapshot.version
    } else {
      aggregate = new EventSourcedRedPacket()
    }

    // 2. åŠ è½½å¿«ç…§ä¹‹åçš„äº‹ä»¶
    const events = await this.eventStore.getEvents(id, fromVersion)
    if (events.length === 0 && !snapshot) {
      return null // èšåˆä¸å­˜åœ¨
    }

    // 3. é‡æ”¾äº‹ä»¶
    events.forEach(event => {
      aggregate['applyEvent'](event) // ç›´æ¥åº”ç”¨ï¼Œä¸æ·»åŠ åˆ°æœªæäº¤åˆ—è¡¨
      aggregate['version'] = event.aggregateVersion
    })

    return aggregate
  }

  private async createSnapshot(aggregate: EventSourcedRedPacket): Promise<void> {
    const state = aggregate.getState()
    
    const snapshot: AggregateSnapshot = {
      aggregateId: aggregate.getId(),
      aggregateType: 'RedPacket',
      version: aggregate.getVersion(),
      data: JSON.stringify(state),
      createdAt: new Date()
    }

    await this.eventStore.saveSnapshot(snapshot)
  }

  private restoreFromSnapshot(snapshot: AggregateSnapshot): EventSourcedRedPacket {
    const state: RedPacketState = JSON.parse(snapshot.data)
    
    // ä»å¿«ç…§æ¢å¤èšåˆçŠ¶æ€
    const aggregate = new EventSourcedRedPacket()
    aggregate['id'] = state.id
    aggregate['creator'] = state.creator
    aggregate['message'] = state.message
    aggregate['totalAmount'] = state.totalAmount
    aggregate['balance'] = state.balance
    aggregate['totalCount'] = state.totalCount
    aggregate['claimedCount'] = state.claimedCount
    aggregate['isEven'] = state.isEven
    aggregate['creationTime'] = state.creationTime
    aggregate['isExpired'] = state.isExpired
    aggregate['isWithdrawn'] = state.isWithdrawn
    aggregate['version'] = snapshot.version
    
    // æ¢å¤claimsæ˜ å°„
    state.claims.forEach(claim => {
      aggregate['claims'].set(claim.claimer, {
        amount: claim.amount,
        claimTime: claim.claimTime,
        claimIndex: claim.claimIndex
      })
    })

    return aggregate
  }

  // ğŸ¯ ç»ƒä¹ æ–¹æ³•ï¼šå®ç°æ—¶é—´æ—…è¡Œ
  async getStateAtTime(id: string, timestamp: Date): Promise<RedPacketState | null> {
    // TODO: å®ç°æ—¶é—´æ—…è¡ŒåŠŸèƒ½
    // 1. è·å–æŒ‡å®šæ—¶é—´ä¹‹å‰çš„æ‰€æœ‰äº‹ä»¶
    // 2. é‡æ”¾äº‹ä»¶åˆ°æŒ‡å®šæ—¶é—´ç‚¹
    // 3. è¿”å›è¯¥æ—¶é—´ç‚¹çš„èšåˆçŠ¶æ€
    // è¿™å¯¹äºå®¡è®¡å’Œè°ƒè¯•éå¸¸æœ‰ç”¨
  }

  // è·å–èšåˆçš„å®Œæ•´å†å²
  async getHistory(id: string): Promise<DomainEvent[]> {
    return await this.eventStore.getEvents(id)
  }
}

interface AggregateSnapshot {
  aggregateId: string
  aggregateType: string
  version: number
  data: string // JSONåºåˆ—åŒ–çš„çŠ¶æ€
  createdAt: Date
}

class ConcurrencyError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ConcurrencyError'
  }
}
```

### ğŸ¯ äº‹ä»¶æº¯æºæœ€ä½³å®è·µæ€»ç»“

1. **äº‹ä»¶ä¸å¯å˜** - ä¸€æ—¦ä¿å­˜å°±æ°¸è¿œä¸èƒ½ä¿®æ”¹
2. **äº‹ä»¶è¦è¡¨è¾¾ä¸šåŠ¡æ„ä¹‰** - ç”¨ä¸šåŠ¡è¯­è¨€å‘½åï¼Œè®°å½•å®Œæ•´ä¸Šä¸‹æ–‡
3. **ç‰ˆæœ¬æ§åˆ¶å¾ˆé‡è¦** - å¤„ç†äº‹ä»¶æ ¼å¼çš„æ¼”è¿›
4. **å¿«ç…§ä¼˜åŒ–æ€§èƒ½** - é¿å…é‡æ”¾å¤ªå¤šäº‹ä»¶
5. **å¹¶å‘æ§åˆ¶å¿…é¡»** - ä½¿ç”¨ä¹è§‚é”é˜²æ­¢å†²çª

**äº‹ä»¶æº¯æºçš„ä¼˜åŠ¿ï¼š**
- å®Œæ•´çš„å®¡è®¡æ—¥å¿—
- å¯ä»¥é‡ç°ä»»æ„æ—¶åˆ»çš„çŠ¶æ€
- è‡ªç„¶æ”¯æŒäº‹ä»¶é©±åŠ¨æ¶æ„
- æ–¹ä¾¿è°ƒè¯•å’Œæ•…éšœæ’æŸ¥

**æ³¨æ„äº‹é¡¹ï¼š**
- å­˜å‚¨ç©ºé—´ä¼šæŒç»­å¢é•¿
- é‡æ”¾å¤§é‡äº‹ä»¶å¯èƒ½è¾ƒæ…¢
- äº‹ä»¶æ ¼å¼å˜æ›´éœ€è¦è°¨æ…å¤„ç†

---

```
äº‹ä»¶æµ
â”œâ”€â”€ PacketCreated
â”‚   â”œâ”€â”€ çŠ¶æ€: RedPacket åˆ›å»º
â”‚   â””â”€â”€ å‰¯ä½œç”¨: å‘é€é€šçŸ¥
â”œâ”€â”€ PacketClaimed  
â”‚   â”œâ”€â”€ çŠ¶æ€: æ›´æ–°ä½™é¢å’Œè®¡æ•°
â”‚   â””â”€â”€ å‰¯ä½œç”¨: ç”¨æˆ·ä½™é¢æ›´æ–°
â””â”€â”€ PacketEmpty
    â”œâ”€â”€ çŠ¶æ€: æ ‡è®°ä¸ºå·²å®Œæˆ
    â””â”€â”€ å‰¯ä½œç”¨: æ¸…ç†ä»»åŠ¡
```

**äº‹ä»¶å­˜å‚¨å®ç°**:
```typescript
// äº‹ä»¶åŸºç±»
abstract class DomainEvent {
  constructor(
    public readonly aggregateId: string,
    public readonly version: number,
    public readonly occurredAt: Date
  ) {}
}

// çº¢åŒ…åˆ›å»ºäº‹ä»¶
class RedPacketCreatedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    version: number,
    public readonly creator: string,
    public readonly message: string,
    public readonly totalAmount: bigint,
    public readonly totalCount: number,
    public readonly isEven: boolean
  ) {
    super(aggregateId, version, new Date())
  }
}

// äº‹ä»¶å­˜å‚¨
class EventStore {
  private events: Map<string, DomainEvent[]> = new Map()

  append(aggregateId: string, events: DomainEvent[]): void {
    const existingEvents = this.events.get(aggregateId) || []
    this.events.set(aggregateId, [...existingEvents, ...events])
  }

  getEvents(aggregateId: string): DomainEvent[] {
    return this.events.get(aggregateId) || []
  }

  getAllEvents(): DomainEvent[] {
    return Array.from(this.events.values()).flat()
  }
}

// äº‹ä»¶é‡æ’­
class EventSourcing {
  constructor(private readonly eventStore: EventStore) {}

  replayAggregate(aggregateId: string): RedPacket | null {
    const events = this.eventStore.getEvents(aggregateId)
    if (events.length === 0) return null

    return events.reduce((aggregate, event) => {
      if (aggregate === null) {
        if (event instanceof RedPacketCreatedEvent) {
          return RedPacket.create(
            aggregateId,
            event.creator,
            event.message,
            new Money(event.totalAmount),
            event.totalCount,
            event.isEven
          )
        }
        return null
      }

      if (event instanceof RedPacketClaimedEvent) {
        aggregate.applyClaim(event.claimer, new Money(event.amount))
      }

      return aggregate
    }, null as RedPacket | null)
  }
}
```

## ğŸ”§ æŠ€æœ¯é€‰å‹åˆ†æ

### 1. æ™ºèƒ½åˆçº¦å±‚

**é€‰æ‹© Solidity 0.8.28 çš„åŸå› **:
- âœ… åŸç”Ÿæº¢å‡ºæ£€æŸ¥ï¼Œæå‡å®‰å…¨æ€§
- âœ… æ›´å¥½çš„ç¼–è¯‘å™¨ä¼˜åŒ–
- âœ… æ”¯æŒæœ€æ–°çš„ EVM ç‰¹æ€§
- âœ… ä¸°å¯Œçš„å¼€å‘å·¥å…·æ”¯æŒ

**é€‰æ‹© Hardhat 3 Beta çš„åŸå› **:
- âœ… åŸç”Ÿ TypeScript æ”¯æŒ
- âœ… æ›´å¿«çš„ç¼–è¯‘å’Œæµ‹è¯•
- âœ… å†…ç½® Viem é›†æˆ
- âœ… æ”¹è¿›çš„æ’ä»¶ç³»ç»Ÿ

**Gas ä¼˜åŒ–ç­–ç•¥**:
```solidity
// ä¼˜åŒ–å­˜å‚¨å¸ƒå±€
struct RedPacket {
    address owner;        // 20 bytes
    bool isEven;         // 1 byte  - ç´§è·ŸaddressèŠ‚çœå­˜å‚¨æ§½
    uint256 totalAmount; // 32 bytes
    uint256 balance;     // 32 bytes
    uint256 totalCount;  // 32 bytes
    uint256 claimedCount; // 32 bytes
    uint256 creationTime; // 32 bytes
    string message;      // åŠ¨æ€é•¿åº¦ï¼Œå•ç‹¬å­˜å‚¨æ§½
}

// ä¼˜åŒ–å‡½æ•°è°ƒç”¨
function claimRedPacket(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId]; // ä½¿ç”¨ storage å¼•ç”¨
    
    // æ‰¹é‡è¯»å–ï¼Œå‡å°‘ SLOAD
    uint256 currentCount = packet.claimedCount;
    uint256 maxCount = packet.totalCount;
    uint256 currentBalance = packet.balance;
    
    // ... ä¸šåŠ¡é€»è¾‘
}
```

### 2. å‰ç«¯æŠ€æœ¯æ ˆ

**React 19 + TypeScript**:
```typescript
// ç±»å‹å®‰å…¨çš„çŠ¶æ€ç®¡ç†
interface AppState {
  user: {
    address?: Address
    isConnected: boolean
    chainId?: number
  }
  redPackets: {
    items: RedPacket[]
    loading: boolean
    error?: string
  }
}

// è‡ªå®šä¹‰Hookæ¨¡å¼
function useRedPacketActions() {
  const { writeContract } = useWriteContract()
  
  const createRedPacket = useCallback(async (params: CreateParams) => {
    return await writeContract({
      address: RED_PACKET_ADDRESS,
      abi: RED_PACKET_ABI,
      functionName: 'createRedPacket',
      args: [params.message, params.count, params.isEven],
      value: params.value
    })
  }, [writeContract])

  return { createRedPacket }
}
```

**Wagmi v2 + Viem v2 é€‰æ‹©ç†ç”±**:
- âœ… å®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ
- âœ… ç°ä»£åŒ–çš„ React Hooks API
- âœ… è½»é‡çº§ï¼Œæ€§èƒ½ä¼˜å¼‚
- âœ… æ´»è·ƒçš„ç¤¾åŒºå’Œç”Ÿæ€

**çŠ¶æ€ç®¡ç†ç­–ç•¥**:
```typescript
// Web3 çŠ¶æ€ - ç”± Wagmi ç®¡ç†
const { address, isConnected } = useAccount()
const { chain } = useNetwork()

// æœåŠ¡ç«¯çŠ¶æ€ - ç”± React Query ç®¡ç†  
const { data: redPackets, isLoading } = useQuery({
  queryKey: ['redPackets', filters],
  queryFn: () => fetchRedPackets(filters),
  staleTime: 1000 * 60 * 2, // 2åˆ†é’Ÿ
  cacheTime: 1000 * 60 * 10 // 10åˆ†é’Ÿ
})

// å®¢æˆ·ç«¯çŠ¶æ€ - ç”± useState ç®¡ç†
const [selectedPacket, setSelectedPacket] = useState<RedPacket | null>(null)

// å…¨å±€çŠ¶æ€ - ç”± Context ç®¡ç†
const { theme, setTheme } = useTheme()
```

### 3. æ•°æ®å±‚æ¶æ„

**The Graph é€‰æ‹©ç†ç”±**:
- âœ… å»ä¸­å¿ƒåŒ–æ•°æ®ç´¢å¼•
- âœ… GraphQL æŸ¥è¯¢æ¥å£
- âœ… å®æ—¶æ•°æ®åŒæ­¥
- âœ… å¼ºå¤§çš„æ•°æ®è½¬æ¢èƒ½åŠ›

**æ•°æ®æµè®¾è®¡**:
```
åŒºå—é“¾äº‹ä»¶ â†’ Subgraph Mapping â†’ GraphQL Schema â†’ Frontend Query
     â†“              â†“                â†“              â†“
PacketCreated â†’ handlePacketCreated â†’ RedPacket â†’ useRedPackets
PacketClaimed â†’ handlePacketClaimed â†’ Claim    â†’ useUserClaims
```

**æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥**:
```graphql
# ä½¿ç”¨åˆ†é¡µé¿å…å¤§é‡æ•°æ®
query GetRedPackets($first: Int!, $skip: Int!) {
  redPackets(
    first: $first
    skip: $skip
    orderBy: creationTime
    orderDirection: desc
  ) {
    # åªæŸ¥è¯¢å¿…è¦å­—æ®µ
    id
    creator
    message
    totalAmount
    claimedCount
    totalCount
    isActive
  }
}

# ä½¿ç”¨whereè¿‡æ»¤å‡å°‘æ•°æ®ä¼ è¾“
query GetActivePackets {
  redPackets(
    where: { isActive: true }
    first: 10
  ) {
    id
    message
    balance
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å‰ç«¯æ€§èƒ½ä¼˜åŒ–

**ä»£ç åˆ†å‰²ç­–ç•¥**:
```typescript
// è·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
const CreateRedPacket = lazy(() => import('../pages/CreateRedPacket'))
const RedPacketList = lazy(() => import('../pages/RedPacketList'))

// ç»„ä»¶çº§åˆ«çš„ä»£ç åˆ†å‰²
const RedPacketCard = lazy(() => import('../components/RedPacketCard'))

// ç¬¬ä¸‰æ–¹åº“çš„åŠ¨æ€å¯¼å…¥
const loadCharts = () => import('react-chartjs-2')
```

**ç¼“å­˜ç­–ç•¥**:
```typescript
// React Query ç¼“å­˜é…ç½®
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5åˆ†é’Ÿå†…æ•°æ®è®¤ä¸ºæ˜¯æ–°é²œçš„
      cacheTime: 1000 * 60 * 10, // 10åˆ†é’Ÿåæ¸…é™¤ç¼“å­˜
      refetchOnWindowFocus: false,
      retry: (failureCount, error) => {
        if (error.message.includes('User rejected')) {
          return false // ç”¨æˆ·æ‹’ç»ä¸é‡è¯•
        }
        return failureCount < 3
      }
    }
  }
})

// Apollo Client ç¼“å­˜
const apolloClient = new ApolloClient({
  cache: new InMemoryCache({
    typePolicies: {
      RedPacket: {
        keyFields: ['id'],
        fields: {
          claims: {
            merge: false // ä¸åˆå¹¶ï¼Œç›´æ¥æ›¿æ¢
          }
        }
      }
    }
  })
})
```

**è™šæ‹ŸåŒ–é•¿åˆ—è¡¨**:
```typescript
function VirtualizedRedPacketList({ packets }: Props) {
  const containerRef = useRef<HTMLDivElement>(null)
  const itemHeight = 200 // æ¯ä¸ªçº¢åŒ…å¡ç‰‡é«˜åº¦
  
  const { visibleItems, offsetY, totalHeight, onScroll } = useVirtualizedList(
    packets,
    itemHeight,
    600 // å®¹å™¨é«˜åº¦
  )

  return (
    <div 
      ref={containerRef}
      style={{ height: 600, overflow: 'auto' }}
      onScroll={onScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((packet) => (
            <RedPacketCard key={packet.id} packet={packet} />
          ))}
        </div>
      </div>
    </div>
  )
}
```

### 2. æ™ºèƒ½åˆçº¦æ€§èƒ½ä¼˜åŒ–

**Gas ä¼˜åŒ–æŠ€æœ¯**:
```solidity
// ä½¿ç”¨ mapping ä¼˜åŒ–æŸ¥æ‰¾
mapping(uint256 => mapping(address => bool)) public hasClaimed;

// æ‰¹é‡æ“ä½œå‡å°‘äº¤æ˜“è´¹ç”¨
function batchClaim(uint256[] calldata packetIds) external {
    for (uint256 i = 0; i < packetIds.length; i++) {
        _claimInternal(packetIds[i]);
    }
}

// ä½¿ç”¨ storage æŒ‡é’ˆé¿å…é‡å¤è¯»å–
function updatePacket(uint256 packetId) internal {
    RedPacket storage packet = packets[packetId];
    
    // å¤šæ¬¡ä¿®æ”¹åŒä¸€ä¸ª storage
    packet.claimedCount++;
    packet.balance -= amount;
    packet.lastUpdate = block.timestamp;
}

// åˆç†ä½¿ç”¨ view å‡½æ•°
function getPacketInfo(uint256 packetId) 
    external 
    view 
    returns (address owner, uint256 balance, bool isActive) 
{
    RedPacket storage packet = packets[packetId];
    return (
        packet.owner,
        packet.balance,
        packet.claimedCount < packet.totalCount
    );
}
```

### 3. å­å›¾æ€§èƒ½ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**:
```typescript
// åœ¨ mapping ä¸­åˆ›å»ºé«˜æ•ˆç´¢å¼•
export function handlePacketCreated(event: PacketCreated): void {
  let redPacket = new RedPacket(event.params.packetId.toString())
  
  // æ·»åŠ æŸ¥è¯¢ä¼˜åŒ–å­—æ®µ
  redPacket.creatorLowerCase = event.params.creator.toHex().toLowerCase()
  redPacket.dayCreated = getDayId(event.block.timestamp)
  redPacket.monthCreated = getMonthId(event.block.timestamp)
  
  // é¢„è®¡ç®—å¸¸ç”¨ç»Ÿè®¡
  redPacket.averageAmount = event.params.totalAmount.div(
    BigInt.fromI32(event.params.totalCount)
  )
  
  redPacket.save()
}
```

**æŸ¥è¯¢æ‰¹é‡å¤„ç†**:
```graphql
# ä½¿ç”¨ batch æŸ¥è¯¢å‡å°‘ç½‘ç»œè¯·æ±‚
query GetRedPacketData($packetIds: [ID!]!) {
  redPackets(where: { id_in: $packetIds }) {
    id
    creator
    message
    totalAmount
    claims {
      claimer
      amount
    }
  }
}
```

## ğŸ›¡ï¸ å®‰å…¨è®¾è®¡

### 1. æ™ºèƒ½åˆçº¦å®‰å…¨

**é‡å…¥æ”»å‡»é˜²æŠ¤**:
```solidity
// ä½¿ç”¨ CEI æ¨¡å¼
bool private locked;

modifier nonReentrant() {
    require(!locked, "ReentrancyGuard: reentrant call");
    locked = true;
    _;
    locked = false;
}

function claimRedPacket(uint256 _packetId) external nonReentrant {
    // Checks: æ£€æŸ¥
    require(packets[_packetId].claimedCount < packets[_packetId].totalCount);
    require(!hasClaimed[_packetId][msg.sender]);
    
    // Effects: çŠ¶æ€æ›´æ–°
    hasClaimed[_packetId][msg.sender] = true;
    packets[_packetId].claimedCount++;
    
    // Interactions: å¤–éƒ¨è°ƒç”¨
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

**è®¿é—®æ§åˆ¶**:
```solidity
// åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
mapping(bytes32 => mapping(address => bool)) private roles;
bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

modifier onlyRole(bytes32 role) {
    require(hasRole(role, msg.sender), "AccessControl: unauthorized");
    _;
}

function pause() external onlyRole(PAUSER_ROLE) {
    _pause();
}

function emergencyWithdraw() external onlyRole(ADMIN_ROLE) {
    // ç´§æ€¥æå–é€»è¾‘
}
```

### 2. å‰ç«¯å®‰å…¨

**è¾“å…¥éªŒè¯**:
```typescript
// ä¸¥æ ¼çš„è¾“å…¥éªŒè¯
function validateRedPacketParams(params: CreateRedPacketParams): ValidationResult {
  const errors: string[] = []

  // æ¶ˆæ¯éªŒè¯
  if (!params.message || params.message.trim().length === 0) {
    errors.push('ç¥ç¦è¯­ä¸èƒ½ä¸ºç©º')
  }
  if (params.message.length > 200) {
    errors.push('ç¥ç¦è¯­ä¸èƒ½è¶…è¿‡200ä¸ªå­—ç¬¦')
  }

  // é‡‘é¢éªŒè¯
  if (params.amount <= 0) {
    errors.push('çº¢åŒ…é‡‘é¢å¿…é¡»å¤§äº0')
  }
  if (params.amount > parseEther('100')) {
    errors.push('å•ä¸ªçº¢åŒ…ä¸èƒ½è¶…è¿‡100 ETH')
  }

  // ä»½æ•°éªŒè¯
  if (params.count <= 0 || params.count > 100) {
    errors.push('çº¢åŒ…ä»½æ•°å¿…é¡»åœ¨1-100ä¹‹é—´')
  }

  // æœ€å°é‡‘é¢éªŒè¯
  if (params.amount / params.count < parseEther('0.000001')) {
    errors.push('æ¯ä»½çº¢åŒ…è‡³å°‘éœ€è¦0.000001 ETH')
  }

  return { isValid: errors.length === 0, errors }
}
```

**XSS é˜²æŠ¤**:
```typescript
// å®‰å…¨çš„å†…å®¹æ¸²æŸ“
function SafeMessage({ message }: { message: string }) {
  // ä½¿ç”¨ DOMPurify æ¸…ç† HTML
  const cleanMessage = DOMPurify.sanitize(message, {
    ALLOWED_TAGS: [], // ä¸å…è®¸ä»»ä½• HTML æ ‡ç­¾
    ALLOWED_ATTR: []
  })

  return <span>{cleanMessage}</span>
}

// å®‰å…¨çš„é“¾æ¥å¤„ç†
function SafeLink({ href, children }: { href: string, children: React.ReactNode }) {
  const isInternalLink = href.startsWith('/')
  const isSafeExternal = href.startsWith('https://etherscan.io')

  if (!isInternalLink && !isSafeExternal) {
    return <span>{children}</span> // ä¸å®‰å…¨çš„é“¾æ¥æ˜¾ç¤ºä¸ºçº¯æ–‡æœ¬
  }

  return (
    <a 
      href={href}
      target={isInternalLink ? '_self' : '_blank'}
      rel={isInternalLink ? '' : 'noopener noreferrer'}
    >
      {children}
    </a>
  )
}
```

## ğŸ“ˆ å¯æ‰©å±•æ€§è®¾è®¡

### 1. æ°´å¹³æ‰©å±•èƒ½åŠ›

**å¤šé“¾æ”¯æŒæ¶æ„**:
```typescript
// é“¾é…ç½®æŠ½è±¡
interface ChainConfig {
  chainId: number
  name: string
  rpcUrl: string
  contractAddress: Address
  subgraphUrl: string
  blockExplorer: string
}

const SUPPORTED_CHAINS: ChainConfig[] = [
  {
    chainId: 11155111,
    name: 'Sepolia',
    rpcUrl: process.env.VITE_SEPOLIA_RPC_URL!,
    contractAddress: '0x9986ec8e9D4d0724e7CD9320eD703a3CD69389C1',
    subgraphUrl: 'https://api.studio.thegraph.com/query/...',
    blockExplorer: 'https://sepolia.etherscan.io'
  },
  {
    chainId: 1,
    name: 'Ethereum',
    rpcUrl: process.env.VITE_MAINNET_RPC_URL!,
    contractAddress: '0x...', // ä¸»ç½‘åˆçº¦åœ°å€
    subgraphUrl: 'https://gateway.thegraph.com/api/...',
    blockExplorer: 'https://etherscan.io'
  }
]

// å¤šé“¾å®¢æˆ·ç«¯ç®¡ç†
class MultiChainClient {
  private clients: Map<number, PublicClient> = new Map()

  getClient(chainId: number): PublicClient {
    if (!this.clients.has(chainId)) {
      const config = SUPPORTED_CHAINS.find(c => c.chainId === chainId)
      if (!config) throw new Error(`Unsupported chain: ${chainId}`)

      const client = createPublicClient({
        chain: { ...sepolia, id: chainId }, // åŠ¨æ€é“¾é…ç½®
        transport: http(config.rpcUrl)
      })

      this.clients.set(chainId, client)
    }

    return this.clients.get(chainId)!
  }
}
```

### 2. åŠŸèƒ½æ‰©å±•èƒ½åŠ›

**æ’ä»¶ç³»ç»Ÿè®¾è®¡**:
```typescript
// æ’ä»¶æ¥å£
interface RedPacketPlugin {
  name: string
  version: string
  init(context: PluginContext): void
  destroy(): void
}

// æ’ä»¶ä¸Šä¸‹æ–‡
interface PluginContext {
  hooks: {
    beforeCreate: (params: CreateParams) => Promise<CreateParams>
    afterCreate: (result: CreateResult) => Promise<void>
    beforeClaim: (params: ClaimParams) => Promise<ClaimParams>
    afterClaim: (result: ClaimResult) => Promise<void>
  }
  services: {
    notification: NotificationService
    analytics: AnalyticsService
    storage: StorageService
  }
}

// NFT çº¢åŒ…æ’ä»¶ç¤ºä¾‹
class NFTRedPacketPlugin implements RedPacketPlugin {
  name = 'nft-red-packet'
  version = '1.0.0'

  init(context: PluginContext) {
    // æ‰©å±•åˆ›å»ºçº¢åŒ…åŠŸèƒ½ï¼Œæ”¯æŒ NFT
    context.hooks.beforeCreate = async (params) => {
      if (params.type === 'nft') {
        return await this.prepareNFTParams(params)
      }
      return params
    }

    // æ·»åŠ NFTå±•ç¤ºç»„ä»¶
    context.services.ui.registerComponent('nft-preview', NFTPreviewComponent)
  }

  destroy() {
    // æ¸…ç†èµ„æº
  }

  private async prepareNFTParams(params: any) {
    // NFT ç‰¹å®šçš„å‚æ•°å¤„ç†
    return params
  }
}

// æ’ä»¶ç®¡ç†å™¨
class PluginManager {
  private plugins: RedPacketPlugin[] = []

  register(plugin: RedPacketPlugin) {
    this.plugins.push(plugin)
    plugin.init(this.createContext())
  }

  unregister(pluginName: string) {
    const plugin = this.plugins.find(p => p.name === pluginName)
    if (plugin) {
      plugin.destroy()
      this.plugins = this.plugins.filter(p => p !== plugin)
    }
  }

  private createContext(): PluginContext {
    return {
      hooks: this.createHooks(),
      services: this.createServices()
    }
  }
}
```

### 3. æ•°æ®æ‰©å±•èƒ½åŠ›

**å¤šç‰ˆæœ¬ Schema æ”¯æŒ**:
```graphql
# Schema v1
type RedPacket @entity {
  id: ID!
  creator: Bytes!
  message: String!
  totalAmount: BigInt!
  # v1 å­—æ®µ...
}

# Schema v2 (å‘åå…¼å®¹)
type RedPacket @entity {
  id: ID!
  creator: Bytes!
  message: String!
  totalAmount: BigInt!
  # v1 å­—æ®µ...
  
  # v2 æ–°å¢å­—æ®µ
  category: String
  tags: [String!]
  metadata: String
  version: Int! # ç‰ˆæœ¬æ ‡è¯†
}
```

**æ•°æ®è¿ç§»ç­–ç•¥**:
```typescript
// æ•°æ®ç‰ˆæœ¬è¿ç§»
class DataMigration {
  async migrateToV2(packetId: string): Promise<void> {
    const packet = RedPacket.load(packetId)
    if (!packet) return

    if (packet.version < 2) {
      // è¿ç§»é€»è¾‘
      packet.category = this.inferCategory(packet)
      packet.tags = this.extractTags(packet.message)
      packet.metadata = "{}" // é»˜è®¤ç©º JSON
      packet.version = 2
      
      packet.save()
    }
  }

  private inferCategory(packet: RedPacket): string {
    // æ ¹æ®æ¶ˆæ¯å†…å®¹æ¨æ–­åˆ†ç±»
    const message = packet.message.toLowerCase()
    if (message.includes('æ–°å¹´') || message.includes('æ˜¥èŠ‚')) {
      return 'festival'
    }
    if (message.includes('ç”Ÿæ—¥') || message.includes('birthday')) {
      return 'birthday'
    }
    return 'general'
  }
}
```

## ğŸ” ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 1. åº”ç”¨ç›‘æ§

**æ€§èƒ½æŒ‡æ ‡æ”¶é›†**:
```typescript
// è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()

  measure<T>(operation: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now()
    
    return fn()
      .then(result => {
        this.recordMetric(operation, performance.now() - start)
        return result
      })
      .catch(error => {
        this.recordMetric(`${operation}_error`, performance.now() - start)
        throw error
      })
  }

  private recordMetric(operation: string, duration: number) {
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, [])
    }
    
    this.metrics.get(operation)!.push(duration)
    
    // å‘é€åˆ°åˆ†ææœåŠ¡
    this.sendToAnalytics(operation, duration)
  }

  getMetrics(operation: string) {
    const values = this.metrics.get(operation) || []
    return {
      count: values.length,
      average: values.reduce((a, b) => a + b, 0) / values.length,
      min: Math.min(...values),
      max: Math.max(...values)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor()

const createRedPacket = (params: CreateParams) =>
  monitor.measure('create_red_packet', async () => {
    return await writeContract({
      address: RED_PACKET_ADDRESS,
      abi: RED_PACKET_ABI,
      functionName: 'createRedPacket',
      args: [params.message, params.count, params.isEven],
      value: params.value
    })
  })
```

### 2. é”™è¯¯è¿½è¸ª

**ç»“æ„åŒ–é”™è¯¯å¤„ç†**:
```typescript
// é”™è¯¯ç±»å‹å®šä¹‰
enum ErrorType {
  USER_REJECTED = 'USER_REJECTED',
  INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS',
  CONTRACT_ERROR = 'CONTRACT_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR'
}

class DAppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public context?: any
  ) {
    super(message)
    this.name = 'DAppError'
  }
}

// é”™è¯¯è¾¹ç•Œç»„ä»¶
class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // å‘é€é”™è¯¯åˆ°ç›‘æ§æœåŠ¡
    Sentry.captureException(error, {
      tags: {
        component: 'ErrorBoundary',
        source: 'react'
      },
      extra: {
        errorInfo,
        userAgent: navigator.userAgent,
        url: window.location.href
      }
    })
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />
    }

    return this.props.children
  }
}
```

### 3. ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

**å…³é”®æŒ‡æ ‡å®šä¹‰**:
```typescript
// ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
class BusinessMetrics {
  // çº¢åŒ…ç›¸å…³æŒ‡æ ‡
  trackRedPacketCreated(amount: bigint, count: number, isEven: boolean) {
    this.track('red_packet_created', {
      amount: formatEther(amount),
      count,
      distribution_type: isEven ? 'even' : 'random',
      timestamp: Date.now()
    })
  }

  trackRedPacketClaimed(packetId: string, amount: bigint, claimIndex: number) {
    this.track('red_packet_claimed', {
      packet_id: packetId,
      amount: formatEther(amount),
      claim_index: claimIndex,
      timestamp: Date.now()
    })
  }

  // ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡
  trackUserAction(action: string, properties?: Record<string, any>) {
    this.track(`user_${action}`, {
      ...properties,
      session_id: this.getSessionId(),
      user_address: this.getCurrentUserAddress(),
      timestamp: Date.now()
    })
  }

  // æ€§èƒ½æŒ‡æ ‡
  trackPerformance(metric: string, value: number, unit: string = 'ms') {
    this.track('performance', {
      metric,
      value,
      unit,
      page: window.location.pathname,
      timestamp: Date.now()
    })
  }

  private track(event: string, properties: Record<string, any>) {
    // å‘é€åˆ°åˆ†æå¹³å°
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', event, properties)
    }

    // å‘é€åˆ°è‡ªå®šä¹‰åˆ†ææœåŠ¡
    fetch('/api/analytics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ event, properties })
    }).catch(console.error)
  }
}
```

## ğŸ“š æ¶æ„æ¼”è¿›è·¯çº¿

### ç¬¬ä¸€é˜¶æ®µï¼šMVP (å·²å®Œæˆ)
- âœ… åŸºç¡€çº¢åŒ…åˆ›å»ºå’Œé¢†å–
- âœ… æ™ºèƒ½åˆçº¦éƒ¨ç½²å’ŒéªŒè¯
- âœ… å­å›¾æ•°æ®ç´¢å¼•
- âœ… å‰ç«¯åŸºæœ¬äº¤äº’

### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼º
- ğŸ”„ å¤šä»£å¸æ”¯æŒ (ERC20)
- ğŸ”„ çº¢åŒ…åˆ†äº«åŠŸèƒ½
- ğŸ”„ ç”¨æˆ·ä¸ªäººé¢æ¿
- ğŸ”„ ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–

### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§ç‰¹æ€§
- â³ NFTçº¢åŒ…æ”¯æŒ
- â³ å®šæ—¶çº¢åŒ…åŠŸèƒ½
- â³ ç¾¤ç»„çº¢åŒ…ç³»ç»Ÿ
- â³ çº¢åŒ…æ¨¡æ¿åŠŸèƒ½

### ç¬¬å››é˜¶æ®µï¼šç”Ÿæ€æ‰©å±•
- â³ è·¨é“¾çº¢åŒ…æ”¯æŒ
- â³ Layer 2 é›†æˆ
- â³ å»ä¸­å¿ƒåŒ–æ²»ç†
- â³ å¼€æ”¾APIå¹³å°

### ç¬¬äº”é˜¶æ®µï¼šä¼ä¸šçº§
- â³ ç™½æ ‡è§£å†³æ–¹æ¡ˆ
- â³ ä¼ä¸šçº§ä»ªè¡¨æ¿
- â³ SLA ä¿è¯
- â³ 24/7 æŠ€æœ¯æ”¯æŒ

## ğŸ¯ æ€»ç»“

è¿™ä¸ªçº¢åŒ…DAppé¡¹ç›®å±•ç¤ºäº†ç°ä»£Web3åº”ç”¨å¼€å‘çš„å®Œæ•´æ¶æ„å’Œæœ€ä½³å®è·µï¼š

### æŠ€æœ¯äº®ç‚¹
1. **å…¨æ ˆTypeScript**: ç«¯åˆ°ç«¯ç±»å‹å®‰å…¨
2. **ç°ä»£Web3æ ˆ**: Wagmi + Viem + React Query
3. **å»ä¸­å¿ƒåŒ–æ•°æ®**: The Graph å­å›¾ç´¢å¼•
4. **å®‰å…¨ç¬¬ä¸€**: å¤šå±‚å®‰å…¨é˜²æŠ¤
5. **æ€§èƒ½ä¼˜åŒ–**: å¤šç»´åº¦æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### æ¶æ„ä¼˜åŠ¿
1. **é«˜å¯æ‰©å±•æ€§**: æ’ä»¶åŒ–æ¶æ„æ”¯æŒåŠŸèƒ½æ‰©å±•
2. **å¼ºä¸€è‡´æ€§**: äº‹ä»¶é©±åŠ¨ç¡®ä¿æ•°æ®ä¸€è‡´
3. **é«˜å¯ç”¨æ€§**: åˆ†å¸ƒå¼æ¶æ„æ— å•ç‚¹æ•…éšœ
4. **æ˜“ç»´æŠ¤æ€§**: æ¸…æ™°çš„åˆ†å±‚å’Œæ¨¡å—åŒ–è®¾è®¡
5. **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„ç›‘æ§å’Œé”™è¯¯è¿½è¸ª

### å­¦ä¹ ä»·å€¼
1. **æ™ºèƒ½åˆçº¦å¼€å‘**: Solidity å®‰å…¨ç¼–ç¨‹å®è·µ
2. **å‰ç«¯æ¶æ„è®¾è®¡**: React + Web3 æœ€ä½³å®è·µ
3. **æ•°æ®ç´¢å¼•æ–¹æ¡ˆ**: The Graph æ·±åº¦åº”ç”¨
4. **å…¨æ ˆé¡¹ç›®ç®¡ç†**: å®Œæ•´çš„å¼€å‘åˆ°éƒ¨ç½²æµç¨‹
5. **DeFiäº§å“æ€ç»´**: å»ä¸­å¿ƒåŒ–é‡‘èäº§å“è®¾è®¡

è¿™ä¸ªé¡¹ç›®ä¸ä»…æ˜¯ä¸€ä¸ªå¯ç”¨çš„äº§å“ï¼Œæ›´æ˜¯ä¸€ä¸ªWeb3å…¨æ ˆå¼€å‘çš„å­¦ä¹ æ¨¡æ¿ï¼Œä¸ºæœªæ¥æ›´å¤šåˆ›æ–°çš„å»ä¸­å¿ƒåŒ–åº”ç”¨å¥ å®šäº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚