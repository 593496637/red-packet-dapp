# ğŸ—ï¸ æŠ€æœ¯æ¶æ„ä¸è®¾è®¡æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ€»ä½“æ¶æ„

### ç³»ç»Ÿæ¶æ„å…¨æ™¯å›¾

```
                    ğŸŒ äº’è”ç½‘
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   CDN/Vercel  â”‚ â† å‰ç«¯é™æ€èµ„æºåˆ†å‘
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚      ğŸ¨ å‰ç«¯åº”ç”¨å±‚           â”‚
          â”‚   React + TypeScript        â”‚
          â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
          â”‚   â”‚  UI Components      â”‚   â”‚
          â”‚   â”‚  State Management   â”‚   â”‚
          â”‚   â”‚  Web3 Integration   â”‚   â”‚
          â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚        â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                        â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ“Š æ•°æ®ç´¢å¼•å±‚  â”‚       â”‚ â›“ï¸  åŒºå—é“¾å±‚   â”‚
    â”‚  The Graph    â”‚       â”‚   Ethereum    â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚       â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ Subgraph  â”‚ â”‚â—„â”€â”€â”€â”€â”€â”€â”¤ â”‚  Smart    â”‚ â”‚
    â”‚ â”‚ GraphQL   â”‚ â”‚ äº‹ä»¶ç›‘å¬ â”‚ â”‚ Contract  â”‚ â”‚
    â”‚ â”‚ Database  â”‚ â”‚       â”‚ â”‚  Events   â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                        â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ—„ï¸  æ•°æ®å­˜å‚¨   â”‚       â”‚ ğŸ”— åŒºå—é“¾ç½‘ç»œ  â”‚
    â”‚  PostgreSQL   â”‚       â”‚   Sepolia     â”‚
    â”‚   IPFS Hash   â”‚       â”‚   Mainnet     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¶æ„è®¾è®¡åŸåˆ™

1. **åˆ†å±‚è§£è€¦**: æ¸…æ™°çš„å±‚æ¬¡åˆ’åˆ†ï¼Œé™ä½è€¦åˆåº¦
2. **äº‹ä»¶é©±åŠ¨**: åŸºäºåŒºå—é“¾äº‹ä»¶çš„å“åº”å¼è®¾è®¡
3. **æ•°æ®ä¸€è‡´æ€§**: å¤šæ•°æ®æºçš„æœ€ç»ˆä¸€è‡´æ€§ä¿è¯
4. **é«˜å¯ç”¨æ€§**: æ— å•ç‚¹æ•…éšœçš„åˆ†å¸ƒå¼æ¶æ„
5. **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•å’ŒåŠŸèƒ½æ‰©å±•

## ğŸ¯ æ ¸å¿ƒè®¾è®¡æ¨¡å¼

### 1. é¢†åŸŸé©±åŠ¨è®¾è®¡ (DDD)

```
çº¢åŒ…ç³»ç»Ÿé¢†åŸŸæ¨¡å‹
â”œâ”€â”€ èšåˆæ ¹ (Aggregate Root)
â”‚   â””â”€â”€ RedPacket çº¢åŒ…èšåˆ
â”‚       â”œâ”€â”€ å€¼å¯¹è±¡ (Value Objects)
â”‚       â”‚   â”œâ”€â”€ Money (é‡‘é¢)
â”‚       â”‚   â”œâ”€â”€ Message (ç¥ç¦è¯­)
â”‚       â”‚   â””â”€â”€ ClaimStatus (é¢†å–çŠ¶æ€)
â”‚       â””â”€â”€ å®ä½“ (Entities)
â”‚           â””â”€â”€ Claim (é¢†å–è®°å½•)
â”œâ”€â”€ é¢†åŸŸæœåŠ¡ (Domain Services)
â”‚   â”œâ”€â”€ RedPacketDistributionService
â”‚   â”œâ”€â”€ RandomAmountCalculator
â”‚   â””â”€â”€ ExpirationChecker
â””â”€â”€ ä»“å‚¨ (Repository)
    â”œâ”€â”€ RedPacketRepository
    â””â”€â”€ UserRepository
```

**é¢†åŸŸæ¨¡å‹å®ç°**:
```typescript
// å€¼å¯¹è±¡ - é‡‘é¢
class Money {
  constructor(
    private readonly amount: bigint,
    private readonly decimals: number = 18
  ) {
    if (amount < 0n) {
      throw new Error('Amount cannot be negative')
    }
  }

  toWei(): bigint {
    return this.amount
  }

  toEther(): string {
    return formatEther(this.amount)
  }

  add(other: Money): Money {
    return new Money(this.amount + other.amount, this.decimals)
  }

  subtract(other: Money): Money {
    if (this.amount < other.amount) {
      throw new Error('Insufficient balance')
    }
    return new Money(this.amount - other.amount, this.decimals)
  }

  equals(other: Money): boolean {
    return this.amount === other.amount
  }

  isZero(): boolean {
    return this.amount === 0n
  }
}

// èšåˆæ ¹ - çº¢åŒ…
class RedPacket {
  private constructor(
    public readonly id: RedPacketId,
    public readonly creator: Address,
    public readonly message: Message,
    private totalAmount: Money,
    private balance: Money,
    public readonly totalCount: number,
    private claimedCount: number,
    public readonly isEven: boolean,
    public readonly creationTime: Date,
    private claims: Claim[] = []
  ) {}

  static create(
    id: RedPacketId,
    creator: Address,
    message: Message,
    amount: Money,
    count: number,
    isEven: boolean
  ): RedPacket {
    return new RedPacket(
      id,
      creator,
      message,
      amount,
      amount, // åˆå§‹ä½™é¢ç­‰äºæ€»é‡‘é¢
      count,
      0,
      isEven,
      new Date()
    )
  }

  canBeClaimed(): boolean {
    return this.claimedCount < this.totalCount && !this.balance.isZero()
  }

  hasBeenClaimedBy(address: Address): boolean {
    return this.claims.some(claim => claim.claimer === address)
  }

  claim(claimer: Address, distributionService: RedPacketDistributionService): ClaimResult {
    if (!this.canBeClaimed()) {
      return ClaimResult.failure('No packets left')
    }

    if (this.hasBeenClaimedBy(claimer)) {
      return ClaimResult.failure('Already claimed')
    }

    const amount = distributionService.calculateClaimAmount(
      this.balance,
      this.totalCount - this.claimedCount,
      this.isEven
    )

    const claim = new Claim(
      this.id,
      claimer,
      amount,
      new Date(),
      this.claimedCount + 1
    )

    this.claims.push(claim)
    this.claimedCount++
    this.balance = this.balance.subtract(amount)

    return ClaimResult.success(claim)
  }

  isExpired(): boolean {
    const expirationTime = new Date(this.creationTime.getTime() + 24 * 60 * 60 * 1000)
    return new Date() > expirationTime
  }

  withdraw(requester: Address): WithdrawResult {
    if (requester !== this.creator) {
      return WithdrawResult.failure('Not owner')
    }

    if (!this.isExpired()) {
      return WithdrawResult.failure('Not expired yet')
    }

    if (this.balance.isZero()) {
      return WithdrawResult.failure('No balance to withdraw')
    }

    const amount = this.balance
    this.balance = new Money(0n)

    return WithdrawResult.success(amount)
  }
}
```

### 2. CQRS æ¨¡å¼ (å‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»)

```
å‘½ä»¤ç«¯ (å†™æ“ä½œ)            æŸ¥è¯¢ç«¯ (è¯»æ“ä½œ)
â”œâ”€â”€ CreateRedPacket       â”œâ”€â”€ GetRedPackets
â”œâ”€â”€ ClaimRedPacket        â”œâ”€â”€ GetUserPackets  
â””â”€â”€ WithdrawFunds         â”œâ”€â”€ GetPacketDetails
     â”‚                    â””â”€â”€ GetUserStats
     â–¼                         â–²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Smart       â”‚          â”‚  Subgraph   â”‚
â”‚ Contract    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Database   â”‚
â”‚ (Write)     â”‚  Events  â”‚  (Read)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å‘½ä»¤æ¨¡å¼å®ç°**:
```typescript
// å‘½ä»¤æ¥å£
interface Command {
  execute(): Promise<CommandResult>
}

// åˆ›å»ºçº¢åŒ…å‘½ä»¤
class CreateRedPacketCommand implements Command {
  constructor(
    private readonly walletClient: WalletClient,
    private readonly params: {
      message: string
      count: number
      isEven: boolean
      value: bigint
    }
  ) {}

  async execute(): Promise<CommandResult> {
    try {
      const hash = await this.walletClient.writeContract({
        address: RED_PACKET_ADDRESS,
        abi: RED_PACKET_ABI,
        functionName: 'createRedPacket',
        args: [this.params.message, BigInt(this.params.count), this.params.isEven],
        value: this.params.value
      })

      return CommandResult.success(hash)
    } catch (error) {
      return CommandResult.failure(error.message)
    }
  }
}

// æŸ¥è¯¢æ¨¡å¼å®ç°
class RedPacketQueryService {
  constructor(
    private readonly apolloClient: ApolloClient<any>
  ) {}

  async getRedPackets(params: GetRedPacketsParams): Promise<RedPacket[]> {
    const { data } = await this.apolloClient.query({
      query: GET_RED_PACKETS,
      variables: params,
      fetchPolicy: 'cache-first'
    })

    return data.redPackets.map(this.mapToRedPacket)
  }

  async getUserStats(address: string): Promise<UserStats> {
    const { data } = await this.apolloClient.query({
      query: GET_USER_STATS,
      variables: { userId: address.toLowerCase() }
    })

    return this.mapToUserStats(data.user)
  }

  private mapToRedPacket(raw: any): RedPacket {
    return {
      id: raw.id,
      creator: raw.creator,
      message: raw.message,
      totalAmount: BigInt(raw.totalAmount),
      balance: BigInt(raw.balance),
      totalCount: raw.totalCount,
      claimedCount: raw.claimedCount,
      isEven: raw.isEven,
      creationTime: new Date(raw.creationTime * 1000),
      claims: raw.claims.map(this.mapToClaim)
    }
  }
}
```

### 3. äº‹ä»¶æº¯æºæ¨¡å¼

```
äº‹ä»¶æµ
â”œâ”€â”€ PacketCreated
â”‚   â”œâ”€â”€ çŠ¶æ€: RedPacket åˆ›å»º
â”‚   â””â”€â”€ å‰¯ä½œç”¨: å‘é€é€šçŸ¥
â”œâ”€â”€ PacketClaimed  
â”‚   â”œâ”€â”€ çŠ¶æ€: æ›´æ–°ä½™é¢å’Œè®¡æ•°
â”‚   â””â”€â”€ å‰¯ä½œç”¨: ç”¨æˆ·ä½™é¢æ›´æ–°
â””â”€â”€ PacketEmpty
    â”œâ”€â”€ çŠ¶æ€: æ ‡è®°ä¸ºå·²å®Œæˆ
    â””â”€â”€ å‰¯ä½œç”¨: æ¸…ç†ä»»åŠ¡
```

**äº‹ä»¶å­˜å‚¨å®ç°**:
```typescript
// äº‹ä»¶åŸºç±»
abstract class DomainEvent {
  constructor(
    public readonly aggregateId: string,
    public readonly version: number,
    public readonly occurredAt: Date
  ) {}
}

// çº¢åŒ…åˆ›å»ºäº‹ä»¶
class RedPacketCreatedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    version: number,
    public readonly creator: string,
    public readonly message: string,
    public readonly totalAmount: bigint,
    public readonly totalCount: number,
    public readonly isEven: boolean
  ) {
    super(aggregateId, version, new Date())
  }
}

// äº‹ä»¶å­˜å‚¨
class EventStore {
  private events: Map<string, DomainEvent[]> = new Map()

  append(aggregateId: string, events: DomainEvent[]): void {
    const existingEvents = this.events.get(aggregateId) || []
    this.events.set(aggregateId, [...existingEvents, ...events])
  }

  getEvents(aggregateId: string): DomainEvent[] {
    return this.events.get(aggregateId) || []
  }

  getAllEvents(): DomainEvent[] {
    return Array.from(this.events.values()).flat()
  }
}

// äº‹ä»¶é‡æ’­
class EventSourcing {
  constructor(private readonly eventStore: EventStore) {}

  replayAggregate(aggregateId: string): RedPacket | null {
    const events = this.eventStore.getEvents(aggregateId)
    if (events.length === 0) return null

    return events.reduce((aggregate, event) => {
      if (aggregate === null) {
        if (event instanceof RedPacketCreatedEvent) {
          return RedPacket.create(
            aggregateId,
            event.creator,
            event.message,
            new Money(event.totalAmount),
            event.totalCount,
            event.isEven
          )
        }
        return null
      }

      if (event instanceof RedPacketClaimedEvent) {
        aggregate.applyClaim(event.claimer, new Money(event.amount))
      }

      return aggregate
    }, null as RedPacket | null)
  }
}
```

## ğŸ”§ æŠ€æœ¯é€‰å‹åˆ†æ

### 1. æ™ºèƒ½åˆçº¦å±‚

**é€‰æ‹© Solidity 0.8.28 çš„åŸå› **:
- âœ… åŸç”Ÿæº¢å‡ºæ£€æŸ¥ï¼Œæå‡å®‰å…¨æ€§
- âœ… æ›´å¥½çš„ç¼–è¯‘å™¨ä¼˜åŒ–
- âœ… æ”¯æŒæœ€æ–°çš„ EVM ç‰¹æ€§
- âœ… ä¸°å¯Œçš„å¼€å‘å·¥å…·æ”¯æŒ

**é€‰æ‹© Hardhat 3 Beta çš„åŸå› **:
- âœ… åŸç”Ÿ TypeScript æ”¯æŒ
- âœ… æ›´å¿«çš„ç¼–è¯‘å’Œæµ‹è¯•
- âœ… å†…ç½® Viem é›†æˆ
- âœ… æ”¹è¿›çš„æ’ä»¶ç³»ç»Ÿ

**Gas ä¼˜åŒ–ç­–ç•¥**:
```solidity
// ä¼˜åŒ–å­˜å‚¨å¸ƒå±€
struct RedPacket {
    address owner;        // 20 bytes
    bool isEven;         // 1 byte  - ç´§è·ŸaddressèŠ‚çœå­˜å‚¨æ§½
    uint256 totalAmount; // 32 bytes
    uint256 balance;     // 32 bytes
    uint256 totalCount;  // 32 bytes
    uint256 claimedCount; // 32 bytes
    uint256 creationTime; // 32 bytes
    string message;      // åŠ¨æ€é•¿åº¦ï¼Œå•ç‹¬å­˜å‚¨æ§½
}

// ä¼˜åŒ–å‡½æ•°è°ƒç”¨
function claimRedPacket(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId]; // ä½¿ç”¨ storage å¼•ç”¨
    
    // æ‰¹é‡è¯»å–ï¼Œå‡å°‘ SLOAD
    uint256 currentCount = packet.claimedCount;
    uint256 maxCount = packet.totalCount;
    uint256 currentBalance = packet.balance;
    
    // ... ä¸šåŠ¡é€»è¾‘
}
```

### 2. å‰ç«¯æŠ€æœ¯æ ˆ

**React 19 + TypeScript**:
```typescript
// ç±»å‹å®‰å…¨çš„çŠ¶æ€ç®¡ç†
interface AppState {
  user: {
    address?: Address
    isConnected: boolean
    chainId?: number
  }
  redPackets: {
    items: RedPacket[]
    loading: boolean
    error?: string
  }
}

// è‡ªå®šä¹‰Hookæ¨¡å¼
function useRedPacketActions() {
  const { writeContract } = useWriteContract()
  
  const createRedPacket = useCallback(async (params: CreateParams) => {
    return await writeContract({
      address: RED_PACKET_ADDRESS,
      abi: RED_PACKET_ABI,
      functionName: 'createRedPacket',
      args: [params.message, params.count, params.isEven],
      value: params.value
    })
  }, [writeContract])

  return { createRedPacket }
}
```

**Wagmi v2 + Viem v2 é€‰æ‹©ç†ç”±**:
- âœ… å®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ
- âœ… ç°ä»£åŒ–çš„ React Hooks API
- âœ… è½»é‡çº§ï¼Œæ€§èƒ½ä¼˜å¼‚
- âœ… æ´»è·ƒçš„ç¤¾åŒºå’Œç”Ÿæ€

**çŠ¶æ€ç®¡ç†ç­–ç•¥**:
```typescript
// Web3 çŠ¶æ€ - ç”± Wagmi ç®¡ç†
const { address, isConnected } = useAccount()
const { chain } = useNetwork()

// æœåŠ¡ç«¯çŠ¶æ€ - ç”± React Query ç®¡ç†  
const { data: redPackets, isLoading } = useQuery({
  queryKey: ['redPackets', filters],
  queryFn: () => fetchRedPackets(filters),
  staleTime: 1000 * 60 * 2, // 2åˆ†é’Ÿ
  cacheTime: 1000 * 60 * 10 // 10åˆ†é’Ÿ
})

// å®¢æˆ·ç«¯çŠ¶æ€ - ç”± useState ç®¡ç†
const [selectedPacket, setSelectedPacket] = useState<RedPacket | null>(null)

// å…¨å±€çŠ¶æ€ - ç”± Context ç®¡ç†
const { theme, setTheme } = useTheme()
```

### 3. æ•°æ®å±‚æ¶æ„

**The Graph é€‰æ‹©ç†ç”±**:
- âœ… å»ä¸­å¿ƒåŒ–æ•°æ®ç´¢å¼•
- âœ… GraphQL æŸ¥è¯¢æ¥å£
- âœ… å®æ—¶æ•°æ®åŒæ­¥
- âœ… å¼ºå¤§çš„æ•°æ®è½¬æ¢èƒ½åŠ›

**æ•°æ®æµè®¾è®¡**:
```
åŒºå—é“¾äº‹ä»¶ â†’ Subgraph Mapping â†’ GraphQL Schema â†’ Frontend Query
     â†“              â†“                â†“              â†“
PacketCreated â†’ handlePacketCreated â†’ RedPacket â†’ useRedPackets
PacketClaimed â†’ handlePacketClaimed â†’ Claim    â†’ useUserClaims
```

**æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥**:
```graphql
# ä½¿ç”¨åˆ†é¡µé¿å…å¤§é‡æ•°æ®
query GetRedPackets($first: Int!, $skip: Int!) {
  redPackets(
    first: $first
    skip: $skip
    orderBy: creationTime
    orderDirection: desc
  ) {
    # åªæŸ¥è¯¢å¿…è¦å­—æ®µ
    id
    creator
    message
    totalAmount
    claimedCount
    totalCount
    isActive
  }
}

# ä½¿ç”¨whereè¿‡æ»¤å‡å°‘æ•°æ®ä¼ è¾“
query GetActivePackets {
  redPackets(
    where: { isActive: true }
    first: 10
  ) {
    id
    message
    balance
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å‰ç«¯æ€§èƒ½ä¼˜åŒ–

**ä»£ç åˆ†å‰²ç­–ç•¥**:
```typescript
// è·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
const CreateRedPacket = lazy(() => import('../pages/CreateRedPacket'))
const RedPacketList = lazy(() => import('../pages/RedPacketList'))

// ç»„ä»¶çº§åˆ«çš„ä»£ç åˆ†å‰²
const RedPacketCard = lazy(() => import('../components/RedPacketCard'))

// ç¬¬ä¸‰æ–¹åº“çš„åŠ¨æ€å¯¼å…¥
const loadCharts = () => import('react-chartjs-2')
```

**ç¼“å­˜ç­–ç•¥**:
```typescript
// React Query ç¼“å­˜é…ç½®
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5åˆ†é’Ÿå†…æ•°æ®è®¤ä¸ºæ˜¯æ–°é²œçš„
      cacheTime: 1000 * 60 * 10, // 10åˆ†é’Ÿåæ¸…é™¤ç¼“å­˜
      refetchOnWindowFocus: false,
      retry: (failureCount, error) => {
        if (error.message.includes('User rejected')) {
          return false // ç”¨æˆ·æ‹’ç»ä¸é‡è¯•
        }
        return failureCount < 3
      }
    }
  }
})

// Apollo Client ç¼“å­˜
const apolloClient = new ApolloClient({
  cache: new InMemoryCache({
    typePolicies: {
      RedPacket: {
        keyFields: ['id'],
        fields: {
          claims: {
            merge: false // ä¸åˆå¹¶ï¼Œç›´æ¥æ›¿æ¢
          }
        }
      }
    }
  })
})
```

**è™šæ‹ŸåŒ–é•¿åˆ—è¡¨**:
```typescript
function VirtualizedRedPacketList({ packets }: Props) {
  const containerRef = useRef<HTMLDivElement>(null)
  const itemHeight = 200 // æ¯ä¸ªçº¢åŒ…å¡ç‰‡é«˜åº¦
  
  const { visibleItems, offsetY, totalHeight, onScroll } = useVirtualizedList(
    packets,
    itemHeight,
    600 // å®¹å™¨é«˜åº¦
  )

  return (
    <div 
      ref={containerRef}
      style={{ height: 600, overflow: 'auto' }}
      onScroll={onScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((packet) => (
            <RedPacketCard key={packet.id} packet={packet} />
          ))}
        </div>
      </div>
    </div>
  )
}
```

### 2. æ™ºèƒ½åˆçº¦æ€§èƒ½ä¼˜åŒ–

**Gas ä¼˜åŒ–æŠ€æœ¯**:
```solidity
// ä½¿ç”¨ mapping ä¼˜åŒ–æŸ¥æ‰¾
mapping(uint256 => mapping(address => bool)) public hasClaimed;

// æ‰¹é‡æ“ä½œå‡å°‘äº¤æ˜“è´¹ç”¨
function batchClaim(uint256[] calldata packetIds) external {
    for (uint256 i = 0; i < packetIds.length; i++) {
        _claimInternal(packetIds[i]);
    }
}

// ä½¿ç”¨ storage æŒ‡é’ˆé¿å…é‡å¤è¯»å–
function updatePacket(uint256 packetId) internal {
    RedPacket storage packet = packets[packetId];
    
    // å¤šæ¬¡ä¿®æ”¹åŒä¸€ä¸ª storage
    packet.claimedCount++;
    packet.balance -= amount;
    packet.lastUpdate = block.timestamp;
}

// åˆç†ä½¿ç”¨ view å‡½æ•°
function getPacketInfo(uint256 packetId) 
    external 
    view 
    returns (address owner, uint256 balance, bool isActive) 
{
    RedPacket storage packet = packets[packetId];
    return (
        packet.owner,
        packet.balance,
        packet.claimedCount < packet.totalCount
    );
}
```

### 3. å­å›¾æ€§èƒ½ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**:
```typescript
// åœ¨ mapping ä¸­åˆ›å»ºé«˜æ•ˆç´¢å¼•
export function handlePacketCreated(event: PacketCreated): void {
  let redPacket = new RedPacket(event.params.packetId.toString())
  
  // æ·»åŠ æŸ¥è¯¢ä¼˜åŒ–å­—æ®µ
  redPacket.creatorLowerCase = event.params.creator.toHex().toLowerCase()
  redPacket.dayCreated = getDayId(event.block.timestamp)
  redPacket.monthCreated = getMonthId(event.block.timestamp)
  
  // é¢„è®¡ç®—å¸¸ç”¨ç»Ÿè®¡
  redPacket.averageAmount = event.params.totalAmount.div(
    BigInt.fromI32(event.params.totalCount)
  )
  
  redPacket.save()
}
```

**æŸ¥è¯¢æ‰¹é‡å¤„ç†**:
```graphql
# ä½¿ç”¨ batch æŸ¥è¯¢å‡å°‘ç½‘ç»œè¯·æ±‚
query GetRedPacketData($packetIds: [ID!]!) {
  redPackets(where: { id_in: $packetIds }) {
    id
    creator
    message
    totalAmount
    claims {
      claimer
      amount
    }
  }
}
```

## ğŸ›¡ï¸ å®‰å…¨è®¾è®¡

### 1. æ™ºèƒ½åˆçº¦å®‰å…¨

**é‡å…¥æ”»å‡»é˜²æŠ¤**:
```solidity
// ä½¿ç”¨ CEI æ¨¡å¼
bool private locked;

modifier nonReentrant() {
    require(!locked, "ReentrancyGuard: reentrant call");
    locked = true;
    _;
    locked = false;
}

function claimRedPacket(uint256 _packetId) external nonReentrant {
    // Checks: æ£€æŸ¥
    require(packets[_packetId].claimedCount < packets[_packetId].totalCount);
    require(!hasClaimed[_packetId][msg.sender]);
    
    // Effects: çŠ¶æ€æ›´æ–°
    hasClaimed[_packetId][msg.sender] = true;
    packets[_packetId].claimedCount++;
    
    // Interactions: å¤–éƒ¨è°ƒç”¨
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

**è®¿é—®æ§åˆ¶**:
```solidity
// åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
mapping(bytes32 => mapping(address => bool)) private roles;
bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

modifier onlyRole(bytes32 role) {
    require(hasRole(role, msg.sender), "AccessControl: unauthorized");
    _;
}

function pause() external onlyRole(PAUSER_ROLE) {
    _pause();
}

function emergencyWithdraw() external onlyRole(ADMIN_ROLE) {
    // ç´§æ€¥æå–é€»è¾‘
}
```

### 2. å‰ç«¯å®‰å…¨

**è¾“å…¥éªŒè¯**:
```typescript
// ä¸¥æ ¼çš„è¾“å…¥éªŒè¯
function validateRedPacketParams(params: CreateRedPacketParams): ValidationResult {
  const errors: string[] = []

  // æ¶ˆæ¯éªŒè¯
  if (!params.message || params.message.trim().length === 0) {
    errors.push('ç¥ç¦è¯­ä¸èƒ½ä¸ºç©º')
  }
  if (params.message.length > 200) {
    errors.push('ç¥ç¦è¯­ä¸èƒ½è¶…è¿‡200ä¸ªå­—ç¬¦')
  }

  // é‡‘é¢éªŒè¯
  if (params.amount <= 0) {
    errors.push('çº¢åŒ…é‡‘é¢å¿…é¡»å¤§äº0')
  }
  if (params.amount > parseEther('100')) {
    errors.push('å•ä¸ªçº¢åŒ…ä¸èƒ½è¶…è¿‡100 ETH')
  }

  // ä»½æ•°éªŒè¯
  if (params.count <= 0 || params.count > 100) {
    errors.push('çº¢åŒ…ä»½æ•°å¿…é¡»åœ¨1-100ä¹‹é—´')
  }

  // æœ€å°é‡‘é¢éªŒè¯
  if (params.amount / params.count < parseEther('0.000001')) {
    errors.push('æ¯ä»½çº¢åŒ…è‡³å°‘éœ€è¦0.000001 ETH')
  }

  return { isValid: errors.length === 0, errors }
}
```

**XSS é˜²æŠ¤**:
```typescript
// å®‰å…¨çš„å†…å®¹æ¸²æŸ“
function SafeMessage({ message }: { message: string }) {
  // ä½¿ç”¨ DOMPurify æ¸…ç† HTML
  const cleanMessage = DOMPurify.sanitize(message, {
    ALLOWED_TAGS: [], // ä¸å…è®¸ä»»ä½• HTML æ ‡ç­¾
    ALLOWED_ATTR: []
  })

  return <span>{cleanMessage}</span>
}

// å®‰å…¨çš„é“¾æ¥å¤„ç†
function SafeLink({ href, children }: { href: string, children: React.ReactNode }) {
  const isInternalLink = href.startsWith('/')
  const isSafeExternal = href.startsWith('https://etherscan.io')

  if (!isInternalLink && !isSafeExternal) {
    return <span>{children}</span> // ä¸å®‰å…¨çš„é“¾æ¥æ˜¾ç¤ºä¸ºçº¯æ–‡æœ¬
  }

  return (
    <a 
      href={href}
      target={isInternalLink ? '_self' : '_blank'}
      rel={isInternalLink ? '' : 'noopener noreferrer'}
    >
      {children}
    </a>
  )
}
```

## ğŸ“ˆ å¯æ‰©å±•æ€§è®¾è®¡

### 1. æ°´å¹³æ‰©å±•èƒ½åŠ›

**å¤šé“¾æ”¯æŒæ¶æ„**:
```typescript
// é“¾é…ç½®æŠ½è±¡
interface ChainConfig {
  chainId: number
  name: string
  rpcUrl: string
  contractAddress: Address
  subgraphUrl: string
  blockExplorer: string
}

const SUPPORTED_CHAINS: ChainConfig[] = [
  {
    chainId: 11155111,
    name: 'Sepolia',
    rpcUrl: process.env.VITE_SEPOLIA_RPC_URL!,
    contractAddress: '0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f',
    subgraphUrl: 'https://api.studio.thegraph.com/query/...',
    blockExplorer: 'https://sepolia.etherscan.io'
  },
  {
    chainId: 1,
    name: 'Ethereum',
    rpcUrl: process.env.VITE_MAINNET_RPC_URL!,
    contractAddress: '0x...', // ä¸»ç½‘åˆçº¦åœ°å€
    subgraphUrl: 'https://gateway.thegraph.com/api/...',
    blockExplorer: 'https://etherscan.io'
  }
]

// å¤šé“¾å®¢æˆ·ç«¯ç®¡ç†
class MultiChainClient {
  private clients: Map<number, PublicClient> = new Map()

  getClient(chainId: number): PublicClient {
    if (!this.clients.has(chainId)) {
      const config = SUPPORTED_CHAINS.find(c => c.chainId === chainId)
      if (!config) throw new Error(`Unsupported chain: ${chainId}`)

      const client = createPublicClient({
        chain: { ...sepolia, id: chainId }, // åŠ¨æ€é“¾é…ç½®
        transport: http(config.rpcUrl)
      })

      this.clients.set(chainId, client)
    }

    return this.clients.get(chainId)!
  }
}
```

### 2. åŠŸèƒ½æ‰©å±•èƒ½åŠ›

**æ’ä»¶ç³»ç»Ÿè®¾è®¡**:
```typescript
// æ’ä»¶æ¥å£
interface RedPacketPlugin {
  name: string
  version: string
  init(context: PluginContext): void
  destroy(): void
}

// æ’ä»¶ä¸Šä¸‹æ–‡
interface PluginContext {
  hooks: {
    beforeCreate: (params: CreateParams) => Promise<CreateParams>
    afterCreate: (result: CreateResult) => Promise<void>
    beforeClaim: (params: ClaimParams) => Promise<ClaimParams>
    afterClaim: (result: ClaimResult) => Promise<void>
  }
  services: {
    notification: NotificationService
    analytics: AnalyticsService
    storage: StorageService
  }
}

// NFT çº¢åŒ…æ’ä»¶ç¤ºä¾‹
class NFTRedPacketPlugin implements RedPacketPlugin {
  name = 'nft-red-packet'
  version = '1.0.0'

  init(context: PluginContext) {
    // æ‰©å±•åˆ›å»ºçº¢åŒ…åŠŸèƒ½ï¼Œæ”¯æŒ NFT
    context.hooks.beforeCreate = async (params) => {
      if (params.type === 'nft') {
        return await this.prepareNFTParams(params)
      }
      return params
    }

    // æ·»åŠ NFTå±•ç¤ºç»„ä»¶
    context.services.ui.registerComponent('nft-preview', NFTPreviewComponent)
  }

  destroy() {
    // æ¸…ç†èµ„æº
  }

  private async prepareNFTParams(params: any) {
    // NFT ç‰¹å®šçš„å‚æ•°å¤„ç†
    return params
  }
}

// æ’ä»¶ç®¡ç†å™¨
class PluginManager {
  private plugins: RedPacketPlugin[] = []

  register(plugin: RedPacketPlugin) {
    this.plugins.push(plugin)
    plugin.init(this.createContext())
  }

  unregister(pluginName: string) {
    const plugin = this.plugins.find(p => p.name === pluginName)
    if (plugin) {
      plugin.destroy()
      this.plugins = this.plugins.filter(p => p !== plugin)
    }
  }

  private createContext(): PluginContext {
    return {
      hooks: this.createHooks(),
      services: this.createServices()
    }
  }
}
```

### 3. æ•°æ®æ‰©å±•èƒ½åŠ›

**å¤šç‰ˆæœ¬ Schema æ”¯æŒ**:
```graphql
# Schema v1
type RedPacket @entity {
  id: ID!
  creator: Bytes!
  message: String!
  totalAmount: BigInt!
  # v1 å­—æ®µ...
}

# Schema v2 (å‘åå…¼å®¹)
type RedPacket @entity {
  id: ID!
  creator: Bytes!
  message: String!
  totalAmount: BigInt!
  # v1 å­—æ®µ...
  
  # v2 æ–°å¢å­—æ®µ
  category: String
  tags: [String!]
  metadata: String
  version: Int! # ç‰ˆæœ¬æ ‡è¯†
}
```

**æ•°æ®è¿ç§»ç­–ç•¥**:
```typescript
// æ•°æ®ç‰ˆæœ¬è¿ç§»
class DataMigration {
  async migrateToV2(packetId: string): Promise<void> {
    const packet = RedPacket.load(packetId)
    if (!packet) return

    if (packet.version < 2) {
      // è¿ç§»é€»è¾‘
      packet.category = this.inferCategory(packet)
      packet.tags = this.extractTags(packet.message)
      packet.metadata = "{}" // é»˜è®¤ç©º JSON
      packet.version = 2
      
      packet.save()
    }
  }

  private inferCategory(packet: RedPacket): string {
    // æ ¹æ®æ¶ˆæ¯å†…å®¹æ¨æ–­åˆ†ç±»
    const message = packet.message.toLowerCase()
    if (message.includes('æ–°å¹´') || message.includes('æ˜¥èŠ‚')) {
      return 'festival'
    }
    if (message.includes('ç”Ÿæ—¥') || message.includes('birthday')) {
      return 'birthday'
    }
    return 'general'
  }
}
```

## ğŸ” ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 1. åº”ç”¨ç›‘æ§

**æ€§èƒ½æŒ‡æ ‡æ”¶é›†**:
```typescript
// è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()

  measure<T>(operation: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now()
    
    return fn()
      .then(result => {
        this.recordMetric(operation, performance.now() - start)
        return result
      })
      .catch(error => {
        this.recordMetric(`${operation}_error`, performance.now() - start)
        throw error
      })
  }

  private recordMetric(operation: string, duration: number) {
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, [])
    }
    
    this.metrics.get(operation)!.push(duration)
    
    // å‘é€åˆ°åˆ†ææœåŠ¡
    this.sendToAnalytics(operation, duration)
  }

  getMetrics(operation: string) {
    const values = this.metrics.get(operation) || []
    return {
      count: values.length,
      average: values.reduce((a, b) => a + b, 0) / values.length,
      min: Math.min(...values),
      max: Math.max(...values)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor()

const createRedPacket = (params: CreateParams) =>
  monitor.measure('create_red_packet', async () => {
    return await writeContract({
      address: RED_PACKET_ADDRESS,
      abi: RED_PACKET_ABI,
      functionName: 'createRedPacket',
      args: [params.message, params.count, params.isEven],
      value: params.value
    })
  })
```

### 2. é”™è¯¯è¿½è¸ª

**ç»“æ„åŒ–é”™è¯¯å¤„ç†**:
```typescript
// é”™è¯¯ç±»å‹å®šä¹‰
enum ErrorType {
  USER_REJECTED = 'USER_REJECTED',
  INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS',
  CONTRACT_ERROR = 'CONTRACT_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR'
}

class DAppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public context?: any
  ) {
    super(message)
    this.name = 'DAppError'
  }
}

// é”™è¯¯è¾¹ç•Œç»„ä»¶
class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // å‘é€é”™è¯¯åˆ°ç›‘æ§æœåŠ¡
    Sentry.captureException(error, {
      tags: {
        component: 'ErrorBoundary',
        source: 'react'
      },
      extra: {
        errorInfo,
        userAgent: navigator.userAgent,
        url: window.location.href
      }
    })
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />
    }

    return this.props.children
  }
}
```

### 3. ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

**å…³é”®æŒ‡æ ‡å®šä¹‰**:
```typescript
// ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
class BusinessMetrics {
  // çº¢åŒ…ç›¸å…³æŒ‡æ ‡
  trackRedPacketCreated(amount: bigint, count: number, isEven: boolean) {
    this.track('red_packet_created', {
      amount: formatEther(amount),
      count,
      distribution_type: isEven ? 'even' : 'random',
      timestamp: Date.now()
    })
  }

  trackRedPacketClaimed(packetId: string, amount: bigint, claimIndex: number) {
    this.track('red_packet_claimed', {
      packet_id: packetId,
      amount: formatEther(amount),
      claim_index: claimIndex,
      timestamp: Date.now()
    })
  }

  // ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡
  trackUserAction(action: string, properties?: Record<string, any>) {
    this.track(`user_${action}`, {
      ...properties,
      session_id: this.getSessionId(),
      user_address: this.getCurrentUserAddress(),
      timestamp: Date.now()
    })
  }

  // æ€§èƒ½æŒ‡æ ‡
  trackPerformance(metric: string, value: number, unit: string = 'ms') {
    this.track('performance', {
      metric,
      value,
      unit,
      page: window.location.pathname,
      timestamp: Date.now()
    })
  }

  private track(event: string, properties: Record<string, any>) {
    // å‘é€åˆ°åˆ†æå¹³å°
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', event, properties)
    }

    // å‘é€åˆ°è‡ªå®šä¹‰åˆ†ææœåŠ¡
    fetch('/api/analytics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ event, properties })
    }).catch(console.error)
  }
}
```

## ğŸ“š æ¶æ„æ¼”è¿›è·¯çº¿

### ç¬¬ä¸€é˜¶æ®µï¼šMVP (å·²å®Œæˆ)
- âœ… åŸºç¡€çº¢åŒ…åˆ›å»ºå’Œé¢†å–
- âœ… æ™ºèƒ½åˆçº¦éƒ¨ç½²å’ŒéªŒè¯
- âœ… å­å›¾æ•°æ®ç´¢å¼•
- âœ… å‰ç«¯åŸºæœ¬äº¤äº’

### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼º
- ğŸ”„ å¤šä»£å¸æ”¯æŒ (ERC20)
- ğŸ”„ çº¢åŒ…åˆ†äº«åŠŸèƒ½
- ğŸ”„ ç”¨æˆ·ä¸ªäººé¢æ¿
- ğŸ”„ ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–

### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§ç‰¹æ€§
- â³ NFTçº¢åŒ…æ”¯æŒ
- â³ å®šæ—¶çº¢åŒ…åŠŸèƒ½
- â³ ç¾¤ç»„çº¢åŒ…ç³»ç»Ÿ
- â³ çº¢åŒ…æ¨¡æ¿åŠŸèƒ½

### ç¬¬å››é˜¶æ®µï¼šç”Ÿæ€æ‰©å±•
- â³ è·¨é“¾çº¢åŒ…æ”¯æŒ
- â³ Layer 2 é›†æˆ
- â³ å»ä¸­å¿ƒåŒ–æ²»ç†
- â³ å¼€æ”¾APIå¹³å°

### ç¬¬äº”é˜¶æ®µï¼šä¼ä¸šçº§
- â³ ç™½æ ‡è§£å†³æ–¹æ¡ˆ
- â³ ä¼ä¸šçº§ä»ªè¡¨æ¿
- â³ SLA ä¿è¯
- â³ 24/7 æŠ€æœ¯æ”¯æŒ

## ğŸ¯ æ€»ç»“

è¿™ä¸ªçº¢åŒ…DAppé¡¹ç›®å±•ç¤ºäº†ç°ä»£Web3åº”ç”¨å¼€å‘çš„å®Œæ•´æ¶æ„å’Œæœ€ä½³å®è·µï¼š

### æŠ€æœ¯äº®ç‚¹
1. **å…¨æ ˆTypeScript**: ç«¯åˆ°ç«¯ç±»å‹å®‰å…¨
2. **ç°ä»£Web3æ ˆ**: Wagmi + Viem + React Query
3. **å»ä¸­å¿ƒåŒ–æ•°æ®**: The Graph å­å›¾ç´¢å¼•
4. **å®‰å…¨ç¬¬ä¸€**: å¤šå±‚å®‰å…¨é˜²æŠ¤
5. **æ€§èƒ½ä¼˜åŒ–**: å¤šç»´åº¦æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### æ¶æ„ä¼˜åŠ¿
1. **é«˜å¯æ‰©å±•æ€§**: æ’ä»¶åŒ–æ¶æ„æ”¯æŒåŠŸèƒ½æ‰©å±•
2. **å¼ºä¸€è‡´æ€§**: äº‹ä»¶é©±åŠ¨ç¡®ä¿æ•°æ®ä¸€è‡´
3. **é«˜å¯ç”¨æ€§**: åˆ†å¸ƒå¼æ¶æ„æ— å•ç‚¹æ•…éšœ
4. **æ˜“ç»´æŠ¤æ€§**: æ¸…æ™°çš„åˆ†å±‚å’Œæ¨¡å—åŒ–è®¾è®¡
5. **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„ç›‘æ§å’Œé”™è¯¯è¿½è¸ª

### å­¦ä¹ ä»·å€¼
1. **æ™ºèƒ½åˆçº¦å¼€å‘**: Solidity å®‰å…¨ç¼–ç¨‹å®è·µ
2. **å‰ç«¯æ¶æ„è®¾è®¡**: React + Web3 æœ€ä½³å®è·µ
3. **æ•°æ®ç´¢å¼•æ–¹æ¡ˆ**: The Graph æ·±åº¦åº”ç”¨
4. **å…¨æ ˆé¡¹ç›®ç®¡ç†**: å®Œæ•´çš„å¼€å‘åˆ°éƒ¨ç½²æµç¨‹
5. **DeFiäº§å“æ€ç»´**: å»ä¸­å¿ƒåŒ–é‡‘èäº§å“è®¾è®¡

è¿™ä¸ªé¡¹ç›®ä¸ä»…æ˜¯ä¸€ä¸ªå¯ç”¨çš„äº§å“ï¼Œæ›´æ˜¯ä¸€ä¸ªWeb3å…¨æ ˆå¼€å‘çš„å­¦ä¹ æ¨¡æ¿ï¼Œä¸ºæœªæ¥æ›´å¤šåˆ›æ–°çš„å»ä¸­å¿ƒåŒ–åº”ç”¨å¥ å®šäº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚