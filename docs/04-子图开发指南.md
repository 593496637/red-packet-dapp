# 📊 Subgraph 开发完整指南

## 📋 开发前准备

### 什么是 The Graph 和 Subgraph？

**The Graph** 是一个去中心化的区块链数据索引协议，它让开发者能够快速构建和发布开放的API（子图），应用可以使用GraphQL查询这些数据。

**Subgraph** 是针对特定智能合约的数据索引器，它：
- 监听区块链上的事件
- 处理和转换数据
- 提供GraphQL API供前端查询
- 大大提升dApp的数据查询性能

### 为什么需要 Subgraph？

```
传统方式查询区块链数据：
前端 → RPC节点 → 遍历所有区块和交易 → 过滤事件 → 返回数据
🐌 慢、消耗资源、体验差

使用 Subgraph：
前端 → GraphQL API → 已索引的数据库 → 快速返回结构化数据  
⚡ 快、高效、用户体验好
```

### 红包系统的数据需求分析

1. **红包列表查询**
   - 按时间排序的所有红包
   - 按创建者过滤的红包
   - 红包状态统计

2. **红包详情查询**
   - 红包基本信息
   - 所有领取记录
   - 领取进度统计

3. **用户统计数据**
   - 用户创建的红包数量
   - 用户领取的红包数量
   - 用户的收支统计

## 🏗️ 开发环境搭建

### 1. 安装 Graph CLI

```bash
# 全局安装 Graph CLI
npm install -g @graphprotocol/graph-cli

# 验证安装
graph --version
```

### 2. 初始化 Subgraph 项目

```bash
# 创建项目目录
mkdir red-packet-subgraph
cd red-packet-subgraph

# 初始化 subgraph
graph init \
  --studio \
  red-packet-subgraph \
  --from-contract 0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f \
  --network sepolia \
  --contract-name RedPacketSystem

# 或者从现有目录初始化
graph init --from-contract 0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f --network sepolia
```

### 3. 项目结构解析

```
red-packet-subgraph/
├── schema.graphql         # 数据模型定义
├── subgraph.yaml         # 子图配置文件
├── src/
│   └── mapping.ts        # 事件处理逻辑
├── generated/            # 自动生成的类型文件
├── build/               # 构建输出
├── package.json
└── README.md
```

### 4. 核心配置文件

**package.json**:
```json
{
  "name": "red-packet-subgraph",
  "version": "0.1.0",
  "description": "Subgraph for Red Packet DApp",
  "scripts": {
    "codegen": "graph codegen",
    "build": "graph build",
    "deploy": "graph deploy --studio red-packet-subgraph",
    "create-local": "graph create --node http://localhost:8020/ red-packet-subgraph",
    "remove-local": "graph remove --node http://localhost:8020/ red-packet-subgraph",
    "deploy-local": "graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 red-packet-subgraph",
    "test": "graph test"
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.69.0",
    "@graphprotocol/graph-ts": "^0.34.0"
  }
}
```

## 💡 数据模型设计

### 1. GraphQL Schema 设计

**schema.graphql**:
```graphql
# 红包实体
type RedPacket @entity {
  id: ID!                           # 红包ID
  creator: Bytes!                   # 创建者地址
  message: String!                  # 祝福语
  totalAmount: BigInt!              # 总金额（wei）
  balance: BigInt!                  # 剩余金额（wei）  
  totalCount: Int!                  # 总份数
  claimedCount: Int!                # 已领取份数
  isEven: Boolean!                  # 是否均分模式
  creationTime: BigInt!             # 创建时间戳
  blockNumber: BigInt!              # 创建区块号
  transactionHash: Bytes!           # 交易哈希
  
  # 关联关系
  claims: [Claim!]! @derivedFrom(field: "redPacket")  # 所有领取记录
  
  # 计算字段（在mapping中计算）
  isActive: Boolean!                # 是否仍可领取
  averageAmount: BigInt!            # 平均金额
  completionRate: BigDecimal!       # 完成率 (0-1)
}

# 领取记录实体
type Claim @entity {
  id: ID!                          # 领取记录ID (packetId-claimer)
  redPacket: RedPacket!            # 关联的红包
  claimer: Bytes!                  # 领取者地址
  amount: BigInt!                  # 领取金额（wei）
  timestamp: BigInt!               # 领取时间戳
  blockNumber: BigInt!             # 领取区块号
  transactionHash: Bytes!          # 交易哈希
  claimIndex: Int!                 # 领取序号（第几个领取）
}

# 用户统计实体
type User @entity {
  id: ID!                          # 用户地址
  address: Bytes!                  # 用户地址
  
  # 创建统计
  createdPacketsCount: Int!        # 创建红包数量
  totalAmountCreated: BigInt!      # 创建红包总金额
  createdPackets: [RedPacket!]! @derivedFrom(field: "creator")
  
  # 领取统计
  claimedPacketsCount: Int!        # 领取红包数量
  totalAmountClaimed: BigInt!      # 领取红包总金额
  claims: [Claim!]! @derivedFrom(field: "claimer")
  
  # 时间统计
  firstActivity: BigInt!           # 首次活动时间
  lastActivity: BigInt!            # 最后活动时间
}

# 全局统计实体
type GlobalStats @entity {
  id: ID!                          # 固定为 "global"
  totalPackets: Int!               # 总红包数量
  totalAmount: BigInt!             # 总金额
  totalClaims: Int!                # 总领取次数
  activePackets: Int!              # 活跃红包数量
  totalUsers: Int!                 # 总用户数
  lastUpdated: BigInt!             # 最后更新时间
}

# 每日统计实体
type DayStats @entity {
  id: ID!                          # 格式: "YYYY-MM-DD"
  date: Int!                       # 日期戳
  packetsCreated: Int!             # 当日创建红包数
  packetsClaimed: Int!             # 当日领取红包数  
  amountCreated: BigInt!           # 当日创建金额
  amountClaimed: BigInt!           # 当日领取金额
  activeUsers: Int!                # 当日活跃用户数
}
```

### 2. 数据模型设计原则

1. **实体关系设计**
   - `RedPacket` ↔ `Claim`: 一对多关系
   - `User` ↔ `RedPacket`: 一对多关系（创建者）
   - `User` ↔ `Claim`: 一对多关系（领取者）

2. **索引优化**
   - 经常查询的字段设为索引
   - 时间字段用于排序和过滤
   - 关联字段提升查询性能

3. **计算字段**
   - 实时计算的状态字段
   - 聚合统计数据
   - 便于前端直接使用

## 🔧 事件处理逻辑实现

### 1. Subgraph 配置

**subgraph.yaml**:
```yaml
specVersion: 1.0.0
indexerHints:
  prune: auto
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: RedPacketSystem
    network: sepolia
    source:
      address: "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"
      abi: RedPacketSystem
      startBlock: 4800000  # 合约部署的区块号
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      entities:
        - RedPacket
        - Claim
        - User
        - GlobalStats
        - DayStats
      abis:
        - name: RedPacketSystem
          file: ./abis/RedPacketSystem.json
      eventHandlers:
        - event: PacketCreated(indexed uint256,indexed address,string,uint256,uint256,bool)
          handler: handlePacketCreated
        - event: PacketClaimed(indexed uint256,indexed address,uint256)
          handler: handlePacketClaimed
        - event: PacketEmpty(indexed uint256)
          handler: handlePacketEmpty
        - event: FundsWithdrawn(indexed uint256,indexed address,uint256)
          handler: handleFundsWithdrawn
      file: ./src/mapping.ts
```

### 2. 映射逻辑实现

**src/mapping.ts**:
```typescript
import {
  PacketCreated,
  PacketClaimed,
  PacketEmpty,
  FundsWithdrawn
} from "../generated/RedPacketSystem/RedPacketSystem"

import {
  RedPacket,
  Claim,
  User,
  GlobalStats,
  DayStats
} from "../generated/schema"

import {
  BigInt,
  BigDecimal,
  Address,
  Bytes
} from "@graphprotocol/graph-ts"

// 常量定义
const GLOBAL_STATS_ID = "global"
const ZERO_BI = BigInt.fromI32(0)
const ONE_BI = BigInt.fromI32(1)

// 工具函数：获取或创建用户实体
function getOrCreateUser(address: Address): User {
  let user = User.load(address.toHex())
  
  if (user === null) {
    user = new User(address.toHex())
    user.address = address
    user.createdPacketsCount = 0
    user.totalAmountCreated = ZERO_BI
    user.claimedPacketsCount = 0
    user.totalAmountClaimed = ZERO_BI
    user.firstActivity = ZERO_BI
    user.lastActivity = ZERO_BI
    user.save()
    
    // 更新全局用户统计
    updateGlobalUserCount()
  }
  
  return user
}

// 工具函数：获取或创建全局统计
function getOrCreateGlobalStats(): GlobalStats {
  let stats = GlobalStats.load(GLOBAL_STATS_ID)
  
  if (stats === null) {
    stats = new GlobalStats(GLOBAL_STATS_ID)
    stats.totalPackets = 0
    stats.totalAmount = ZERO_BI
    stats.totalClaims = 0
    stats.activePackets = 0
    stats.totalUsers = 0
    stats.lastUpdated = ZERO_BI
  }
  
  return stats
}

// 工具函数：获取每日统计ID
function getDayStatsId(timestamp: BigInt): string {
  const date = new Date(timestamp.toI32() * 1000)
  const year = date.getUTCFullYear()
  const month = date.getUTCMonth() + 1
  const day = date.getUTCDate()
  
  const monthStr = month < 10 ? "0" + month.toString() : month.toString()
  const dayStr = day < 10 ? "0" + day.toString() : day.toString()
  
  return year.toString() + "-" + monthStr + "-" + dayStr
}

// 工具函数：获取或创建每日统计
function getOrCreateDayStats(timestamp: BigInt): DayStats {
  const dayStatsId = getDayStatsId(timestamp)
  let dayStats = DayStats.load(dayStatsId)
  
  if (dayStats === null) {
    dayStats = new DayStats(dayStatsId)
    const date = new Date(timestamp.toI32() * 1000)
    dayStats.date = BigInt.fromI32(Math.floor(date.getTime() / 1000 / 86400) * 86400)
    dayStats.packetsCreated = 0
    dayStats.packetsClaimed = 0
    dayStats.amountCreated = ZERO_BI
    dayStats.amountClaimed = ZERO_BI
    dayStats.activeUsers = 0
  }
  
  return dayStats
}

// 工具函数：更新全局用户数量
function updateGlobalUserCount(): void {
  let stats = getOrCreateGlobalStats()
  stats.totalUsers = stats.totalUsers + 1
  stats.save()
}

// 工具函数：计算完成率
function calculateCompletionRate(claimedCount: i32, totalCount: i32): BigDecimal {
  if (totalCount === 0) {
    return BigDecimal.fromString("0")
  }
  return BigDecimal.fromString(claimedCount.toString()).div(BigDecimal.fromString(totalCount.toString()))
}

// 事件处理器：红包创建
export function handlePacketCreated(event: PacketCreated): void {
  // 创建红包实体
  let redPacket = new RedPacket(event.params.packetId.toString())
  
  redPacket.creator = event.params.creator
  redPacket.message = event.params.message
  redPacket.totalAmount = event.params.totalAmount
  redPacket.balance = event.params.totalAmount  // 初始余额等于总金额
  redPacket.totalCount = event.params.totalCount.toI32()
  redPacket.claimedCount = 0
  redPacket.isEven = event.params.isEven
  redPacket.creationTime = event.block.timestamp
  redPacket.blockNumber = event.block.number
  redPacket.transactionHash = event.transaction.hash
  
  // 计算字段
  redPacket.isActive = true
  redPacket.averageAmount = event.params.totalAmount.div(BigInt.fromI32(event.params.totalCount.toI32()))
  redPacket.completionRate = BigDecimal.fromString("0")
  
  redPacket.save()

  // 更新用户统计
  let creator = getOrCreateUser(event.params.creator)
  creator.createdPacketsCount = creator.createdPacketsCount + 1
  creator.totalAmountCreated = creator.totalAmountCreated.plus(event.params.totalAmount)
  
  if (creator.firstActivity.equals(ZERO_BI)) {
    creator.firstActivity = event.block.timestamp
  }
  creator.lastActivity = event.block.timestamp
  creator.save()

  // 更新全局统计
  let globalStats = getOrCreateGlobalStats()
  globalStats.totalPackets = globalStats.totalPackets + 1
  globalStats.totalAmount = globalStats.totalAmount.plus(event.params.totalAmount)
  globalStats.activePackets = globalStats.activePackets + 1
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()

  // 更新每日统计
  let dayStats = getOrCreateDayStats(event.block.timestamp)
  dayStats.packetsCreated = dayStats.packetsCreated + 1
  dayStats.amountCreated = dayStats.amountCreated.plus(event.params.totalAmount)
  dayStats.save()
}

// 事件处理器：红包领取
export function handlePacketClaimed(event: PacketClaimed): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    // 这不应该发生，但为了安全起见
    return
  }

  // 创建领取记录
  let claimId = event.params.packetId.toString() + "-" + event.params.claimer.toHex()
  let claim = new Claim(claimId)
  
  claim.redPacket = redPacket.id
  claim.claimer = event.params.claimer
  claim.amount = event.params.amount
  claim.timestamp = event.block.timestamp
  claim.blockNumber = event.block.number
  claim.transactionHash = event.transaction.hash
  claim.claimIndex = redPacket.claimedCount + 1  // 领取序号
  
  claim.save()

  // 更新红包状态
  redPacket.claimedCount = redPacket.claimedCount + 1
  redPacket.balance = redPacket.balance.minus(event.params.amount)
  redPacket.completionRate = calculateCompletionRate(redPacket.claimedCount, redPacket.totalCount)
  
  // 检查是否还能领取
  if (redPacket.claimedCount >= redPacket.totalCount) {
    redPacket.isActive = false
  }
  
  redPacket.save()

  // 更新用户统计
  let claimer = getOrCreateUser(event.params.claimer)
  claimer.claimedPacketsCount = claimer.claimedPacketsCount + 1
  claimer.totalAmountClaimed = claimer.totalAmountClaimed.plus(event.params.amount)
  
  if (claimer.firstActivity.equals(ZERO_BI)) {
    claimer.firstActivity = event.block.timestamp
  }
  claimer.lastActivity = event.block.timestamp
  claimer.save()

  // 更新全局统计
  let globalStats = getOrCreateGlobalStats()
  globalStats.totalClaims = globalStats.totalClaims + 1
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()

  // 更新每日统计
  let dayStats = getOrCreateDayStats(event.block.timestamp)
  dayStats.packetsClaimed = dayStats.packetsClaimed + 1
  dayStats.amountClaimed = dayStats.amountClaimed.plus(event.params.amount)
  dayStats.save()
}

// 事件处理器：红包抢完
export function handlePacketEmpty(event: PacketEmpty): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    return
  }

  // 确保红包状态正确
  redPacket.isActive = false
  redPacket.completionRate = BigDecimal.fromString("1")
  redPacket.save()

  // 更新全局活跃红包数量
  let globalStats = getOrCreateGlobalStats()
  globalStats.activePackets = globalStats.activePackets - 1
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()
}

// 事件处理器：资金提取
export function handleFundsWithdrawn(event: FundsWithdrawn): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    return
  }

  // 更新红包状态
  redPacket.balance = ZERO_BI
  redPacket.isActive = false
  redPacket.save()

  // 更新全局活跃红包数量
  let globalStats = getOrCreateGlobalStats()
  if (redPacket.isActive) {
    globalStats.activePackets = globalStats.activePackets - 1
  }
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()
}
```

### 3. 高级查询优化

为了提供更好的查询性能，我们需要在映射中添加一些索引字段：

```typescript
// 在 handlePacketCreated 中添加
redPacket.creatorLowerCase = event.params.creator.toHex().toLowerCase()  // 便于搜索
redPacket.dayCreated = getDayStatsId(event.block.timestamp)              // 便于按天过滤

// 在 handlePacketClaimed 中添加  
claim.claimerLowerCase = event.params.claimer.toHex().toLowerCase()      // 便于搜索
claim.dayCreated = getDayStatsId(event.block.timestamp)                  // 便于按天过滤
```

## 🧪 测试与调试

### 1. 本地测试环境搭建

**安装 Matchstick 测试框架**:
```bash
# 安装测试依赖
npm install --save-dev matchstick-as

# 创建测试目录
mkdir tests
```

**tests/red-packet-system.test.ts**:
```typescript
import {
  test,
  assert,
  describe,
  beforeEach,
  clearStore,
  createMockedFunction,
  newMockEvent
} from "matchstick-as/assembly/index"

import { 
  handlePacketCreated,
  handlePacketClaimed 
} from "../src/mapping"

import { PacketCreated, PacketClaimed } from "../generated/RedPacketSystem/RedPacketSystem"
import { RedPacket, Claim } from "../generated/schema"
import { BigInt, Address, ethereum } from "@graphprotocol/graph-ts"

// 测试工具函数
function createPacketCreatedEvent(
  packetId: BigInt,
  creator: Address,
  message: string,
  totalAmount: BigInt,
  totalCount: BigInt,
  isEven: boolean
): PacketCreated {
  let event = changetype<PacketCreated>(newMockEvent())
  
  event.parameters = []
  
  event.parameters.push(
    new ethereum.EventParam("packetId", ethereum.Value.fromUnsignedBigInt(packetId))
  )
  event.parameters.push(
    new ethereum.EventParam("creator", ethereum.Value.fromAddress(creator))
  )
  event.parameters.push(
    new ethereum.EventParam("message", ethereum.Value.fromString(message))
  )
  event.parameters.push(
    new ethereum.EventParam("totalAmount", ethereum.Value.fromUnsignedBigInt(totalAmount))
  )
  event.parameters.push(
    new ethereum.EventParam("totalCount", ethereum.Value.fromUnsignedBigInt(totalCount))
  )
  event.parameters.push(
    new ethereum.EventParam("isEven", ethereum.Value.fromBoolean(isEven))
  )

  return event
}

function createPacketClaimedEvent(
  packetId: BigInt,
  claimer: Address,
  amount: BigInt
): PacketClaimed {
  let event = changetype<PacketClaimed>(newMockEvent())
  
  event.parameters = []
  
  event.parameters.push(
    new ethereum.EventParam("packetId", ethereum.Value.fromUnsignedBigInt(packetId))
  )
  event.parameters.push(
    new ethereum.EventParam("claimer", ethereum.Value.fromAddress(claimer))
  )
  event.parameters.push(
    new ethereum.EventParam("amount", ethereum.Value.fromUnsignedBigInt(amount))
  )

  return event
}

// 测试用例
describe("Red Packet System", () => {
  beforeEach(() => {
    clearStore() // 清理测试存储
  })

  test("Should create red packet correctly", () => {
    // 准备测试数据
    let packetId = BigInt.fromI32(1)
    let creator = Address.fromString("0x1234567890123456789012345678901234567890")
    let message = "Happy New Year!"
    let totalAmount = BigInt.fromString("1000000000000000000") // 1 ETH
    let totalCount = BigInt.fromI32(5)
    let isEven = true

    // 创建并处理事件
    let event = createPacketCreatedEvent(packetId, creator, message, totalAmount, totalCount, isEven)
    handlePacketCreated(event)

    // 验证红包实体
    let redPacket = RedPacket.load("1")
    assert.assertNotNull(redPacket)
    
    if (redPacket !== null) {
      assert.bytesEquals(redPacket.creator, creator)
      assert.stringEquals(redPacket.message, message)
      assert.bigIntEquals(redPacket.totalAmount, totalAmount)
      assert.bigIntEquals(redPacket.balance, totalAmount)
      assert.i32Equals(redPacket.totalCount, 5)
      assert.i32Equals(redPacket.claimedCount, 0)
      assert.booleanEquals(redPacket.isEven, true)
      assert.booleanEquals(redPacket.isActive, true)
    }
  })

  test("Should handle red packet claim correctly", () => {
    // 先创建红包
    let packetId = BigInt.fromI32(1)
    let creator = Address.fromString("0x1234567890123456789012345678901234567890")
    let claimer = Address.fromString("0x0987654321098765432109876543210987654321")
    
    let createEvent = createPacketCreatedEvent(
      packetId,
      creator,
      "Test packet",
      BigInt.fromString("1000000000000000000"),
      BigInt.fromI32(2),
      false
    )
    handlePacketCreated(createEvent)

    // 然后处理领取事件
    let claimAmount = BigInt.fromString("600000000000000000") // 0.6 ETH
    let claimEvent = createPacketClaimedEvent(packetId, claimer, claimAmount)
    handlePacketClaimed(claimEvent)

    // 验证红包状态更新
    let redPacket = RedPacket.load("1")
    assert.assertNotNull(redPacket)
    
    if (redPacket !== null) {
      assert.i32Equals(redPacket.claimedCount, 1)
      assert.bigIntEquals(redPacket.balance, BigInt.fromString("400000000000000000"))
      assert.booleanEquals(redPacket.isActive, true) // 还有1份没领取
    }

    // 验证领取记录
    let claimId = "1-" + claimer.toHex()
    let claim = Claim.load(claimId)
    assert.assertNotNull(claim)
    
    if (claim !== null) {
      assert.stringEquals(claim.redPacket, "1")
      assert.bytesEquals(claim.claimer, claimer)
      assert.bigIntEquals(claim.amount, claimAmount)
      assert.i32Equals(claim.claimIndex, 1)
    }
  })

  test("Should mark red packet as inactive when fully claimed", () => {
    // 创建只有1份的红包
    let packetId = BigInt.fromI32(1)
    let creator = Address.fromString("0x1234567890123456789012345678901234567890")
    let claimer = Address.fromString("0x0987654321098765432109876543210987654321")
    
    let createEvent = createPacketCreatedEvent(
      packetId,
      creator,
      "Single packet",
      BigInt.fromString("1000000000000000000"),
      BigInt.fromI32(1),
      true
    )
    handlePacketCreated(createEvent)

    // 领取这唯一的红包
    let claimEvent = createPacketClaimedEvent(
      packetId, 
      claimer, 
      BigInt.fromString("1000000000000000000")
    )
    handlePacketClaimed(claimEvent)

    // 验证红包变为非活跃状态
    let redPacket = RedPacket.load("1")
    assert.assertNotNull(redPacket)
    
    if (redPacket !== null) {
      assert.i32Equals(redPacket.claimedCount, 1)
      assert.bigIntEquals(redPacket.balance, BigInt.fromI32(0))
      assert.booleanEquals(redPacket.isActive, false)
      assert.stringEquals(redPacket.completionRate.toString(), "1")
    }
  })
})
```

### 2. 运行测试

```bash
# 生成类型文件
npm run codegen

# 运行测试
graph test
```

## 🚀 部署与发布

### 1. 准备部署

```bash
# 生成类型和构建
npm run codegen
npm run build
```

### 2. 部署到 Graph Studio

```bash
# 首先需要在 https://thegraph.com/studio/ 创建子图

# 授权（需要从Studio获取访问令牌）
graph auth --studio YOUR_ACCESS_TOKEN

# 部署
npm run deploy
```

### 3. 版本管理

**部署多个版本**:
```bash
# 部署到不同标签
graph deploy --studio red-packet-subgraph --version-label v1.0.0
graph deploy --studio red-packet-subgraph --version-label v1.0.1
```

### 4. 监控与维护

**检查同步状态**:
```bash
# 通过GraphQL查询子图状态
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"query": "{ _meta { block { number } } }"}' \
  https://api.studio.thegraph.com/query/your-subgraph-id/your-subgraph-name/version/latest
```

## 📊 常用查询示例

### 1. 基础查询

```graphql
# 获取最新的20个红包
query GetRecentPackets {
  redPackets(
    first: 20
    orderBy: creationTime
    orderDirection: desc
  ) {
    id
    creator
    message
    totalAmount
    totalCount
    claimedCount
    isEven
    isActive
    creationTime
    claims {
      claimer
      amount
      timestamp
    }
  }
}

# 获取用户创建的红包
query GetUserPackets($creator: Bytes!) {
  redPackets(
    where: { creator: $creator }
    orderBy: creationTime
    orderDirection: desc
  ) {
    id
    message
    totalAmount
    totalCount
    claimedCount
    isActive
    completionRate
  }
}

# 获取用户的领取记录
query GetUserClaims($claimer: Bytes!) {
  claims(
    where: { claimer: $claimer }
    orderBy: timestamp
    orderDirection: desc
  ) {
    id
    redPacket {
      id
      message
      creator
    }
    amount
    timestamp
    claimIndex
  }
}
```

### 2. 统计查询

```graphql
# 获取全局统计
query GetGlobalStats {
  globalStats(id: "global") {
    totalPackets
    totalAmount
    totalClaims
    activePackets
    totalUsers
    lastUpdated
  }
}

# 获取每日统计
query GetDayStats($startDate: String!, $endDate: String!) {
  dayStats(
    where: {
      id_gte: $startDate
      id_lte: $endDate
    }
    orderBy: date
    orderDirection: asc
  ) {
    id
    date
    packetsCreated
    packetsClaimed
    amountCreated
    amountClaimed
    activeUsers
  }
}

# 获取用户统计
query GetUserStats($userId: ID!) {
  user(id: $userId) {
    address
    createdPacketsCount
    totalAmountCreated
    claimedPacketsCount
    totalAmountClaimed
    firstActivity
    lastActivity
  }
}
```

### 3. 复杂查询

```graphql
# 获取活跃红包（可领取的）
query GetActivePackets($first: Int = 10) {
  redPackets(
    where: { isActive: true }
    first: $first
    orderBy: creationTime
    orderDirection: desc
  ) {
    id
    creator
    message
    totalAmount
    balance
    totalCount
    claimedCount
    averageAmount
    completionRate
  }
}

# 获取大额红包（总金额大于1 ETH）
query GetLargePackets {
  redPackets(
    where: { totalAmount_gte: "1000000000000000000" }
    orderBy: totalAmount
    orderDirection: desc
  ) {
    id
    creator
    message
    totalAmount
    totalCount
    isEven
    creationTime
  }
}

# 获取红包详情和所有领取记录
query GetPacketDetails($packetId: ID!) {
  redPacket(id: $packetId) {
    id
    creator
    message
    totalAmount
    balance
    totalCount
    claimedCount
    isEven
    isActive
    creationTime
    completionRate
    claims(orderBy: timestamp, orderDirection: asc) {
      claimer
      amount
      timestamp
      claimIndex
      transactionHash
    }
  }
}
```

## 🛠️ 调试与优化

### 1. 调试技巧

**日志调试**:
```typescript
import { log } from "@graphprotocol/graph-ts"

export function handlePacketCreated(event: PacketCreated): void {
  log.info("Processing PacketCreated event for packet {}", [event.params.packetId.toString()])
  
  // 处理逻辑...
  
  log.info("Successfully processed packet {} with amount {}", [
    event.params.packetId.toString(),
    event.params.totalAmount.toString()
  ])
}
```

**错误处理**:
```typescript
export function handlePacketClaimed(event: PacketClaimed): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    log.error("RedPacket with id {} not found", [event.params.packetId.toString()])
    return  // 优雅处理错误，不要让子图失败
  }

  // 继续处理...
}
```

### 2. 性能优化

**批量操作**:
```typescript
// 避免在循环中多次保存同一个实体
let user = getOrCreateUser(event.params.creator)
user.createdPacketsCount = user.createdPacketsCount + 1
user.totalAmountCreated = user.totalAmountCreated.plus(event.params.totalAmount)
user.lastActivity = event.block.timestamp
user.save() // 只保存一次
```

**合理的实体关系**:
```typescript
// 使用 @derivedFrom 避免手动维护双向关系
// 在 schema.graphql 中：
# claims: [Claim!]! @derivedFrom(field: "redPacket")
```

### 3. 监控指标

**监控子图健康状态**:
```typescript
// 在映射中添加健康检查
let globalStats = getOrCreateGlobalStats()
globalStats.lastUpdated = event.block.timestamp

// 如果长时间没有更新，说明可能有问题
if (event.block.timestamp.gt(globalStats.lastUpdated.plus(BigInt.fromI32(3600)))) {
  log.warning("Subgraph might be lagging, last update was {} seconds ago", [
    event.block.timestamp.minus(globalStats.lastUpdated).toString()
  ])
}
```

## 📚 最佳实践总结

### 1. 数据模型设计
- **实体关系清晰**: 合理设计一对多、多对多关系
- **字段类型选择**: 使用合适的数据类型（BigInt for wei amounts）
- **索引策略**: 经常查询的字段添加索引
- **计算字段**: 在映射中计算常用的派生字段

### 2. 映射逻辑
- **错误处理**: 优雅处理空值和异常情况
- **性能优化**: 避免不必要的实体加载和保存
- **日志记录**: 合理添加日志用于调试
- **版本兼容**: 考虑合约升级和数据迁移

### 3. 测试策略
- **单元测试**: 测试每个事件处理函数
- **集成测试**: 测试完整的业务流程
- **边界测试**: 测试极端情况和错误处理
- **性能测试**: 确保大量数据下的性能

### 4. 部署运维
- **版本管理**: 使用语义版本号管理子图版本
- **监控告警**: 监控同步状态和查询性能
- **备份策略**: 重要数据的备份和恢复
- **文档维护**: 保持查询文档和API文档最新

通过这套完整的Subgraph开发指南，我们构建了一个高效、可靠、可扩展的数据索引系统，为红包DApp提供了强大的数据支持，显著提升了用户体验和应用性能。