# 📊 The Graph 子图开发实战教程

> **手把手教你构建高性能的区块链数据索引系统**

## 🎯 学习目标

通过这个教程，你将学会：
- ✅ 理解 The Graph 协议和子图的工作原理
- ✅ 从零开始搭建子图开发环境
- ✅ 设计高效的数据模型和关系
- ✅ 编写复杂的事件处理逻辑
- ✅ 测试、部署和优化子图性能
- ✅ 在前端应用中集成GraphQL查询

## 📚 前置知识

### 必须掌握：
- TypeScript基础语法
- 区块链和智能合约基本概念
- GraphQL基础知识
- 命令行操作

### 建议了解：
- 智能合约事件机制
- 数据库设计原理
- 前端数据查询优化

---

## 🧠 第一步：理解子图核心概念

### The Graph 生态系统架构

```
📈 完整数据流程图：

区块链网络 (Sepolia)
    │ 智能合约发出事件
    ▼
📡 Graph节点 (索引器)
    │ 监听和收集事件
    │ 按照mapping.ts处理数据
    │ 存储到PostgreSQL
    ▼  
🗃️ 索引数据库
    │ 结构化存储
    │ 支持复杂查询
    ▼
🌐 GraphQL API
    │ 提供统一查询接口
    │ 支持分页、排序、过滤
    ▼
🖥️ 前端应用
    │ Apollo Client查询
    │ 实时数据展示
    │ 用户交互
```

### 为什么子图比直接查询RPC更好？

**性能对比实例**：

```typescript
// ❌ 传统RPC方式 - 查询所有红包
async function getRedPacketsTraditional() {
  // 1. 获取合约所有事件 (需要扫描所有区块)
  const events = await contract.queryFilter('PacketCreated', 0, 'latest')
  // 🐌 可能需要几十秒，随着区块增加会越来越慢
  
  // 2. 手动处理每个事件
  const packets = []
  for (const event of events) {
    // 3. 对每个红包查询详细信息 (N次RPC调用)
    const packetInfo = await contract.packets(event.args.packetId)
    packets.push({ ...event.args, ...packetInfo })
  }
  
  // 4. 手动排序和分页
  return packets.sort((a, b) => b.creationTime - a.creationTime).slice(0, 10)
}

// ✅ 子图方式 - 同样的查询
const GET_RED_PACKETS = gql`
  query GetRedPackets($first: Int = 10, $orderBy: RedPacket_orderBy = creationTime) {
    redPackets(first: $first, orderBy: $orderBy, orderDirection: desc) {
      id
      creator
      message
      totalAmount
      balance
      totalCount
      claimedCount
      creationTime
    }
  }
`
// ⚡ 通常在100-300ms内完成，性能稳定
```

### 红包系统数据需求分析

**核心业务查询场景**：

1. **首页红包列表** 📋
   ```graphql
   # 需求：按时间倒序显示最新红包，支持分页
   query RecentRedPackets {
     redPackets(first: 20, orderBy: creationTime, orderDirection: desc) {
       id, creator, message, totalAmount, claimedCount, totalCount
     }
   }
   ```

2. **用户个人中心** 👤
   ```graphql
   # 需求：用户创建的红包 + 领取记录
   query UserActivity($user: Bytes!) {
     redPackets(where: {creator: $user}) { ... }
     claims(where: {claimer: $user}) { ... }
   }
   ```

3. **红包详情页** 🎁
   ```graphql
   # 需求：红包详情 + 所有领取记录
   query RedPacketDetail($id: ID!) {
     redPacket(id: $id) { ... }
     claims(where: {redPacket: $id}) { claimer, amount, timestamp }
   }
   ```

4. **统计仪表盘** 📊
   ```graphql
   # 需求：平台统计数据
   query PlatformStats {
     redPacketStats { totalPackets, totalAmount, totalClaims }
   }
   ```

---

## 🚀 第二步：环境搭建实战

### 1. 安装开发工具

```bash
# 1. 安装Graph CLI (全局安装)
npm install -g @graphprotocol/graph-cli@latest

# 2. 验证安装
graph --version
# 应该显示类似：@graphprotocol/graph-cli/0.61.0

# 3. 安装开发依赖
npm install -g typescript ts-node

# 4. 检查Node.js版本 (需要>=16)
node --version
```

### 2. 创建The Graph Studio项目

**Step 1: 访问The Graph Studio**
1. 打开 https://thegraph.com/studio/
2. 连接你的钱包 (MetaMask)
3. 点击 "Create a Subgraph"
4. 输入项目名称：`red-packet-subgraph`
5. 复制生成的部署密钥

**Step 2: 初始化本地项目**

```bash
# 创建项目目录
mkdir red-packet-subgraph
cd red-packet-subgraph

# 方法1: 使用CLI初始化 (推荐新手)
graph init --studio red-packet-subgraph

# 按提示填写信息：
# Protocol: ethereum
# Subgraph slug: red-packet-subgraph  
# Directory: red-packet-subgraph
# Ethereum network: sepolia
# Contract address: 0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f
# Contract Name: RedPacketSystem

# 方法2: 手动创建 (更灵活)
npm init -y
npm install --save-dev @graphprotocol/graph-cli @graphprotocol/graph-ts
```

### 3. 项目结构详解

```bash
# 查看生成的项目结构
tree red-packet-subgraph

# 应该看到：
red-packet-subgraph/
├── 📄 schema.graphql          # 数据模型定义 (最重要!)
├── 📄 subgraph.yaml          # 配置文件 (合约地址、事件等)
├── 📁 src/
│   └── 📄 red-packet-system.ts  # 事件处理逻辑 (核心代码)
├── 📁 generated/             # 自动生成的类型文件 (不要手动编辑)
├── 📁 build/                # 构建输出 (部署文件)
├── 📁 tests/                # 测试文件
├── 📄 package.json          # 依赖配置
├── 📄 tsconfig.json         # TypeScript配置
└── 📄 .gitignore           # Git忽略文件
```

### 4. 核心配置文件设置

**修改 `package.json`**:

```json
{
  "name": "red-packet-subgraph",
  "version": "0.1.0",
  "description": "High-performance subgraph for Red Packet DApp with advanced querying capabilities",
  "repository": {
    "type": "git",
    "url": "https://github.com/your-username/red-packet-dapp"
  },
  "scripts": {
    "codegen": "graph codegen",
    "build": "graph build",
    "test": "graph test",
    "deploy": "graph deploy --studio red-packet-subgraph",
    "create-local": "graph create --node http://localhost:8020/ red-packet-subgraph",
    "deploy-local": "graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 red-packet-subgraph",
    "clean": "rm -rf build/ generated/",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write \"**/*.{ts,js,json,md}\""
  },
  "devDependencies": {
    "@graphprotocol/graph-cli": "^0.61.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.5.0",
    "typescript": "^5.0.0",
    "prettier": "^3.0.0",
    "eslint": "^8.0.0"
  }
}
```

**验证环境设置**:

```bash
# 1. 安装依赖
npm install

# 2. 测试代码生成
npm run codegen
# 应该看到: ✓ Generate types for data source template

# 3. 测试构建
npm run build  
# 应该看到: ✓ Build completed

echo "🎉 环境搭建成功！"
```

---

## 💡 第三步：数据模型设计实战

### 1. 高级Schema设计

**创建 `schema.graphql`** (完整版本):

```graphql
"""
红包实体 - 核心数据模型
包含所有红包的基本信息和计算字段
"""
type RedPacket @entity {
  "红包唯一标识 (packetId)"
  id: ID!
  
  "创建者地址"
  creator: Bytes!
  
  "祝福语内容"
  message: String!
  
  "红包总金额 (wei)"
  totalAmount: BigInt!
  
  "剩余金额 (wei)"  
  balance: BigInt!
  
  "总份数"
  totalCount: BigInt!
  
  "已领取份数"
  claimedCount: BigInt!
  
  "是否均分模式"
  isEven: Boolean!
  
  "创建时间戳"
  creationTime: BigInt!
  
  "创建交易哈希"
  creationTxHash: Bytes!
  
  "创建区块号"
  creationBlock: BigInt!
  
  # === 关联字段 ===
  "所有领取记录"
  claims: [Claim!]! @derivedFrom(field: "redPacket")
  
  # === 计算字段 (在mapping中计算) ===
  "是否已过期 (24小时)"
  isExpired: Boolean!
  
  "是否已领完"
  isFullyClaimed: Boolean!
  
  "是否可以提取 (创建者 + 已过期 + 有余额)"
  canWithdraw: Boolean!
  
  "平均金额 (wei)"
  averageAmount: BigInt!
  
  "领取进度百分比 (0-100)"
  progressPercentage: Int!
  
  "状态: ACTIVE, EXPIRED, COMPLETED"
  status: PacketStatus!
  
  # === 统计字段 ===
  "已领取金额"
  claimedAmount: BigInt!
  
  "最后更新时间"
  lastUpdateTime: BigInt!
  
  "最后更新区块"
  lastUpdateBlock: BigInt!
}

"""
领取记录实体 - 每次抢红包的详细记录
"""
type Claim @entity {
  "领取记录唯一标识 (packetId-claimer)"
  id: ID!
  
  "关联的红包"
  redPacket: RedPacket!
  
  "领取者地址" 
  claimer: Bytes!
  
  "领取金额 (wei)"
  amount: BigInt!
  
  "领取时间戳"
  timestamp: BigInt!
  
  "交易哈希"
  transactionHash: Bytes!
  
  "区块号"
  blockNumber: BigInt!
  
  "Gas消耗"
  gasUsed: BigInt!
  
  "领取顺序 (第几个领取)"
  claimOrder: Int!
}

"""
用户统计实体 - 每个用户的活动统计
自动聚合用户的创建和领取数据
"""
type UserStats @entity {
  "用户地址"
  id: ID!
  
  # === 创建统计 ===
  "创建的红包数量"
  packetsCreated: Int!
  
  "创建的红包总金额"
  totalAmountSent: BigInt!
  
  "平均红包金额"
  averagePacketAmount: BigInt!
  
  # === 领取统计 ===  
  "领取的红包数量"
  packetsClaimed: Int!
  
  "领取的总金额"
  totalAmountReceived: BigInt!
  
  "平均领取金额"
  averageClaimAmount: BigInt!
  
  # === 时间统计 ===
  "首次活动时间"
  firstActivityTime: BigInt!
  
  "最后活动时间"
  lastActivityTime: BigInt!
  
  # === 成功率统计 ===
  "参与的红包数(尝试领取)"
  packetsParticipated: Int!
  
  "成功率 (claimed/participated * 100)"
  successRate: Int!
}

"""
每日统计实体 - 平台每日活动数据
用于仪表盘展示和趋势分析
"""
type DailyStats @entity {
  "日期 (YYYY-MM-DD)"
  id: ID!
  
  "当日创建红包数"
  packetsCreated: Int!
  
  "当日领取次数"  
  claimsCount: Int!
  
  "当日活跃用户数"
  activeUsers: Int!
  
  "当日总交易金额"
  totalVolume: BigInt!
  
  "当日平均红包金额"
  averagePacketAmount: BigInt!
  
  "日期时间戳"
  date: BigInt!
}

"""
全局统计实体 - 平台整体数据
单例实体，ID固定为"global"
"""
type GlobalStats @entity {
  "固定ID: global"
  id: ID!
  
  # === 总体统计 ===
  "总红包数量"
  totalPackets: Int!
  
  "总领取次数"
  totalClaims: Int!
  
  "独立用户数"
  uniqueUsers: Int!
  
  "总交易金额"
  totalVolume: BigInt!
  
  # === 当前状态 ===
  "活跃红包数 (未完成)"
  activePackets: Int!
  
  "总剩余金额"
  totalBalance: BigInt!
  
  # === 更新信息 ===
  "最后更新时间"
  lastUpdateTime: BigInt!
  
  "最后处理的区块"
  lastProcessedBlock: BigInt!
}

"""
资金提取记录 - 24小时后提取未领取资金
"""
type Withdrawal @entity {
  "提取记录ID (packetId-txHash)"
  id: ID!
  
  "关联的红包"
  redPacket: RedPacket!
  
  "提取者 (红包创建者)"
  withdrawer: Bytes!
  
  "提取金额"
  amount: BigInt!
  
  "提取时间"
  timestamp: BigInt!
  
  "交易哈希"
  transactionHash: Bytes!
  
  "区块号"
  blockNumber: BigInt!
}

"""
红包状态枚举
"""
enum PacketStatus {
  "活跃状态 - 可以领取"
  ACTIVE
  
  "已过期 - 24小时后未领完"
  EXPIRED
  
  "已完成 - 全部领取完毕"
  COMPLETED
  
  "已提取 - 创建者已提取剩余资金"
  WITHDRAWN
}
```

### 2. 数据模型设计原理

**关系设计说明**：

```typescript
// 一对多关系：一个红包对应多个领取记录
RedPacket ←1--n→ Claim

// 聚合关系：用户统计聚合多个红包和领取记录  
User ←1--n→ RedPacket (created)
User ←1--n→ Claim (claimed)

// 时间序列：每日统计按日期聚合
Date ←1--1→ DailyStats

// 全局单例：整个平台的统计信息
Global ←1--1→ GlobalStats
```

**索引优化策略**：

```graphql
# 自动创建的索引字段：
# - 所有 @entity 的 id 字段
# - 所有带 @derivedFrom 的关联字段  
# - 枚举类型字段

# 查询优化考虑：
# 1. 经常作为 where 条件的字段
# 2. 需要排序的字段 (creationTime)
# 3. 关联查询的外键字段
```

**字段设计原则**：

1. **存储原始数据** + **计算衍生数据**
   ```graphql
   totalAmount: BigInt!      # 原始：合约返回的值
   averageAmount: BigInt!    # 衍生：totalAmount / totalCount  
   ```

2. **时间戳统一使用 BigInt**
   ```graphql
   creationTime: BigInt!     # 秒级时间戳，便于计算和比较
   ```

3. **金额使用 BigInt 保持精度**
   ```graphql
   amount: BigInt!           # wei单位，避免精度丢失
   ```

4. **状态用枚举类型**
   ```graphql
   status: PacketStatus!     # 类型安全，便于过滤
   ```

---

## 🔥 第四步：事件处理逻辑实战

### 1. 配置子图文件

**修改 `subgraph.yaml`**:

```yaml
specVersion: 0.0.5
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: RedPacketSystem
    network: sepolia
    source:
      address: "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"
      abi: RedPacketSystem
      # 起始区块号 - 合约部署的区块
      startBlock: 4680000
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      entities:
        - RedPacket
        - Claim  
        - UserStats
        - DailyStats
        - GlobalStats
        - Withdrawal
      abis:
        - name: RedPacketSystem
          file: ./abis/RedPacketSystem.json
      eventHandlers:
        - event: PacketCreated(indexed uint256,indexed address,string,uint256,uint256,bool)
          handler: handlePacketCreated
        - event: PacketClaimed(indexed uint256,indexed address,uint256)
          handler: handlePacketClaimed
        - event: AlreadyClaimed(indexed uint256,indexed address)
          handler: handleAlreadyClaimed
        - event: FundsWithdrawn(indexed uint256,indexed address,uint256)
          handler: handleFundsWithdrawn
      file: ./src/red-packet-system.ts
```

### 2. 核心映射逻辑实现

**创建 `src/red-packet-system.ts`** (完整版本):

```typescript
import { BigInt, Bytes, log, Address } from '@graphprotocol/graph-ts'
import {
  PacketCreated,
  PacketClaimed, 
  AlreadyClaimed,
  FundsWithdrawn
} from '../generated/RedPacketSystem/RedPacketSystem'
import { 
  RedPacket, 
  Claim, 
  UserStats, 
  DailyStats, 
  GlobalStats,
  Withdrawal 
} from '../generated/schema'

// ===== 工具函数 =====

/**
 * 获取日期ID (YYYY-MM-DD格式)
 */
function getDayId(timestamp: BigInt): string {
  // 将时间戳转换为天数
  const daysSinceEpoch = timestamp.div(BigInt.fromI32(86400))
  return daysSinceEpoch.toString()
}

/**
 * 获取或创建用户统计
 */
function getOrCreateUserStats(address: Bytes): UserStats {
  let userStats = UserStats.load(address.toHexString())
  
  if (userStats == null) {
    userStats = new UserStats(address.toHexString())
    userStats.packetsCreated = 0
    userStats.totalAmountSent = BigInt.fromI32(0)
    userStats.averagePacketAmount = BigInt.fromI32(0)
    userStats.packetsClaimed = 0
    userStats.totalAmountReceived = BigInt.fromI32(0)
    userStats.averageClaimAmount = BigInt.fromI32(0)
    userStats.firstActivityTime = BigInt.fromI32(0)
    userStats.lastActivityTime = BigInt.fromI32(0)
    userStats.packetsParticipated = 0
    userStats.successRate = 0
    
    log.info('[UserStats] 创建新用户统计: {}', [address.toHexString()])
  }
  
  return userStats as UserStats
}

/**
 * 获取或创建每日统计
 */
function getOrCreateDailyStats(timestamp: BigInt): DailyStats {
  const dayId = getDayId(timestamp)
  let dailyStats = DailyStats.load(dayId)
  
  if (dailyStats == null) {
    dailyStats = new DailyStats(dayId)
    dailyStats.packetsCreated = 0
    dailyStats.claimsCount = 0
    dailyStats.activeUsers = 0
    dailyStats.totalVolume = BigInt.fromI32(0)
    dailyStats.averagePacketAmount = BigInt.fromI32(0)
    dailyStats.date = timestamp
    
    log.info('[DailyStats] 创建新日统计: {}', [dayId])
  }
  
  return dailyStats as DailyStats
}

/**
 * 获取或创建全局统计
 */
function getOrCreateGlobalStats(): GlobalStats {
  let globalStats = GlobalStats.load('global')
  
  if (globalStats == null) {
    globalStats = new GlobalStats('global')
    globalStats.totalPackets = 0
    globalStats.totalClaims = 0
    globalStats.uniqueUsers = 0
    globalStats.totalVolume = BigInt.fromI32(0)
    globalStats.activePackets = 0
    globalStats.totalBalance = BigInt.fromI32(0)
    globalStats.lastUpdateTime = BigInt.fromI32(0)
    globalStats.lastProcessedBlock = BigInt.fromI32(0)
    
    log.info('[GlobalStats] 创建全局统计', [])
  }
  
  return globalStats as GlobalStats
}

/**
 * 计算红包状态
 */
function calculatePacketStatus(redPacket: RedPacket, currentTime: BigInt): string {
  const TWENTY_FOUR_HOURS = BigInt.fromI32(24 * 60 * 60) // 24小时秒数
  
  // 检查是否已领完
  if (redPacket.claimedCount >= redPacket.totalCount) {
    return 'COMPLETED'
  }
  
  // 检查是否已过期
  if (currentTime > redPacket.creationTime.plus(TWENTY_FOUR_HOURS)) {
    return 'EXPIRED'
  }
  
  // 默认为活跃状态
  return 'ACTIVE'
}

// ===== 事件处理函数 =====

/**
 * 处理红包创建事件
 */
export function handlePacketCreated(event: PacketCreated): void {
  log.info('[PacketCreated] 开始处理红包创建事件 - ID: {}', [
    event.params.packetId.toString()
  ])

  // === 1. 创建红包实体 ===
  const packetId = event.params.packetId.toString()
  let redPacket = new RedPacket(packetId)
  
  // 基本信息
  redPacket.creator = event.params.creator
  redPacket.message = event.params.message
  redPacket.totalAmount = event.params.totalAmount
  redPacket.balance = event.params.totalAmount
  redPacket.totalCount = event.params.totalCount
  redPacket.claimedCount = BigInt.fromI32(0)
  redPacket.isEven = event.params.isEven
  redPacket.creationTime = event.block.timestamp
  redPacket.creationTxHash = event.transaction.hash
  redPacket.creationBlock = event.block.number
  
  // 计算字段
  redPacket.isExpired = false
  redPacket.isFullyClaimed = false
  redPacket.canWithdraw = false
  redPacket.averageAmount = event.params.totalAmount.div(event.params.totalCount)
  redPacket.progressPercentage = 0
  redPacket.status = 'ACTIVE'
  redPacket.claimedAmount = BigInt.fromI32(0)
  redPacket.lastUpdateTime = event.block.timestamp
  redPacket.lastUpdateBlock = event.block.number
  
  redPacket.save()
  log.info('[PacketCreated] 红包实体已保存', [])

  // === 2. 更新创建者统计 ===
  let creatorStats = getOrCreateUserStats(event.params.creator)
  creatorStats.packetsCreated += 1
  creatorStats.totalAmountSent = creatorStats.totalAmountSent.plus(event.params.totalAmount)
  
  // 计算平均金额
  if (creatorStats.packetsCreated > 0) {
    creatorStats.averagePacketAmount = creatorStats.totalAmountSent
      .div(BigInt.fromI32(creatorStats.packetsCreated))
  }
  
  // 更新活动时间
  if (creatorStats.firstActivityTime == BigInt.fromI32(0)) {
    creatorStats.firstActivityTime = event.block.timestamp
  }
  creatorStats.lastActivityTime = event.block.timestamp
  
  creatorStats.save()
  log.info('[PacketCreated] 创建者统计已更新: {}', [event.params.creator.toHexString()])

  // === 3. 更新每日统计 ===
  let dailyStats = getOrCreateDailyStats(event.block.timestamp)
  dailyStats.packetsCreated += 1
  dailyStats.totalVolume = dailyStats.totalVolume.plus(event.params.totalAmount)
  
  // 计算当日平均金额
  if (dailyStats.packetsCreated > 0) {
    dailyStats.averagePacketAmount = dailyStats.totalVolume
      .div(BigInt.fromI32(dailyStats.packetsCreated))
  }
  
  dailyStats.save()
  log.info('[PacketCreated] 每日统计已更新', [])

  // === 4. 更新全局统计 ===
  let globalStats = getOrCreateGlobalStats()
  globalStats.totalPackets += 1
  globalStats.totalVolume = globalStats.totalVolume.plus(event.params.totalAmount)
  globalStats.activePackets += 1
  globalStats.totalBalance = globalStats.totalBalance.plus(event.params.totalAmount)
  globalStats.lastUpdateTime = event.block.timestamp
  globalStats.lastProcessedBlock = event.block.number
  
  globalStats.save()
  log.info('[PacketCreated] 全局统计已更新', [])
  
  log.info('[PacketCreated] 红包创建事件处理完成', [])
}

/**
 * 处理红包领取事件
 */
export function handlePacketClaimed(event: PacketClaimed): void {
  log.info('[PacketClaimed] 开始处理红包领取事件 - 红包ID: {}, 领取者: {}', [
    event.params.packetId.toString(),
    event.params.claimer.toHexString()
  ])

  const packetId = event.params.packetId.toString()
  
  // === 1. 创建领取记录 ===
  const claimId = packetId + '-' + event.params.claimer.toHexString()
  let claim = new Claim(claimId)
  
  claim.redPacket = packetId
  claim.claimer = event.params.claimer
  claim.amount = event.params.amount
  claim.timestamp = event.block.timestamp
  claim.transactionHash = event.transaction.hash
  claim.blockNumber = event.block.number
  claim.gasUsed = event.transaction.gasUsed
  
  // 需要从红包获取当前领取顺序
  let redPacket = RedPacket.load(packetId)
  if (redPacket != null) {
    claim.claimOrder = redPacket.claimedCount.toI32() + 1
  } else {
    claim.claimOrder = 1
    log.error('[PacketClaimed] 红包不存在: {}', [packetId])
  }
  
  claim.save()
  log.info('[PacketClaimed] 领取记录已保存', [])

  // === 2. 更新红包状态 ===
  if (redPacket != null) {
    redPacket.claimedCount = redPacket.claimedCount.plus(BigInt.fromI32(1))
    redPacket.balance = redPacket.balance.minus(event.params.amount)
    redPacket.claimedAmount = redPacket.claimedAmount.plus(event.params.amount)
    
    // 计算进度百分比
    if (redPacket.totalCount > BigInt.fromI32(0)) {
      redPacket.progressPercentage = redPacket.claimedCount
        .times(BigInt.fromI32(100))
        .div(redPacket.totalCount)
        .toI32()
    }
    
    // 更新状态标志
    redPacket.isFullyClaimed = redPacket.claimedCount >= redPacket.totalCount
    redPacket.status = calculatePacketStatus(redPacket, event.block.timestamp)
    redPacket.lastUpdateTime = event.block.timestamp
    redPacket.lastUpdateBlock = event.block.number
    
    // 如果领完了，更新活跃红包数
    if (redPacket.isFullyClaimed) {
      let globalStats = getOrCreateGlobalStats()
      globalStats.activePackets -= 1
      globalStats.save()
    }
    
    redPacket.save()
    log.info('[PacketClaimed] 红包状态已更新 - 进度: {}%', [
      redPacket.progressPercentage.toString()
    ])
  }

  // === 3. 更新领取者统计 ===
  let claimerStats = getOrCreateUserStats(event.params.claimer)
  claimerStats.packetsClaimed += 1
  claimerStats.totalAmountReceived = claimerStats.totalAmountReceived.plus(event.params.amount)
  
  // 计算平均领取金额
  if (claimerStats.packetsClaimed > 0) {
    claimerStats.averageClaimAmount = claimerStats.totalAmountReceived
      .div(BigInt.fromI32(claimerStats.packetsClaimed))
  }
  
  // 更新活动时间
  if (claimerStats.firstActivityTime == BigInt.fromI32(0)) {
    claimerStats.firstActivityTime = event.block.timestamp
  }
  claimerStats.lastActivityTime = event.block.timestamp
  
  claimerStats.save()
  log.info('[PacketClaimed] 领取者统计已更新: {}', [event.params.claimer.toHexString()])

  // === 4. 更新每日统计 ===
  let dailyStats = getOrCreateDailyStats(event.block.timestamp)
  dailyStats.claimsCount += 1
  dailyStats.save()

  // === 5. 更新全局统计 ===
  let globalStats = getOrCreateGlobalStats()
  globalStats.totalClaims += 1
  globalStats.totalBalance = globalStats.totalBalance.minus(event.params.amount)
  globalStats.lastUpdateTime = event.block.timestamp
  globalStats.lastProcessedBlock = event.block.number
  
  globalStats.save()
  
  log.info('[PacketClaimed] 红包领取事件处理完成', [])
}

/**
 * 处理重复领取事件 (记录但不影响状态)
 */
export function handleAlreadyClaimed(event: AlreadyClaimed): void {
  log.info('[AlreadyClaimed] 用户重复领取红包 - 红包ID: {}, 用户: {}', [
    event.params.packetId.toString(),
    event.params.claimer.toHexString()
  ])
  
  // 这个事件主要用于前端展示，不需要创建实体
  // 但可以用于统计用户的参与次数
  let userStats = getOrCreateUserStats(event.params.claimer)
  userStats.packetsParticipated += 1
  
  // 重新计算成功率
  if (userStats.packetsParticipated > 0) {
    userStats.successRate = (userStats.packetsClaimed * 100) / userStats.packetsParticipated
  }
  
  userStats.save()
}

/**
 * 处理资金提取事件
 */
export function handleFundsWithdrawn(event: FundsWithdrawn): void {
  log.info('[FundsWithdrawn] 开始处理资金提取事件 - 红包ID: {}, 金额: {}', [
    event.params.packetId.toString(),
    event.params.amount.toString()
  ])

  const packetId = event.params.packetId.toString()
  
  // === 1. 创建提取记录 ===
  const withdrawalId = packetId + '-' + event.transaction.hash.toHexString()
  let withdrawal = new Withdrawal(withdrawalId)
  
  withdrawal.redPacket = packetId
  withdrawal.withdrawer = event.params.owner
  withdrawal.amount = event.params.amount
  withdrawal.timestamp = event.block.timestamp
  withdrawal.transactionHash = event.transaction.hash
  withdrawal.blockNumber = event.block.number
  
  withdrawal.save()
  log.info('[FundsWithdrawn] 提取记录已保存', [])

  // === 2. 更新红包状态 ===
  let redPacket = RedPacket.load(packetId)
  if (redPacket != null) {
    redPacket.balance = BigInt.fromI32(0) // 提取后余额为0
    redPacket.status = 'WITHDRAWN'
    redPacket.lastUpdateTime = event.block.timestamp
    redPacket.lastUpdateBlock = event.block.number
    
    redPacket.save()
    log.info('[FundsWithdrawn] 红包状态已更新为WITHDRAWN', [])
  }

  // === 3. 更新全局统计 ===
  let globalStats = getOrCreateGlobalStats()
  globalStats.activePackets -= 1 // 减少活跃红包数
  globalStats.totalBalance = globalStats.totalBalance.minus(event.params.amount)
  globalStats.lastUpdateTime = event.block.timestamp
  globalStats.lastProcessedBlock = event.block.number
  
  globalStats.save()
  
  log.info('[FundsWithdrawn] 资金提取事件处理完成', [])
}
```

### 3. 高级映射技巧

**处理复杂计算**：

```typescript
// 计算时间相关字段
function updateTimeBasedFields(entity: RedPacket, currentTime: BigInt): void {
  const TWENTY_FOUR_HOURS = BigInt.fromI32(24 * 60 * 60)
  const timeSinceCreation = currentTime.minus(entity.creationTime)
  
  entity.isExpired = timeSinceCreation >= TWENTY_FOUR_HOURS
  entity.canWithdraw = entity.isExpired && 
                      entity.balance > BigInt.fromI32(0) &&
                      !entity.isFullyClaimed
}

// 批量更新相关实体
function updateRelatedEntities(packetId: string): void {
  // 更新所有相关的聚合统计
  // 这种模式用于复杂的数据一致性保证
}
```

**错误处理和日志**：

```typescript
export function handlePacketCreated(event: PacketCreated): void {
  try {
    // 核心逻辑
    let redPacket = new RedPacket(event.params.packetId.toString())
    // ...处理逻辑
    
    log.info('[PacketCreated] 处理成功 - ID: {}', [
      event.params.packetId.toString()
    ])
  } catch (error) {
    log.error('[PacketCreated] 处理失败: {} - 错误: {}', [
      event.params.packetId.toString(),
      error.message
    ])
    // 可以选择创建一个错误记录实体
  }
}
```

---

## 🧪 第五步：测试与部署实战

### 1. 本地测试

**运行代码生成和构建**:

```bash
# 1. 清理旧文件
npm run clean

# 2. 生成类型文件
npm run codegen
# 检查 generated/ 目录是否生成了类型文件

# 3. 构建子图
npm run build
# 检查 build/ 目录是否生成了部署文件

# 4. 运行测试 (如果有)
npm run test
```

### 2. 部署到Graph Studio

```bash
# 1. 认证到Graph Studio (使用你的部署密钥)
graph auth --studio YOUR_DEPLOY_KEY

# 2. 部署子图
npm run deploy

# 等待部署完成...
# ✅ 部署成功后会得到查询端点
```

### 3. 验证部署

**测试GraphQL查询**:

```graphql
# 在Graph Studio playground中测试
query TestBasicQuery {
  redPackets(first: 5, orderBy: creationTime, orderDirection: desc) {
    id
    creator
    message
    totalAmount
    balance
    status
    creationTime
  }
}

query TestUserStats {
  userStats(first: 10, orderBy: packetsCreated, orderDirection: desc) {
    id
    packetsCreated
    totalAmountSent
    packetsClaimed
    totalAmountReceived
  }
}

query TestGlobalStats {
  globalStats(id: "global") {
    totalPackets
    totalClaims
    totalVolume
    activePackets
  }
}
```

**性能监控查询**:

```graphql
query PerformanceTest {
  # 测试复杂关联查询
  redPackets(first: 10) {
    id
    creator
    message
    claims(first: 5) {
      claimer
      amount
      timestamp
    }
  }
}
```

---

## 🚀 第六步：前端集成实战

### 前端GraphQL查询示例

```typescript
// 1. 红包列表查询
export const GET_RED_PACKETS = gql`
  query GetRedPackets(
    $first: Int = 20
    $skip: Int = 0
    $orderBy: RedPacket_orderBy = creationTime
    $orderDirection: OrderDirection = desc
    $where: RedPacket_filter
  ) {
    redPackets(
      first: $first
      skip: $skip
      orderBy: $orderBy
      orderDirection: $orderDirection
      where: $where
    ) {
      id
      creator
      message
      totalAmount
      balance
      totalCount
      claimedCount
      isEven
      status
      progressPercentage
      creationTime
      isExpired
      canWithdraw
    }
  }
`

// 2. 用户活动查询
export const GET_USER_ACTIVITY = gql`
  query GetUserActivity($user: Bytes!) {
    # 用户创建的红包
    createdPackets: redPackets(
      where: { creator: $user }
      orderBy: creationTime
      orderDirection: desc
    ) {
      id
      message
      totalAmount
      claimedCount
      totalCount
      status
      creationTime
    }
    
    # 用户的领取记录
    claims(
      where: { claimer: $user }
      orderBy: timestamp
      orderDirection: desc
    ) {
      id
      redPacket {
        id
        creator
        message
      }
      amount
      timestamp
    }
    
    # 用户统计
    userStats(id: $user) {
      packetsCreated
      totalAmountSent
      packetsClaimed  
      totalAmountReceived
      successRate
    }
  }
`

// 3. 平台统计查询
export const GET_PLATFORM_STATS = gql`
  query GetPlatformStats {
    globalStats(id: "global") {
      totalPackets
      totalClaims
      uniqueUsers
      totalVolume
      activePackets
      totalBalance
    }
    
    # 最近7天的数据
    recentDailyStats: dailyStats(
      first: 7
      orderBy: date
      orderDirection: desc
    ) {
      id
      packetsCreated
      claimsCount
      activeUsers
      totalVolume
      date
    }
  }
`
```

## 📚 知识总结

### 你已经掌握的核心技能

1. **子图架构设计**:
   - 复杂数据模型设计
   - 实体关系和索引优化
   - 聚合统计和计算字段

2. **高效事件处理**:
   - AssemblyScript编程
   - 事件监听和数据转换
   - 错误处理和日志记录

3. **性能优化技巧**:
   - 查询优化策略
   - 数据预计算
   - 批量操作处理

4. **部署和维护**:
   - Graph Studio集成
   - 版本管理和更新
   - 监控和故障排除

**恭喜！你已经完成了高性能子图开发的完整学习！** 🎉

现在你可以：
- 设计复杂的数据模型和关系
- 编写高效的事件处理逻辑  
- 部署和维护生产级子图
- 优化查询性能和用户体验

继续实践，成为 The Graph 开发专家！ 🚀

```bash
# 全局安装 Graph CLI
npm install -g @graphprotocol/graph-cli

# 验证安装
graph --version
```

### 2. 初始化 Subgraph 项目

```bash
# 创建项目目录
mkdir red-packet-subgraph
cd red-packet-subgraph

# 初始化 subgraph
graph init \
  --studio \
  red-packet-subgraph \
  --from-contract 0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f \
  --network sepolia \
  --contract-name RedPacketSystem

# 或者从现有目录初始化
graph init --from-contract 0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f --network sepolia
```

### 3. 项目结构解析

```
red-packet-subgraph/
├── schema.graphql         # 数据模型定义
├── subgraph.yaml         # 子图配置文件
├── src/
│   └── mapping.ts        # 事件处理逻辑
├── generated/            # 自动生成的类型文件
├── build/               # 构建输出
├── package.json
└── README.md
```

### 4. 核心配置文件

**package.json**:
```json
{
  "name": "red-packet-subgraph",
  "version": "0.1.0",
  "description": "Subgraph for Red Packet DApp",
  "scripts": {
    "codegen": "graph codegen",
    "build": "graph build",
    "deploy": "graph deploy --studio red-packet-subgraph",
    "create-local": "graph create --node http://localhost:8020/ red-packet-subgraph",
    "remove-local": "graph remove --node http://localhost:8020/ red-packet-subgraph",
    "deploy-local": "graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 red-packet-subgraph",
    "test": "graph test"
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.69.0",
    "@graphprotocol/graph-ts": "^0.34.0"
  }
}
```

## 💡 数据模型设计

### 1. GraphQL Schema 设计

**schema.graphql**:
```graphql
# 红包实体
type RedPacket @entity {
  id: ID!                           # 红包ID
  creator: Bytes!                   # 创建者地址
  message: String!                  # 祝福语
  totalAmount: BigInt!              # 总金额（wei）
  balance: BigInt!                  # 剩余金额（wei）  
  totalCount: Int!                  # 总份数
  claimedCount: Int!                # 已领取份数
  isEven: Boolean!                  # 是否均分模式
  creationTime: BigInt!             # 创建时间戳
  blockNumber: BigInt!              # 创建区块号
  transactionHash: Bytes!           # 交易哈希
  
  # 关联关系
  claims: [Claim!]! @derivedFrom(field: "redPacket")  # 所有领取记录
  
  # 计算字段（在mapping中计算）
  isActive: Boolean!                # 是否仍可领取
  averageAmount: BigInt!            # 平均金额
  completionRate: BigDecimal!       # 完成率 (0-1)
}

# 领取记录实体
type Claim @entity {
  id: ID!                          # 领取记录ID (packetId-claimer)
  redPacket: RedPacket!            # 关联的红包
  claimer: Bytes!                  # 领取者地址
  amount: BigInt!                  # 领取金额（wei）
  timestamp: BigInt!               # 领取时间戳
  blockNumber: BigInt!             # 领取区块号
  transactionHash: Bytes!          # 交易哈希
  claimIndex: Int!                 # 领取序号（第几个领取）
}

# 用户统计实体
type User @entity {
  id: ID!                          # 用户地址
  address: Bytes!                  # 用户地址
  
  # 创建统计
  createdPacketsCount: Int!        # 创建红包数量
  totalAmountCreated: BigInt!      # 创建红包总金额
  createdPackets: [RedPacket!]! @derivedFrom(field: "creator")
  
  # 领取统计
  claimedPacketsCount: Int!        # 领取红包数量
  totalAmountClaimed: BigInt!      # 领取红包总金额
  claims: [Claim!]! @derivedFrom(field: "claimer")
  
  # 时间统计
  firstActivity: BigInt!           # 首次活动时间
  lastActivity: BigInt!            # 最后活动时间
}

# 全局统计实体
type GlobalStats @entity {
  id: ID!                          # 固定为 "global"
  totalPackets: Int!               # 总红包数量
  totalAmount: BigInt!             # 总金额
  totalClaims: Int!                # 总领取次数
  activePackets: Int!              # 活跃红包数量
  totalUsers: Int!                 # 总用户数
  lastUpdated: BigInt!             # 最后更新时间
}

# 每日统计实体
type DayStats @entity {
  id: ID!                          # 格式: "YYYY-MM-DD"
  date: Int!                       # 日期戳
  packetsCreated: Int!             # 当日创建红包数
  packetsClaimed: Int!             # 当日领取红包数  
  amountCreated: BigInt!           # 当日创建金额
  amountClaimed: BigInt!           # 当日领取金额
  activeUsers: Int!                # 当日活跃用户数
}
```

### 2. 数据模型设计原则

1. **实体关系设计**
   - `RedPacket` ↔ `Claim`: 一对多关系
   - `User` ↔ `RedPacket`: 一对多关系（创建者）
   - `User` ↔ `Claim`: 一对多关系（领取者）

2. **索引优化**
   - 经常查询的字段设为索引
   - 时间字段用于排序和过滤
   - 关联字段提升查询性能

3. **计算字段**
   - 实时计算的状态字段
   - 聚合统计数据
   - 便于前端直接使用

## 🔧 事件处理逻辑实现

### 1. Subgraph 配置

**subgraph.yaml**:
```yaml
specVersion: 1.0.0
indexerHints:
  prune: auto
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: RedPacketSystem
    network: sepolia
    source:
      address: "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"
      abi: RedPacketSystem
      startBlock: 4800000  # 合约部署的区块号
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      entities:
        - RedPacket
        - Claim
        - User
        - GlobalStats
        - DayStats
      abis:
        - name: RedPacketSystem
          file: ./abis/RedPacketSystem.json
      eventHandlers:
        - event: PacketCreated(indexed uint256,indexed address,string,uint256,uint256,bool)
          handler: handlePacketCreated
        - event: PacketClaimed(indexed uint256,indexed address,uint256)
          handler: handlePacketClaimed
        - event: PacketEmpty(indexed uint256)
          handler: handlePacketEmpty
        - event: FundsWithdrawn(indexed uint256,indexed address,uint256)
          handler: handleFundsWithdrawn
      file: ./src/mapping.ts
```

### 2. 映射逻辑实现

**src/mapping.ts**:
```typescript
import {
  PacketCreated,
  PacketClaimed,
  PacketEmpty,
  FundsWithdrawn
} from "../generated/RedPacketSystem/RedPacketSystem"

import {
  RedPacket,
  Claim,
  User,
  GlobalStats,
  DayStats
} from "../generated/schema"

import {
  BigInt,
  BigDecimal,
  Address,
  Bytes
} from "@graphprotocol/graph-ts"

// 常量定义
const GLOBAL_STATS_ID = "global"
const ZERO_BI = BigInt.fromI32(0)
const ONE_BI = BigInt.fromI32(1)

// 工具函数：获取或创建用户实体
function getOrCreateUser(address: Address): User {
  let user = User.load(address.toHex())
  
  if (user === null) {
    user = new User(address.toHex())
    user.address = address
    user.createdPacketsCount = 0
    user.totalAmountCreated = ZERO_BI
    user.claimedPacketsCount = 0
    user.totalAmountClaimed = ZERO_BI
    user.firstActivity = ZERO_BI
    user.lastActivity = ZERO_BI
    user.save()
    
    // 更新全局用户统计
    updateGlobalUserCount()
  }
  
  return user
}

// 工具函数：获取或创建全局统计
function getOrCreateGlobalStats(): GlobalStats {
  let stats = GlobalStats.load(GLOBAL_STATS_ID)
  
  if (stats === null) {
    stats = new GlobalStats(GLOBAL_STATS_ID)
    stats.totalPackets = 0
    stats.totalAmount = ZERO_BI
    stats.totalClaims = 0
    stats.activePackets = 0
    stats.totalUsers = 0
    stats.lastUpdated = ZERO_BI
  }
  
  return stats
}

// 工具函数：获取每日统计ID
function getDayStatsId(timestamp: BigInt): string {
  const date = new Date(timestamp.toI32() * 1000)
  const year = date.getUTCFullYear()
  const month = date.getUTCMonth() + 1
  const day = date.getUTCDate()
  
  const monthStr = month < 10 ? "0" + month.toString() : month.toString()
  const dayStr = day < 10 ? "0" + day.toString() : day.toString()
  
  return year.toString() + "-" + monthStr + "-" + dayStr
}

// 工具函数：获取或创建每日统计
function getOrCreateDayStats(timestamp: BigInt): DayStats {
  const dayStatsId = getDayStatsId(timestamp)
  let dayStats = DayStats.load(dayStatsId)
  
  if (dayStats === null) {
    dayStats = new DayStats(dayStatsId)
    const date = new Date(timestamp.toI32() * 1000)
    dayStats.date = BigInt.fromI32(Math.floor(date.getTime() / 1000 / 86400) * 86400)
    dayStats.packetsCreated = 0
    dayStats.packetsClaimed = 0
    dayStats.amountCreated = ZERO_BI
    dayStats.amountClaimed = ZERO_BI
    dayStats.activeUsers = 0
  }
  
  return dayStats
}

// 工具函数：更新全局用户数量
function updateGlobalUserCount(): void {
  let stats = getOrCreateGlobalStats()
  stats.totalUsers = stats.totalUsers + 1
  stats.save()
}

// 工具函数：计算完成率
function calculateCompletionRate(claimedCount: i32, totalCount: i32): BigDecimal {
  if (totalCount === 0) {
    return BigDecimal.fromString("0")
  }
  return BigDecimal.fromString(claimedCount.toString()).div(BigDecimal.fromString(totalCount.toString()))
}

// 事件处理器：红包创建
export function handlePacketCreated(event: PacketCreated): void {
  // 创建红包实体
  let redPacket = new RedPacket(event.params.packetId.toString())
  
  redPacket.creator = event.params.creator
  redPacket.message = event.params.message
  redPacket.totalAmount = event.params.totalAmount
  redPacket.balance = event.params.totalAmount  // 初始余额等于总金额
  redPacket.totalCount = event.params.totalCount.toI32()
  redPacket.claimedCount = 0
  redPacket.isEven = event.params.isEven
  redPacket.creationTime = event.block.timestamp
  redPacket.blockNumber = event.block.number
  redPacket.transactionHash = event.transaction.hash
  
  // 计算字段
  redPacket.isActive = true
  redPacket.averageAmount = event.params.totalAmount.div(BigInt.fromI32(event.params.totalCount.toI32()))
  redPacket.completionRate = BigDecimal.fromString("0")
  
  redPacket.save()

  // 更新用户统计
  let creator = getOrCreateUser(event.params.creator)
  creator.createdPacketsCount = creator.createdPacketsCount + 1
  creator.totalAmountCreated = creator.totalAmountCreated.plus(event.params.totalAmount)
  
  if (creator.firstActivity.equals(ZERO_BI)) {
    creator.firstActivity = event.block.timestamp
  }
  creator.lastActivity = event.block.timestamp
  creator.save()

  // 更新全局统计
  let globalStats = getOrCreateGlobalStats()
  globalStats.totalPackets = globalStats.totalPackets + 1
  globalStats.totalAmount = globalStats.totalAmount.plus(event.params.totalAmount)
  globalStats.activePackets = globalStats.activePackets + 1
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()

  // 更新每日统计
  let dayStats = getOrCreateDayStats(event.block.timestamp)
  dayStats.packetsCreated = dayStats.packetsCreated + 1
  dayStats.amountCreated = dayStats.amountCreated.plus(event.params.totalAmount)
  dayStats.save()
}

// 事件处理器：红包领取
export function handlePacketClaimed(event: PacketClaimed): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    // 这不应该发生，但为了安全起见
    return
  }

  // 创建领取记录
  let claimId = event.params.packetId.toString() + "-" + event.params.claimer.toHex()
  let claim = new Claim(claimId)
  
  claim.redPacket = redPacket.id
  claim.claimer = event.params.claimer
  claim.amount = event.params.amount
  claim.timestamp = event.block.timestamp
  claim.blockNumber = event.block.number
  claim.transactionHash = event.transaction.hash
  claim.claimIndex = redPacket.claimedCount + 1  // 领取序号
  
  claim.save()

  // 更新红包状态
  redPacket.claimedCount = redPacket.claimedCount + 1
  redPacket.balance = redPacket.balance.minus(event.params.amount)
  redPacket.completionRate = calculateCompletionRate(redPacket.claimedCount, redPacket.totalCount)
  
  // 检查是否还能领取
  if (redPacket.claimedCount >= redPacket.totalCount) {
    redPacket.isActive = false
  }
  
  redPacket.save()

  // 更新用户统计
  let claimer = getOrCreateUser(event.params.claimer)
  claimer.claimedPacketsCount = claimer.claimedPacketsCount + 1
  claimer.totalAmountClaimed = claimer.totalAmountClaimed.plus(event.params.amount)
  
  if (claimer.firstActivity.equals(ZERO_BI)) {
    claimer.firstActivity = event.block.timestamp
  }
  claimer.lastActivity = event.block.timestamp
  claimer.save()

  // 更新全局统计
  let globalStats = getOrCreateGlobalStats()
  globalStats.totalClaims = globalStats.totalClaims + 1
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()

  // 更新每日统计
  let dayStats = getOrCreateDayStats(event.block.timestamp)
  dayStats.packetsClaimed = dayStats.packetsClaimed + 1
  dayStats.amountClaimed = dayStats.amountClaimed.plus(event.params.amount)
  dayStats.save()
}

// 事件处理器：红包抢完
export function handlePacketEmpty(event: PacketEmpty): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    return
  }

  // 确保红包状态正确
  redPacket.isActive = false
  redPacket.completionRate = BigDecimal.fromString("1")
  redPacket.save()

  // 更新全局活跃红包数量
  let globalStats = getOrCreateGlobalStats()
  globalStats.activePackets = globalStats.activePackets - 1
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()
}

// 事件处理器：资金提取
export function handleFundsWithdrawn(event: FundsWithdrawn): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    return
  }

  // 更新红包状态
  redPacket.balance = ZERO_BI
  redPacket.isActive = false
  redPacket.save()

  // 更新全局活跃红包数量
  let globalStats = getOrCreateGlobalStats()
  if (redPacket.isActive) {
    globalStats.activePackets = globalStats.activePackets - 1
  }
  globalStats.lastUpdated = event.block.timestamp
  globalStats.save()
}
```

### 3. 高级查询优化

为了提供更好的查询性能，我们需要在映射中添加一些索引字段：

```typescript
// 在 handlePacketCreated 中添加
redPacket.creatorLowerCase = event.params.creator.toHex().toLowerCase()  // 便于搜索
redPacket.dayCreated = getDayStatsId(event.block.timestamp)              // 便于按天过滤

// 在 handlePacketClaimed 中添加  
claim.claimerLowerCase = event.params.claimer.toHex().toLowerCase()      // 便于搜索
claim.dayCreated = getDayStatsId(event.block.timestamp)                  // 便于按天过滤
```

## 🧪 测试与调试

### 1. 本地测试环境搭建

**安装 Matchstick 测试框架**:
```bash
# 安装测试依赖
npm install --save-dev matchstick-as

# 创建测试目录
mkdir tests
```

**tests/red-packet-system.test.ts**:
```typescript
import {
  test,
  assert,
  describe,
  beforeEach,
  clearStore,
  createMockedFunction,
  newMockEvent
} from "matchstick-as/assembly/index"

import { 
  handlePacketCreated,
  handlePacketClaimed 
} from "../src/mapping"

import { PacketCreated, PacketClaimed } from "../generated/RedPacketSystem/RedPacketSystem"
import { RedPacket, Claim } from "../generated/schema"
import { BigInt, Address, ethereum } from "@graphprotocol/graph-ts"

// 测试工具函数
function createPacketCreatedEvent(
  packetId: BigInt,
  creator: Address,
  message: string,
  totalAmount: BigInt,
  totalCount: BigInt,
  isEven: boolean
): PacketCreated {
  let event = changetype<PacketCreated>(newMockEvent())
  
  event.parameters = []
  
  event.parameters.push(
    new ethereum.EventParam("packetId", ethereum.Value.fromUnsignedBigInt(packetId))
  )
  event.parameters.push(
    new ethereum.EventParam("creator", ethereum.Value.fromAddress(creator))
  )
  event.parameters.push(
    new ethereum.EventParam("message", ethereum.Value.fromString(message))
  )
  event.parameters.push(
    new ethereum.EventParam("totalAmount", ethereum.Value.fromUnsignedBigInt(totalAmount))
  )
  event.parameters.push(
    new ethereum.EventParam("totalCount", ethereum.Value.fromUnsignedBigInt(totalCount))
  )
  event.parameters.push(
    new ethereum.EventParam("isEven", ethereum.Value.fromBoolean(isEven))
  )

  return event
}

function createPacketClaimedEvent(
  packetId: BigInt,
  claimer: Address,
  amount: BigInt
): PacketClaimed {
  let event = changetype<PacketClaimed>(newMockEvent())
  
  event.parameters = []
  
  event.parameters.push(
    new ethereum.EventParam("packetId", ethereum.Value.fromUnsignedBigInt(packetId))
  )
  event.parameters.push(
    new ethereum.EventParam("claimer", ethereum.Value.fromAddress(claimer))
  )
  event.parameters.push(
    new ethereum.EventParam("amount", ethereum.Value.fromUnsignedBigInt(amount))
  )

  return event
}

// 测试用例
describe("Red Packet System", () => {
  beforeEach(() => {
    clearStore() // 清理测试存储
  })

  test("Should create red packet correctly", () => {
    // 准备测试数据
    let packetId = BigInt.fromI32(1)
    let creator = Address.fromString("0x1234567890123456789012345678901234567890")
    let message = "Happy New Year!"
    let totalAmount = BigInt.fromString("1000000000000000000") // 1 ETH
    let totalCount = BigInt.fromI32(5)
    let isEven = true

    // 创建并处理事件
    let event = createPacketCreatedEvent(packetId, creator, message, totalAmount, totalCount, isEven)
    handlePacketCreated(event)

    // 验证红包实体
    let redPacket = RedPacket.load("1")
    assert.assertNotNull(redPacket)
    
    if (redPacket !== null) {
      assert.bytesEquals(redPacket.creator, creator)
      assert.stringEquals(redPacket.message, message)
      assert.bigIntEquals(redPacket.totalAmount, totalAmount)
      assert.bigIntEquals(redPacket.balance, totalAmount)
      assert.i32Equals(redPacket.totalCount, 5)
      assert.i32Equals(redPacket.claimedCount, 0)
      assert.booleanEquals(redPacket.isEven, true)
      assert.booleanEquals(redPacket.isActive, true)
    }
  })

  test("Should handle red packet claim correctly", () => {
    // 先创建红包
    let packetId = BigInt.fromI32(1)
    let creator = Address.fromString("0x1234567890123456789012345678901234567890")
    let claimer = Address.fromString("0x0987654321098765432109876543210987654321")
    
    let createEvent = createPacketCreatedEvent(
      packetId,
      creator,
      "Test packet",
      BigInt.fromString("1000000000000000000"),
      BigInt.fromI32(2),
      false
    )
    handlePacketCreated(createEvent)

    // 然后处理领取事件
    let claimAmount = BigInt.fromString("600000000000000000") // 0.6 ETH
    let claimEvent = createPacketClaimedEvent(packetId, claimer, claimAmount)
    handlePacketClaimed(claimEvent)

    // 验证红包状态更新
    let redPacket = RedPacket.load("1")
    assert.assertNotNull(redPacket)
    
    if (redPacket !== null) {
      assert.i32Equals(redPacket.claimedCount, 1)
      assert.bigIntEquals(redPacket.balance, BigInt.fromString("400000000000000000"))
      assert.booleanEquals(redPacket.isActive, true) // 还有1份没领取
    }

    // 验证领取记录
    let claimId = "1-" + claimer.toHex()
    let claim = Claim.load(claimId)
    assert.assertNotNull(claim)
    
    if (claim !== null) {
      assert.stringEquals(claim.redPacket, "1")
      assert.bytesEquals(claim.claimer, claimer)
      assert.bigIntEquals(claim.amount, claimAmount)
      assert.i32Equals(claim.claimIndex, 1)
    }
  })

  test("Should mark red packet as inactive when fully claimed", () => {
    // 创建只有1份的红包
    let packetId = BigInt.fromI32(1)
    let creator = Address.fromString("0x1234567890123456789012345678901234567890")
    let claimer = Address.fromString("0x0987654321098765432109876543210987654321")
    
    let createEvent = createPacketCreatedEvent(
      packetId,
      creator,
      "Single packet",
      BigInt.fromString("1000000000000000000"),
      BigInt.fromI32(1),
      true
    )
    handlePacketCreated(createEvent)

    // 领取这唯一的红包
    let claimEvent = createPacketClaimedEvent(
      packetId, 
      claimer, 
      BigInt.fromString("1000000000000000000")
    )
    handlePacketClaimed(claimEvent)

    // 验证红包变为非活跃状态
    let redPacket = RedPacket.load("1")
    assert.assertNotNull(redPacket)
    
    if (redPacket !== null) {
      assert.i32Equals(redPacket.claimedCount, 1)
      assert.bigIntEquals(redPacket.balance, BigInt.fromI32(0))
      assert.booleanEquals(redPacket.isActive, false)
      assert.stringEquals(redPacket.completionRate.toString(), "1")
    }
  })
})
```

### 2. 运行测试

```bash
# 生成类型文件
npm run codegen

# 运行测试
graph test
```

## 🚀 部署与发布

### 1. 准备部署

```bash
# 生成类型和构建
npm run codegen
npm run build
```

### 2. 部署到 Graph Studio

```bash
# 首先需要在 https://thegraph.com/studio/ 创建子图

# 授权（需要从Studio获取访问令牌）
graph auth --studio YOUR_ACCESS_TOKEN

# 部署
npm run deploy
```

### 3. 版本管理

**部署多个版本**:
```bash
# 部署到不同标签
graph deploy --studio red-packet-subgraph --version-label v1.0.0
graph deploy --studio red-packet-subgraph --version-label v1.0.1
```

### 4. 监控与维护

**检查同步状态**:
```bash
# 通过GraphQL查询子图状态
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"query": "{ _meta { block { number } } }"}' \
  https://api.studio.thegraph.com/query/your-subgraph-id/your-subgraph-name/version/latest
```

## 📊 常用查询示例

### 1. 基础查询

```graphql
# 获取最新的20个红包
query GetRecentPackets {
  redPackets(
    first: 20
    orderBy: creationTime
    orderDirection: desc
  ) {
    id
    creator
    message
    totalAmount
    totalCount
    claimedCount
    isEven
    isActive
    creationTime
    claims {
      claimer
      amount
      timestamp
    }
  }
}

# 获取用户创建的红包
query GetUserPackets($creator: Bytes!) {
  redPackets(
    where: { creator: $creator }
    orderBy: creationTime
    orderDirection: desc
  ) {
    id
    message
    totalAmount
    totalCount
    claimedCount
    isActive
    completionRate
  }
}

# 获取用户的领取记录
query GetUserClaims($claimer: Bytes!) {
  claims(
    where: { claimer: $claimer }
    orderBy: timestamp
    orderDirection: desc
  ) {
    id
    redPacket {
      id
      message
      creator
    }
    amount
    timestamp
    claimIndex
  }
}
```

### 2. 统计查询

```graphql
# 获取全局统计
query GetGlobalStats {
  globalStats(id: "global") {
    totalPackets
    totalAmount
    totalClaims
    activePackets
    totalUsers
    lastUpdated
  }
}

# 获取每日统计
query GetDayStats($startDate: String!, $endDate: String!) {
  dayStats(
    where: {
      id_gte: $startDate
      id_lte: $endDate
    }
    orderBy: date
    orderDirection: asc
  ) {
    id
    date
    packetsCreated
    packetsClaimed
    amountCreated
    amountClaimed
    activeUsers
  }
}

# 获取用户统计
query GetUserStats($userId: ID!) {
  user(id: $userId) {
    address
    createdPacketsCount
    totalAmountCreated
    claimedPacketsCount
    totalAmountClaimed
    firstActivity
    lastActivity
  }
}
```

### 3. 复杂查询

```graphql
# 获取活跃红包（可领取的）
query GetActivePackets($first: Int = 10) {
  redPackets(
    where: { isActive: true }
    first: $first
    orderBy: creationTime
    orderDirection: desc
  ) {
    id
    creator
    message
    totalAmount
    balance
    totalCount
    claimedCount
    averageAmount
    completionRate
  }
}

# 获取大额红包（总金额大于1 ETH）
query GetLargePackets {
  redPackets(
    where: { totalAmount_gte: "1000000000000000000" }
    orderBy: totalAmount
    orderDirection: desc
  ) {
    id
    creator
    message
    totalAmount
    totalCount
    isEven
    creationTime
  }
}

# 获取红包详情和所有领取记录
query GetPacketDetails($packetId: ID!) {
  redPacket(id: $packetId) {
    id
    creator
    message
    totalAmount
    balance
    totalCount
    claimedCount
    isEven
    isActive
    creationTime
    completionRate
    claims(orderBy: timestamp, orderDirection: asc) {
      claimer
      amount
      timestamp
      claimIndex
      transactionHash
    }
  }
}
```

## 🛠️ 调试与优化

### 1. 调试技巧

**日志调试**:
```typescript
import { log } from "@graphprotocol/graph-ts"

export function handlePacketCreated(event: PacketCreated): void {
  log.info("Processing PacketCreated event for packet {}", [event.params.packetId.toString()])
  
  // 处理逻辑...
  
  log.info("Successfully processed packet {} with amount {}", [
    event.params.packetId.toString(),
    event.params.totalAmount.toString()
  ])
}
```

**错误处理**:
```typescript
export function handlePacketClaimed(event: PacketClaimed): void {
  let redPacket = RedPacket.load(event.params.packetId.toString())
  
  if (redPacket === null) {
    log.error("RedPacket with id {} not found", [event.params.packetId.toString()])
    return  // 优雅处理错误，不要让子图失败
  }

  // 继续处理...
}
```

### 2. 性能优化

**批量操作**:
```typescript
// 避免在循环中多次保存同一个实体
let user = getOrCreateUser(event.params.creator)
user.createdPacketsCount = user.createdPacketsCount + 1
user.totalAmountCreated = user.totalAmountCreated.plus(event.params.totalAmount)
user.lastActivity = event.block.timestamp
user.save() // 只保存一次
```

**合理的实体关系**:
```typescript
// 使用 @derivedFrom 避免手动维护双向关系
// 在 schema.graphql 中：
# claims: [Claim!]! @derivedFrom(field: "redPacket")
```

### 3. 监控指标

**监控子图健康状态**:
```typescript
// 在映射中添加健康检查
let globalStats = getOrCreateGlobalStats()
globalStats.lastUpdated = event.block.timestamp

// 如果长时间没有更新，说明可能有问题
if (event.block.timestamp.gt(globalStats.lastUpdated.plus(BigInt.fromI32(3600)))) {
  log.warning("Subgraph might be lagging, last update was {} seconds ago", [
    event.block.timestamp.minus(globalStats.lastUpdated).toString()
  ])
}
```

## 📚 最佳实践总结

### 1. 数据模型设计
- **实体关系清晰**: 合理设计一对多、多对多关系
- **字段类型选择**: 使用合适的数据类型（BigInt for wei amounts）
- **索引策略**: 经常查询的字段添加索引
- **计算字段**: 在映射中计算常用的派生字段

### 2. 映射逻辑
- **错误处理**: 优雅处理空值和异常情况
- **性能优化**: 避免不必要的实体加载和保存
- **日志记录**: 合理添加日志用于调试
- **版本兼容**: 考虑合约升级和数据迁移

### 3. 测试策略
- **单元测试**: 测试每个事件处理函数
- **集成测试**: 测试完整的业务流程
- **边界测试**: 测试极端情况和错误处理
- **性能测试**: 确保大量数据下的性能

### 4. 部署运维
- **版本管理**: 使用语义版本号管理子图版本
- **监控告警**: 监控同步状态和查询性能
- **备份策略**: 重要数据的备份和恢复
- **文档维护**: 保持查询文档和API文档最新

通过这套完整的Subgraph开发指南，我们构建了一个高效、可靠、可扩展的数据索引系统，为红包DApp提供了强大的数据支持，显著提升了用户体验和应用性能。