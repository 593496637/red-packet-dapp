# ğŸ§§ æ™ºèƒ½åˆçº¦å¼€å‘å®æˆ˜æ•™ç¨‹

> **ä»é›¶å¼€å§‹ï¼Œæ‰‹æŠŠæ‰‹æ•™ä½ å¼€å‘ä¸€ä¸ªå®‰å…¨ã€é«˜æ•ˆçš„çº¢åŒ…æ™ºèƒ½åˆçº¦**

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡è¿™ä¸ªæ•™ç¨‹ï¼Œä½ å°†å­¦ä¼šï¼š
- âœ… å®Œæ•´çš„æ™ºèƒ½åˆçº¦å¼€å‘æµç¨‹
- âœ… Solidityè¯­è¨€å®æˆ˜æŠ€å·§
- âœ… åŒºå—é“¾å®‰å…¨ç¼–ç¨‹æœ€ä½³å®è·µ
- âœ… ç°ä»£åŒ–çš„æµ‹è¯•å’Œéƒ¨ç½²æ–¹æ³•
- âœ… Gasä¼˜åŒ–å’Œæ€§èƒ½è°ƒä¼˜

## ğŸ“š å‰ç½®çŸ¥è¯†

### å¿…é¡»æŒæ¡ï¼š
- JavaScript/TypeScriptåŸºç¡€
- åŒºå—é“¾å’Œä»¥å¤ªåŠåŸºæœ¬æ¦‚å¿µ
- å‘½ä»¤è¡Œæ“ä½œåŸºç¡€

### å»ºè®®äº†è§£ï¼š
- Solidityè¯­æ³•åŸºç¡€
- æ™ºèƒ½åˆçº¦åŸºæœ¬æ¦‚å¿µ
- Web3å¼€å‘ç»éªŒ

---

## ğŸš€ ç¬¬ä¸€æ­¥ï¼šé¡¹ç›®åˆå§‹åŒ–å®æˆ˜

### åˆ›å»ºé¡¹ç›®ç›®å½•
```bash
# 1. åˆ›å»ºå¹¶è¿›å…¥é¡¹ç›®ç›®å½•
mkdir red-packet-contracts
cd red-packet-contracts

# 2. åˆå§‹åŒ–npmé¡¹ç›®
npm init -y

# 3. åˆ›å»ºåŸºæœ¬ç›®å½•ç»“æ„
mkdir contracts
mkdir test
mkdir scripts
mkdir ignition
mkdir ignition/modules
```

### å®‰è£…å¼€å‘ä¾èµ–

```bash
# å®‰è£…Hardhat 3 Beta (æœ€æ–°ç‰ˆæœ¬)
npm install --save-dev hardhat@^3.0.3

# å®‰è£…Hardhatå·¥å…·é“¾
npm install --save-dev @nomicfoundation/hardhat-toolbox-viem
npm install --save-dev @nomicfoundation/hardhat-ignition
npm install --save-dev @nomicfoundation/hardhat-verify

# å®‰è£…TypeScriptæ”¯æŒ
npm install --save-dev typescript @types/node

# å®‰è£…åŒºå—é“¾äº¤äº’åº“
npm install --save-dev viem

# å®‰è£…Foundryæ”¯æŒ(ç”¨äºSolidityæµ‹è¯•)
npm install --save-dev forge-std

# å®‰è£…ç¯å¢ƒå˜é‡ç®¡ç†
npm install dotenv
```

### é…ç½®é¡¹ç›®æ–‡ä»¶

**åˆ›å»º `hardhat.config.ts`**:
```typescript
import type { HardhatUserConfig } from "hardhat/config";
import "dotenv/config";
import hardhatToolboxViemPlugin from "@nomicfoundation/hardhat-toolbox-viem";
import { configVariable } from "hardhat/config";
import "@nomicfoundation/hardhat-verify";

const config: HardhatUserConfig = {
  plugins: [hardhatToolboxViemPlugin],
  
  // Solidityç¼–è¯‘å™¨é…ç½®
  solidity: {
    profiles: {
      default: {
        version: "0.8.28", // ä½¿ç”¨æœ€æ–°ç¨³å®šç‰ˆæœ¬
      },
      production: {
        version: "0.8.28",
        settings: {
          optimizer: {
            enabled: true,
            runs: 200, // å¹³è¡¡éƒ¨ç½²æˆæœ¬å’Œæ‰§è¡Œæˆæœ¬
          },
        },
      },
    },
  },
  
  // ç½‘ç»œé…ç½®
  networks: {
    // æœ¬åœ°å¼€å‘ç½‘ç»œ
    hardhatMainnet: {
      type: "edr-simulated",
      chainType: "l1",
    },
    // Sepoliaæµ‹è¯•ç½‘
    sepolia: {
      type: "http",
      chainType: "l1",
      url: configVariable("SEPOLIA_RPC_URL"),
      accounts: [configVariable("SEPOLIA_PRIVATE_KEY")],
    },
  },
  
  // EtherscanéªŒè¯é…ç½®
  verify: {
    etherscan: {
      apiKey: configVariable("ETHERSCAN_API_KEY"),
    },
  },
};

export default config;
```

**åˆ›å»º `.env` æ–‡ä»¶** (ç¯å¢ƒå˜é‡):
```bash
# Sepoliaæµ‹è¯•ç½‘RPC URL (ä»Infuraæˆ–Alchemyè·å–)
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID

# éƒ¨ç½²è´¦æˆ·ç§é’¥ (æµ‹è¯•ç½‘ä¸“ç”¨ï¼Œä¸è¦ç”¨ä¸»ç½‘ç§é’¥ï¼)
SEPOLIA_PRIVATE_KEY=your_private_key_here

# Etherscan API Key (ç”¨äºåˆçº¦éªŒè¯)
ETHERSCAN_API_KEY=your_etherscan_api_key
```

**åˆ›å»º `.gitignore`**:
```gitignore
node_modules
.env
coverage
coverage.json
typechain
typechain-types

# Hardhat files
cache
artifacts

# Build files
dist
build
```

### éªŒè¯ç¯å¢ƒæ­å»º
```bash
# ç¼–è¯‘ç©ºé¡¹ç›® (åº”è¯¥æˆåŠŸ)
npx hardhat compile

# è¿è¡Œæµ‹è¯• (åº”è¯¥æ˜¾ç¤º"No test files found")  
npx hardhat test

# æŸ¥çœ‹å¯ç”¨å‘½ä»¤
npx hardhat help
```

---

## ğŸ’¡ ç¬¬äºŒæ­¥ï¼šæ™ºèƒ½åˆçº¦è®¾è®¡å®æˆ˜

### éœ€æ±‚åˆ†ææ€ç»´å¯¼å›¾

```
çº¢åŒ…ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½
â”œâ”€â”€ åˆ›å»ºçº¢åŒ…
â”‚   â”œâ”€â”€ å­˜å…¥ETHèµ„é‡‘ âœ¨
â”‚   â”œâ”€â”€ è®¾ç½®çº¢åŒ…ä»½æ•° ğŸ“Š  
â”‚   â”œâ”€â”€ å†™ç¥ç¦è¯­ ğŸ’Œ
â”‚   â””â”€â”€ é€‰æ‹©åˆ†å‘æ¨¡å¼ ğŸ²
â”œâ”€â”€ æŠ¢çº¢åŒ…
â”‚   â”œâ”€â”€ é˜²é‡å¤é¢†å– ğŸ›¡ï¸
â”‚   â”œâ”€â”€ éšæœº/å‡åˆ†ç®—æ³• âš™ï¸
â”‚   â””â”€â”€ å®æ—¶åˆ°è´¦ ğŸ’°
â””â”€â”€ å®‰å…¨æœºåˆ¶
    â”œâ”€â”€ 24å°æ—¶æå–æœºåˆ¶ â°
    â”œâ”€â”€ èµ„é‡‘å®‰å…¨ä¿éšœ ğŸ”’
    â””â”€â”€ é˜²æ”»å‡»è®¾è®¡ ğŸ›¡ï¸
```

### æ•°æ®ç»“æ„è®¾è®¡å®æˆ˜

**åˆ›å»º `contracts/RedPacketSystem.sol`**:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title çº¢åŒ…ç³»ç»Ÿæ™ºèƒ½åˆçº¦
 * @author æ‚¨çš„åå­—
 * @notice è¿™æ˜¯ä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„çº¢åŒ…å‘æ”¾ç³»ç»Ÿ
 * @dev æ”¯æŒéšæœºå’Œå‡åˆ†ä¸¤ç§æ¨¡å¼ï¼ŒåŒ…å«å®Œæ•´çš„å®‰å…¨æœºåˆ¶
 */
contract RedPacketSystem {
    
    // ===== æ•°æ®ç»“æ„å®šä¹‰ =====
    
    /**
     * @dev çº¢åŒ…æ•°æ®ç»“æ„
     * @notice å­˜å‚¨çº¢åŒ…çš„æ‰€æœ‰å¿…è¦ä¿¡æ¯
     */
    struct RedPacket {
        address owner;           // çº¢åŒ…åˆ›å»ºè€…åœ°å€
        string message;          // ç¥ç¦è¯­ 
        uint256 totalAmount;     // çº¢åŒ…æ€»é‡‘é¢ (wei)
        uint256 balance;         // å‰©ä½™é‡‘é¢ (wei)
        uint256 totalCount;      // çº¢åŒ…æ€»ä»½æ•°
        uint256 claimedCount;    // å·²é¢†å–ä»½æ•°
        bool isEven;            // æ˜¯å¦å‡åˆ† (true=å‡åˆ†, false=éšæœº)
        uint256 creationTime;    // åˆ›å»ºæ—¶é—´æˆ³
    }
    
    // ===== çŠ¶æ€å˜é‡ =====
    
    /// @notice çº¢åŒ…è®¡æ•°å™¨ï¼Œç”¨äºç”Ÿæˆå”¯ä¸€ID
    uint256 public packetCounter;
    
    /// @notice å­˜å‚¨æ‰€æœ‰çº¢åŒ…æ•°æ® packetId => RedPacket
    mapping(uint256 => RedPacket) public packets;
    
    /// @notice è®°å½•ç”¨æˆ·é¢†å–çŠ¶æ€ packetId => user => hasClaimed
    mapping(uint256 => mapping(address => bool)) public hasClaimed;
    
    // ===== äº‹ä»¶å®šä¹‰ =====
    
    /**
     * @dev çº¢åŒ…åˆ›å»ºäº‹ä»¶
     * @param packetId çº¢åŒ…ID
     * @param creator åˆ›å»ºè€…åœ°å€  
     * @param message ç¥ç¦è¯­
     * @param totalAmount æ€»é‡‘é¢
     * @param totalCount æ€»ä»½æ•°
     * @param isEven æ˜¯å¦å‡åˆ†
     */
    event PacketCreated(
        uint256 indexed packetId,
        address indexed creator,
        string message,
        uint256 totalAmount,
        uint256 totalCount,
        bool isEven
    );
    
    /**
     * @dev çº¢åŒ…è¢«é¢†å–äº‹ä»¶
     */
    event PacketClaimed(
        uint256 indexed packetId,
        address indexed claimer,
        uint256 amount
    );
    
    /**
     * @dev çº¢åŒ…è¢«é¢†å®Œäº‹ä»¶
     */
    event PacketEmpty(uint256 indexed packetId);
    
    /**
     * @dev é‡å¤é¢†å–å°è¯•äº‹ä»¶  
     */
    event AlreadyClaimed(
        uint256 indexed packetId, 
        address indexed claimer
    );
    
    /**
     * @dev èµ„é‡‘æå–äº‹ä»¶
     */
    event FundsWithdrawn(
        uint256 indexed packetId,
        address indexed owner,
        uint256 amount
    );
```

### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

1. **struct RedPacket**ï¼š
   - `owner`: éœ€è¦éªŒè¯æå–æƒé™
   - `balance`: è·Ÿè¸ªå‰©ä½™èµ„é‡‘ï¼Œæ¯”é‡å¤è®¡ç®—æ›´é«˜æ•ˆ
   - `creationTime`: å®ç°24å°æ—¶æå–æœºåˆ¶
   - `isEven`: æ”¯æŒä¸¤ç§åˆ†å‘æ¨¡å¼

2. **mappingè®¾è®¡**ï¼š
   - `packets`: ä¸»è¦æ•°æ®å­˜å‚¨ï¼Œæ”¯æŒé€šè¿‡IDå¿«é€ŸæŸ¥è¯¢
   - `hasClaimed`: äºŒçº§æ˜ å°„é˜²æ­¢é‡å¤é¢†å–ï¼ŒO(1)æŸ¥è¯¢æ•ˆç‡

3. **äº‹ä»¶è®¾è®¡**ï¼š
   - ä½¿ç”¨`indexed`å…³é”®å­—ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
   - åŒ…å«å‰ç«¯éœ€è¦çš„å®Œæ•´ä¿¡æ¯
   - æ”¯æŒThe Graphç­‰æ•°æ®ç´¢å¼•å·¥å…·

---

## ğŸ”¥ ç¬¬ä¸‰æ­¥ï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°å®æˆ˜

### 1. createRedPacket - åˆ›å»ºçº¢åŒ…åŠŸèƒ½

**åŠŸèƒ½éœ€æ±‚**ï¼šç”¨æˆ·å‘é€ETHï¼Œåˆ›å»ºçº¢åŒ…å¹¶è®¾ç½®å‚æ•°

```solidity
/**
 * @dev åˆ›å»ºçº¢åŒ…åŠŸèƒ½ - å®Œæ•´å®ç°
 * @param _message ç¥ç¦è¯­
 * @param _count çº¢åŒ…ä»½æ•°
 * @param _isEven æ˜¯å¦å‡åˆ†æ¨¡å¼
 */
function createRedPacket(
    string memory _message,
    uint256 _count,
    bool _isEven
) external payable {
    // ===== ç¬¬1æ­¥ï¼šå‚æ•°éªŒè¯ =====
    require(msg.value > 0, "RedPacket: Must send ETH to create");
    require(_count > 0, "RedPacket: Count must be greater than 0");
    require(
        msg.value >= _count,
        "RedPacket: Amount must be at least 1 wei per packet"
    );
    require(bytes(_message).length > 0, "RedPacket: Message cannot be empty");
    require(bytes(_message).length <= 200, "RedPacket: Message too long");

    // ===== ç¬¬2æ­¥ï¼šç”Ÿæˆçº¢åŒ…ID =====
    uint256 packetId = ++packetCounter;
    
    // ===== ç¬¬3æ­¥ï¼šåˆ›å»ºçº¢åŒ…æ•°æ® =====
    packets[packetId] = RedPacket({
        owner: msg.sender,
        message: _message,
        totalAmount: msg.value,
        balance: msg.value,
        totalCount: _count,
        claimedCount: 0,
        isEven: _isEven,
        creationTime: block.timestamp
    });

    // ===== ç¬¬4æ­¥ï¼šå‘å‡ºäº‹ä»¶ =====
    emit PacketCreated(
        packetId,
        msg.sender,
        _message,
        msg.value,
        _count,
        _isEven
    );
}
```

**ä»£ç è§£æ**ï¼š

1. **ä¸ºä»€ä¹ˆè¦éªŒè¯ `msg.value >= _count`ï¼Ÿ**
   ```solidity
   // ç¡®ä¿æ¯ä¸ªçº¢åŒ…è‡³å°‘æœ‰1weiï¼Œé¿å…0é‡‘é¢çº¢åŒ…
   require(msg.value >= _count, "RedPacket: Amount must be at least 1 wei per packet");
   ```

2. **ä¸ºä»€ä¹ˆé™åˆ¶ç¥ç¦è¯­é•¿åº¦ï¼Ÿ**
   ```solidity
   // é˜²æ­¢Gasæ¶ˆè€—è¿‡é«˜ï¼Œ200å­—ç¬¦å·²è¶³å¤Ÿè¡¨è¾¾ç¥ç¦
   require(bytes(_message).length <= 200, "RedPacket: Message too long");
   ```

3. **ä¸ºä»€ä¹ˆä½¿ç”¨é€’å¢è®¡æ•°å™¨ç”ŸæˆIDï¼Ÿ**
   ```solidity
   // ç®€å•ã€å¯é¢„æµ‹ã€é¿å…IDå†²çªï¼ŒGasæ¶ˆè€—è¾ƒä½
   uint256 packetId = ++packetCounter;
   ```

### 2. claimRedPacket - æŠ¢çº¢åŒ…åŠŸèƒ½

**åŠŸèƒ½éœ€æ±‚**ï¼šç”¨æˆ·æŠ¢çº¢åŒ…ï¼Œè·å¾—éšæœºæˆ–å‡åˆ†çš„ETH

```solidity
/**
 * @dev æŠ¢çº¢åŒ…åŠŸèƒ½ - å®Œæ•´å®ç°
 * @param _packetId çº¢åŒ…ID
 */
function claimRedPacket(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId];

    // ===== ç¬¬1æ­¥ï¼šåŸºç¡€éªŒè¯ =====
    require(packet.owner != address(0), "RedPacket: Packet does not exist");
    require(
        packet.claimedCount < packet.totalCount,
        "RedPacket: No packets left"
    );
    require(packet.balance > 0, "RedPacket: No balance left");
    
    // ===== ç¬¬2æ­¥ï¼šé‡å¤é¢†å–æ£€æŸ¥ =====
    if (hasClaimed[_packetId][msg.sender]) {
        emit AlreadyClaimed(_packetId, msg.sender);
        return; // Soft fail: ä¸revertï¼Œæ›´å‹å¥½çš„ç”¨æˆ·ä½“éªŒ
    }

    // ===== ç¬¬3æ­¥ï¼šæ›´æ–°çŠ¶æ€ (CEIæ¨¡å¼) =====
    hasClaimed[_packetId][msg.sender] = true;
    packet.claimedCount++;

    // ===== ç¬¬4æ­¥ï¼šè®¡ç®—é¢†å–é‡‘é¢ =====
    uint256 amount = _calculateAmount(packet);

    // ===== ç¬¬5æ­¥ï¼šæ›´æ–°ä½™é¢ =====
    packet.balance -= amount;

    // ===== ç¬¬6æ­¥ï¼šå®‰å…¨è½¬è´¦ =====
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "RedPacket: Transfer failed");

    // ===== ç¬¬7æ­¥ï¼šå‘å‡ºäº‹ä»¶ =====
    emit PacketClaimed(_packetId, msg.sender, amount);

    // ===== ç¬¬8æ­¥ï¼šæ£€æŸ¥æ˜¯å¦é¢†å®Œ =====
    if (packet.claimedCount == packet.totalCount) {
        emit PacketEmpty(_packetId);
    }
}

/**
 * @dev è®¡ç®—é¢†å–é‡‘é¢çš„æ ¸å¿ƒç®—æ³•
 */
function _calculateAmount(RedPacket storage packet) private view returns (uint256) {
    // æœ€åä¸€ä¸ªäººè·å¾—æ‰€æœ‰å‰©ä½™é‡‘é¢
    if (packet.claimedCount == packet.totalCount) {
        return packet.balance;
    }

    uint256 amount;
    if (packet.isEven) {
        // å‡åˆ†æ¨¡å¼ï¼šç®€å•é™¤æ³•
        amount = packet.totalAmount / packet.totalCount;
    } else {
        // éšæœºæ¨¡å¼ï¼šè°ƒç”¨éšæœºç®—æ³•
        amount = _getRandomAmount(
            packet.balance,
            packet.totalCount - packet.claimedCount + 1
        );
    }

    // é˜²æ­¢è®¡ç®—é”™è¯¯å¯¼è‡´é‡‘é¢è¶…å‡ºä½™é¢
    if (amount > packet.balance) {
        amount = packet.balance;
    }

    return amount;
}
```

**å…³é”®æŠ€æœ¯ç‚¹è§£æ**ï¼š

1. **CEIæ¨¡å¼ (Checks-Effects-Interactions)**ï¼š
   ```solidity
   // âœ… æ­£ç¡®é¡ºåº
   hasClaimed[_packetId][msg.sender] = true; // Effectså…ˆ
   packet.balance -= amount;                 // Effects
   msg.sender.call{value: amount}("");       // Interactionså
   ```

2. **Soft Failè®¾è®¡**ï¼š
   ```solidity
   // é‡å¤é¢†å–ä¸revertï¼Œåªå‘å‡ºäº‹ä»¶
   if (hasClaimed[_packetId][msg.sender]) {
       emit AlreadyClaimed(_packetId, msg.sender);
       return; // ä¼˜é›…é€€å‡º
   }
   ```

3. **ä¸ºä»€ä¹ˆç”¨ `call` è€Œä¸æ˜¯ `transfer`ï¼Ÿ**
   ```solidity
   // call: Gasè½¬å‘æ‰€æœ‰å¯ç”¨Gasï¼Œæ›´å®‰å…¨
   (bool success, ) = msg.sender.call{value: amount}("");
   require(success, "RedPacket: Transfer failed");
   ```

### 3. éšæœºç®—æ³•å®ç° - æ ¸å¿ƒéš¾ç‚¹

```solidity
/**
 * @dev ç”Ÿæˆéšæœºçº¢åŒ…é‡‘é¢
 * @param _balance å½“å‰å‰©ä½™é‡‘é¢
 * @param _remainingCount å‰©ä½™çº¢åŒ…ä»½æ•°  
 */
function _getRandomAmount(
    uint256 _balance,
    uint256 _remainingCount
) private view returns (uint256) {
    if (_remainingCount == 0) return 0;
    if (_remainingCount == 1) return _balance; // æœ€åä¸€ä¸ªäººå…¨æ‹¿
    
    // ===== ç¬¬1æ­¥ï¼šè®¡ç®—å¹³å‡å€¼ =====
    uint256 avg = _balance / _remainingCount;
    
    // ===== ç¬¬2æ­¥ï¼šç”Ÿæˆä¼ªéšæœºæ•° =====
    uint256 seed = uint256(keccak256(abi.encodePacked(
        block.timestamp,    // æ—¶é—´éšæœºæ€§
        msg.sender,        // ç”¨æˆ·éšæœºæ€§  
        _balance,          // ä½™é¢éšæœºæ€§
        blockhash(block.number - 1) // åŒºå—éšæœºæ€§
    )));
    
    // ===== ç¬¬3æ­¥ï¼šè®¡ç®—éšæœºé‡‘é¢ =====
    // èŒƒå›´ï¼š[1, avg * 2]ï¼Œä»¥å¹³å‡å€¼ä¸ºä¸­å¿ƒçš„åˆ†å¸ƒ
    uint256 maxRandom = avg * 2;
    if (maxRandom == 0) maxRandom = 1;
    uint256 random = (seed % maxRandom) + 1;
    
    // ===== ç¬¬4æ­¥ï¼šè¾¹ç•Œä¿æŠ¤ =====
    // ç¡®ä¿å‰©ä½™ç”¨æˆ·èƒ½åˆ†åˆ°è‡³å°‘1wei
    uint256 maxAllowed = _balance - (_remainingCount - 1);
    if (random > maxAllowed) {
        random = maxAllowed;
    }
    
    return random;
}
```

**éšæœºç®—æ³•è®¾è®¡æ€è·¯**ï¼š

1. **éšæœºæ€§æ¥æº**ï¼š
   - `block.timestamp`: æ—¶é—´æˆ³
   - `msg.sender`: é¢†å–è€…åœ°å€
   - `_balance`: å½“å‰ä½™é¢
   - `blockhash`: å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ

2. **åˆ†å¸ƒç­–ç•¥**ï¼š
   ```
   å¹³å‡å€¼ = å‰©ä½™é‡‘é¢ / å‰©ä½™ä»½æ•°
   éšæœºèŒƒå›´ = [1, å¹³å‡å€¼ Ã— 2]
   ```

3. **è¾¹ç•Œä¿æŠ¤**ï¼š
   ```solidity
   // ä¸ºåç»­Nä¸ªç”¨æˆ·ä¿ç•™è‡³å°‘N wei
   uint256 maxAllowed = _balance - (_remainingCount - 1);
   ```

### 4. withdraw - 24å°æ—¶æå–åŠŸèƒ½

```solidity
/**
 * @dev 24å°æ—¶åæå–å‰©ä½™èµ„é‡‘
 * @param _packetId çº¢åŒ…ID
 */
function withdraw(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId];
    
    // ===== ç¬¬1æ­¥ï¼šæƒé™éªŒè¯ =====
    require(msg.sender == packet.owner, "RedPacket: Not the owner");
    
    // ===== ç¬¬2æ­¥ï¼šæ—¶é—´éªŒè¯ =====
    require(
        block.timestamp >= packet.creationTime + 24 hours,
        "RedPacket: Not expired yet"
    );
    
    // ===== ç¬¬3æ­¥ï¼šä½™é¢éªŒè¯ =====
    require(packet.balance > 0, "RedPacket: No balance to withdraw");

    // ===== ç¬¬4æ­¥ï¼šçŠ¶æ€æ›´æ–° =====
    uint256 amountToWithdraw = packet.balance;
    packet.balance = 0; // é˜²é‡å…¥æ”»å‡»

    // ===== ç¬¬5æ­¥ï¼šå®‰å…¨è½¬è´¦ =====
    (bool success, ) = msg.sender.call{value: amountToWithdraw}("");
    require(success, "RedPacket: Withdraw transfer failed");

    // ===== ç¬¬6æ­¥ï¼šå‘å‡ºäº‹ä»¶ =====
    emit FundsWithdrawn(_packetId, msg.sender, amountToWithdraw);
}
```

### 5. è¾…åŠ©æŸ¥è¯¢å‡½æ•°

```solidity
/**
 * @dev è·å–çº¢åŒ…è¯¦ç»†ä¿¡æ¯ (ä¼˜åŒ–ç‰ˆæœ¬)
 */
function getPacketInfo(uint256 _packetId) external view returns (
    address owner,
    string memory message,
    uint256 totalAmount,
    uint256 balance,
    uint256 totalCount,
    uint256 claimedCount,
    bool isEven,
    uint256 creationTime,
    bool expired
) {
    RedPacket storage packet = packets[_packetId];
    require(packet.owner != address(0), "RedPacket: Does not exist");
    
    return (
        packet.owner,
        packet.message,
        packet.totalAmount,
        packet.balance,
        packet.totalCount,
        packet.claimedCount,
        packet.isEven,
        packet.creationTime,
        block.timestamp >= packet.creationTime + 24 hours
    );
}

/**
 * @dev æ‰¹é‡æŸ¥è¯¢ç”¨æˆ·æ˜¯å¦å·²é¢†å–
 */
function batchCheckClaimed(
    uint256[] calldata _packetIds,
    address _user
) external view returns (bool[] memory) {
    bool[] memory results = new bool[](_packetIds.length);
    for (uint256 i = 0; i < _packetIds.length; i++) {
        results[i] = hasClaimed[_packetIds[i]][_user];
    }
    return results;
}
```

---

## ğŸ§ª ç¬¬å››æ­¥ï¼šå®Œæ•´æµ‹è¯•å®æˆ˜

### æµ‹è¯•ç­–ç•¥è®¾è®¡

**æµ‹è¯•é‡‘å­—å¡”**ï¼š
```
    /\     E2E Tests (å°‘é‡)
   /  \    â”œâ”€â”€ å®Œæ•´ç”¨æˆ·æµç¨‹æµ‹è¯•  
  /    \   â””â”€â”€ è·¨åˆçº¦é›†æˆæµ‹è¯•
 /______\  
/        \ Integration Tests (é€‚é‡)
\________/ â”œâ”€â”€ å‡½æ•°é—´äº¤äº’æµ‹è¯•
 \      /  â””â”€â”€ çŠ¶æ€å˜åŒ–éªŒè¯æµ‹è¯•
  \____/   
  \  /     Unit Tests (å¤§é‡)
   \/      â”œâ”€â”€ å•å‡½æ•°åŠŸèƒ½æµ‹è¯•
           â”œâ”€â”€ è¾¹ç•Œæ¡ä»¶æµ‹è¯•
           â””â”€â”€ é”™è¯¯æƒ…å†µæµ‹è¯•
```

### 1. åˆ›å»ºæµ‹è¯•æ–‡ä»¶ç»“æ„

```bash
# åˆ›å»ºæµ‹è¯•ç›®å½•
mkdir -p test/solidity
mkdir -p test/nodejs
mkdir -p test/fixtures

# åˆ›å»ºæµ‹è¯•æ–‡ä»¶
touch test/solidity/RedPacketSystem.t.sol
touch test/nodejs/RedPacketSystem.test.ts
touch test/fixtures/deploy.ts
```

### 2. Solidityå•å…ƒæµ‹è¯•å®æˆ˜

**åˆ›å»º `test/solidity/RedPacketSystem.t.sol`**:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {RedPacketSystem} from "../../contracts/RedPacketSystem.sol";

/**
 * @dev Foundryå…¼å®¹çš„Solidityæµ‹è¯•
 */
contract RedPacketSystemTest is Test {
    RedPacketSystem public redPacketSystem;
    
    // æµ‹è¯•è´¦æˆ·
    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");
    
    // æµ‹è¯•å¸¸é‡
    uint256 constant DEFAULT_AMOUNT = 1 ether;
    uint256 constant DEFAULT_COUNT = 5;
    string constant DEFAULT_MESSAGE = "æ–°å¹´å¿«ä¹ï¼";

    function setUp() public {
        // éƒ¨ç½²åˆçº¦
        redPacketSystem = new RedPacketSystem();
        
        // ç»™æµ‹è¯•è´¦æˆ·å……å€¼
        vm.deal(owner, 100 ether);
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);
        vm.deal(user3, 10 ether);
        
        console.log("âœ… æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ");
        console.log("åˆçº¦åœ°å€:", address(redPacketSystem));
    }

    // ===== createRedPacket æµ‹è¯• =====
    
    function test_CreateRedPacket_Success() public {
        vm.startPrank(owner);
        
        // åˆ›å»ºçº¢åŒ…
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(
            DEFAULT_MESSAGE, 
            DEFAULT_COUNT, 
            false
        );
        
        // éªŒè¯çº¢åŒ…æ•°æ®
        (
            address packetOwner,
            string memory message,
            uint256 totalAmount,
            uint256 balance,
            uint256 totalCount,
            uint256 claimedCount,
            bool isEven,
            uint256 creationTime
        ) = redPacketSystem.packets(1);
        
        assertEq(packetOwner, owner);
        assertEq(message, DEFAULT_MESSAGE);
        assertEq(totalAmount, DEFAULT_AMOUNT);
        assertEq(balance, DEFAULT_AMOUNT);
        assertEq(totalCount, DEFAULT_COUNT);
        assertEq(claimedCount, 0);
        assertEq(isEven, false);
        assertGt(creationTime, 0);
        
        // éªŒè¯è®¡æ•°å™¨
        assertEq(redPacketSystem.packetCounter(), 1);
        
        vm.stopPrank();
        
        console.log("âœ… åˆ›å»ºçº¢åŒ…æµ‹è¯•é€šè¿‡");
    }
    
    function test_CreateRedPacket_EmptyMessage_ShouldFail() public {
        vm.startPrank(owner);
        
        vm.expectRevert("RedPacket: Message cannot be empty");
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}("", DEFAULT_COUNT, true);
        
        vm.stopPrank();
    }
    
    function test_CreateRedPacket_NoETH_ShouldFail() public {
        vm.startPrank(owner);
        
        vm.expectRevert("RedPacket: Must send ETH to create");
        redPacketSystem.createRedPacket(DEFAULT_MESSAGE, DEFAULT_COUNT, true);
        
        vm.stopPrank();
    }
    
    function test_CreateRedPacket_ZeroCount_ShouldFail() public {
        vm.startPrank(owner);
        
        vm.expectRevert("RedPacket: Count must be greater than 0");
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, 0, true);
        
        vm.stopPrank();
    }

    function test_CreateRedPacket_InsufficientAmount_ShouldFail() public {
        vm.startPrank(owner);
        
        // å‘é€4weiä½†è¦æ±‚5ä»½çº¢åŒ…
        vm.expectRevert("RedPacket: Amount must be at least 1 wei per packet");
        redPacketSystem.createRedPacket{value: 4}(DEFAULT_MESSAGE, 5, true);
        
        vm.stopPrank();
    }
    
    // ===== claimRedPacket æµ‹è¯• =====
    
    function test_ClaimRedPacket_EvenMode_Success() public {
        // owneråˆ›å»ºå‡åˆ†çº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, true);
        
        // user1é¢†å–
        uint256 balanceBefore = user1.balance;
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        // éªŒè¯ç”¨æˆ·ä½™é¢å¢åŠ 
        uint256 expectedAmount = DEFAULT_AMOUNT / DEFAULT_COUNT; // 0.2 ETH
        assertEq(user1.balance - balanceBefore, expectedAmount);
        
        // éªŒè¯é¢†å–çŠ¶æ€
        assertTrue(redPacketSystem.hasClaimed(1, user1));
        
        // éªŒè¯çº¢åŒ…çŠ¶æ€
        (, , , uint256 balance, , uint256 claimedCount, ,) = redPacketSystem.packets(1);
        assertEq(claimedCount, 1);
        assertEq(balance, DEFAULT_AMOUNT - expectedAmount);
        
        console.log("âœ… å‡åˆ†çº¢åŒ…é¢†å–æµ‹è¯•é€šè¿‡");
    }
    
    function test_ClaimRedPacket_RandomMode_Success() public {
        // åˆ›å»ºéšæœºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, false);
        
        // å¤šä¸ªç”¨æˆ·é¢†å–
        uint256[] memory amounts = new uint256[](3);
        
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        amounts[0] = address(user1).balance - 10 ether;
        
        vm.prank(user2);
        redPacketSystem.claimRedPacket(1);
        amounts[1] = address(user2).balance - 10 ether;
        
        vm.prank(user3);
        redPacketSystem.claimRedPacket(1);
        amounts[2] = address(user3).balance - 10 ether;
        
        // éªŒè¯é‡‘é¢éƒ½å¤§äº0
        assertGt(amounts[0], 0);
        assertGt(amounts[1], 0);
        assertGt(amounts[2], 0);
        
        console.log("ç”¨æˆ·1é¢†å–é‡‘é¢:", amounts[0]);
        console.log("ç”¨æˆ·2é¢†å–é‡‘é¢:", amounts[1]);
        console.log("ç”¨æˆ·3é¢†å–é‡‘é¢:", amounts[2]);
        console.log("âœ… éšæœºçº¢åŒ…é¢†å–æµ‹è¯•é€šè¿‡");
    }
    
    function test_ClaimRedPacket_DuplicateClaim_ShouldEmitEvent() public {
        // åˆ›å»ºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, true);
        
        // ç¬¬ä¸€æ¬¡é¢†å–
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        // ç¬¬äºŒæ¬¡é¢†å–åº”è¯¥å‘å‡ºAlreadyClaimedäº‹ä»¶
        vm.expectEmit(true, true, false, false);
        emit AlreadyClaimed(1, user1);
        
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        console.log("âœ… é‡å¤é¢†å–è½¯å¤±è´¥æµ‹è¯•é€šè¿‡");
    }
    
    function test_ClaimRedPacket_NonExistentPacket_ShouldFail() public {
        vm.prank(user1);
        vm.expectRevert("RedPacket: Packet does not exist");
        redPacketSystem.claimRedPacket(999);
    }
    
    function test_ClaimRedPacket_LastPersonGetsAllRemaining() public {
        // åˆ›å»º5ä»½éšæœºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, 5, false);
        
        // å‰4ä¸ªäººé¢†å–
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        vm.prank(user2);
        redPacketSystem.claimRedPacket(1);
        
        vm.prank(user3);
        redPacketSystem.claimRedPacket(1);
        
        address user4 = makeAddr("user4");
        vm.deal(user4, 1 ether);
        vm.prank(user4);
        redPacketSystem.claimRedPacket(1);
        
        // æ£€æŸ¥å‰©ä½™ä½™é¢
        (, , , uint256 balanceBefore, , ,  , ) = redPacketSystem.packets(1);
        
        // æœ€åä¸€ä¸ªäººé¢†å–
        address user5 = makeAddr("user5");
        vm.deal(user5, 1 ether);
        uint256 balanceBeforeClaim = user5.balance;
        
        vm.prank(user5);
        redPacketSystem.claimRedPacket(1);
        
        // éªŒè¯æœ€åä¸€ä¸ªäººè·å¾—æ‰€æœ‰å‰©ä½™é‡‘é¢
        assertEq(user5.balance - balanceBeforeClaim, balanceBefore);
        
        // éªŒè¯çº¢åŒ…ä½™é¢ä¸º0
        (, , , uint256 finalBalance, , ,  , ) = redPacketSystem.packets(1);
        assertEq(finalBalance, 0);
        
        console.log("âœ… æœ€åä¸€äººè·å¾—å‰©ä½™é‡‘é¢æµ‹è¯•é€šè¿‡");
    }
    
    // ===== withdraw æµ‹è¯• =====
    
    function test_Withdraw_After24Hours_Success() public {
        // åˆ›å»ºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, true);
        
        // éƒ¨åˆ†é¢†å–
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        // æ—¶é—´å¿«è¿›24å°æ—¶
        vm.warp(block.timestamp + 24 hours + 1);
        
        // æå–å‰©ä½™èµ„é‡‘
        (, , , uint256 balanceBefore, , ,  , ) = redPacketSystem.packets(1);
        uint256 ownerBalanceBefore = owner.balance;
        
        vm.prank(owner);
        redPacketSystem.withdraw(1);
        
        // éªŒè¯æå–æˆåŠŸ
        assertEq(owner.balance - ownerBalanceBefore, balanceBefore);
        
        // éªŒè¯çº¢åŒ…ä½™é¢ä¸º0
        (, , , uint256 finalBalance, , ,  , ) = redPacketSystem.packets(1);
        assertEq(finalBalance, 0);
        
        console.log("âœ… 24å°æ—¶åæå–æµ‹è¯•é€šè¿‡");
    }
    
    function test_Withdraw_Before24Hours_ShouldFail() public {
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, true);
        
        // ç«‹å³å°è¯•æå–
        vm.prank(owner);
        vm.expectRevert("RedPacket: Not expired yet");
        redPacketSystem.withdraw(1);
    }
    
    function test_Withdraw_NotOwner_ShouldFail() public {
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, true);
        
        vm.warp(block.timestamp + 24 hours + 1);
        
        // éownerå°è¯•æå–
        vm.prank(user1);
        vm.expectRevert("RedPacket: Not the owner");
        redPacketSystem.withdraw(1);
    }
    
    // ===== Gasä¼˜åŒ–æµ‹è¯• =====
    
    function testGas_CreateRedPacket() public {
        vm.prank(owner);
        uint256 gasBefore = gasleft();
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, false);
        uint256 gasUsed = gasBefore - gasleft();
        
        console.log("åˆ›å»ºçº¢åŒ…Gasæ¶ˆè€—:", gasUsed);
        assertLt(gasUsed, 200000); // åº”è¯¥å°‘äº20ä¸‡Gas
    }
    
    function testGas_ClaimRedPacket() public {
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: DEFAULT_AMOUNT}(DEFAULT_MESSAGE, DEFAULT_COUNT, false);
        
        vm.prank(user1);
        uint256 gasBefore = gasleft();
        redPacketSystem.claimRedPacket(1);
        uint256 gasUsed = gasBefore - gasleft();
        
        console.log("é¢†å–çº¢åŒ…Gasæ¶ˆè€—:", gasUsed);
        assertLt(gasUsed, 150000); // åº”è¯¥å°‘äº15ä¸‡Gas
    }
    
    // ===== äº‹ä»¶å®šä¹‰ (ç”¨äºæµ‹è¯•) =====
    
    event PacketCreated(
        uint256 indexed packetId,
        address indexed creator,
        string message,
        uint256 totalAmount,
        uint256 totalCount,
        bool isEven
    );
    
    event PacketClaimed(
        uint256 indexed packetId,
        address indexed claimer,
        uint256 amount
    );
    
    event AlreadyClaimed(
        uint256 indexed packetId,
        address indexed claimer
    );
}
```

### 3. Node.jsé›†æˆæµ‹è¯•å®æˆ˜

**åˆ›å»º `test/fixtures/deploy.ts`**:

```typescript
import { deployContract as viemDeploy } from "viem";
import { artifacts } from "hardhat";

export async function deployContract(walletClient: any) {
  const RedPacketSystemArtifact = await artifacts.readArtifact("RedPacketSystem");
  
  const hash = await walletClient.deployContract({
    abi: RedPacketSystemArtifact.abi,
    bytecode: RedPacketSystemArtifact.bytecode,
    account: walletClient.account || (await walletClient.getAddresses())[0],
  });

  const transaction = await walletClient.waitForTransactionReceipt({ hash });
  
  return {
    address: transaction.contractAddress!,
    abi: RedPacketSystemArtifact.abi,
    transactionHash: hash,
  };
}
```

**åˆ›å»º `test/nodejs/RedPacketSystem.test.ts`**:

```typescript
import { test, describe, beforeEach } from "node:test";
import { strict as assert } from "node:assert";
import { 
  createPublicClient, 
  createWalletClient, 
  http, 
  parseEther, 
  formatEther,
  getContract
} from "viem";
import { hardhat } from "viem/chains";
import { deployContract } from "../fixtures/deploy";

describe("RedPacketSystem é›†æˆæµ‹è¯•", () => {
  let publicClient: any;
  let walletClient: any;
  let contractAddress: string;
  let contractAbi: any;
  let accounts: string[];
  let redPacketContract: any;

  beforeEach(async () => {
    // åˆå§‹åŒ–å®¢æˆ·ç«¯
    publicClient = createPublicClient({
      chain: hardhat,
      transport: http(),
    });

    walletClient = createWalletClient({
      chain: hardhat,
      transport: http(),
    });

    // è·å–æµ‹è¯•è´¦æˆ·
    accounts = await walletClient.getAddresses();

    // éƒ¨ç½²åˆçº¦
    const deployment = await deployContract(walletClient);
    contractAddress = deployment.address;
    contractAbi = deployment.abi;
    
    // åˆ›å»ºåˆçº¦å®ä¾‹
    redPacketContract = getContract({
      address: contractAddress,
      abi: contractAbi,
      publicClient,
      walletClient,
    });

    console.log(`âœ… åˆçº¦éƒ¨ç½²æˆåŠŸ: ${contractAddress}`);
  });

  test("å®Œæ•´çº¢åŒ…æµç¨‹æµ‹è¯•", async () => {
    const [owner, user1, user2] = accounts;
    
    console.log("ğŸš€ å¼€å§‹å®Œæ•´çº¢åŒ…æµç¨‹æµ‹è¯•...");

    // === æ­¥éª¤1: åˆ›å»ºçº¢åŒ… ===
    const createTx = await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "createRedPacket",
      args: ["æ­å–œå‘è´¢ï¼Œçº¢åŒ…æ‹¿æ¥ï¼", 3n, false], // 3ä»½éšæœºçº¢åŒ…
      value: parseEther("1.0"),
      account: owner,
    });

    const createReceipt = await publicClient.waitForTransactionReceipt({ 
      hash: createTx 
    });
    
    console.log(`âœ… çº¢åŒ…åˆ›å»ºæˆåŠŸï¼Œäº¤æ˜“å“ˆå¸Œ: ${createTx}`);
    console.log(`â›½ Gasæ¶ˆè€—: ${createReceipt.gasUsed}`);

    // === æ­¥éª¤2: éªŒè¯çº¢åŒ…æ•°æ® ===
    const packetInfo = await publicClient.readContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "packets",
      args: [1n],
    });

    assert.equal(packetInfo[0].toLowerCase(), owner.toLowerCase()); // owner
    assert.equal(packetInfo[1], "æ­å–œå‘è´¢ï¼Œçº¢åŒ…æ‹¿æ¥ï¼"); // message
    assert.equal(packetInfo[2], parseEther("1.0")); // totalAmount
    assert.equal(packetInfo[4], 3n); // totalCount
    assert.equal(packetInfo[6], false); // isEven

    console.log("âœ… çº¢åŒ…æ•°æ®éªŒè¯é€šè¿‡");

    // === æ­¥éª¤3: ç”¨æˆ·é¢†å–çº¢åŒ… ===
    const claimTx1 = await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "claimRedPacket",
      args: [1n],
      account: user1,
    });

    const claimReceipt1 = await publicClient.waitForTransactionReceipt({ 
      hash: claimTx1 
    });
    
    console.log(`âœ… ç”¨æˆ·1é¢†å–æˆåŠŸï¼ŒGasæ¶ˆè€—: ${claimReceipt1.gasUsed}`);

    // === æ­¥éª¤4: éªŒè¯é¢†å–çŠ¶æ€ ===
    const hasClaimed = await publicClient.readContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "hasClaimed",
      args: [1n, user1],
    });

    assert.equal(hasClaimed, true);
    console.log("âœ… é¢†å–çŠ¶æ€éªŒè¯é€šè¿‡");

    // === æ­¥éª¤5: æŸ¥çœ‹çº¢åŒ…çŠ¶æ€å˜åŒ– ===
    const updatedPacket = await publicClient.readContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "packets", 
      args: [1n],
    });

    assert.equal(updatedPacket[5], 1n); // claimedCountåº”è¯¥ä¸º1
    assert.notEqual(updatedPacket[3], parseEther("1.0")); // balanceåº”è¯¥å‡å°‘

    console.log(`ğŸ’° å‰©ä½™ä½™é¢: ${formatEther(updatedPacket[3])} ETH`);
    console.log("âœ… çº¢åŒ…çŠ¶æ€æ›´æ–°éªŒè¯é€šè¿‡");

    // === æ­¥éª¤6: ç¬¬äºŒä¸ªç”¨æˆ·é¢†å– ===
    const claimTx2 = await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "claimRedPacket",
      args: [1n],
      account: user2,
    });

    await publicClient.waitForTransactionReceipt({ hash: claimTx2 });
    console.log("âœ… ç”¨æˆ·2é¢†å–æˆåŠŸ");

    // === æ­¥éª¤7: é‡å¤é¢†å–æµ‹è¯• ===
    try {
      await walletClient.writeContract({
        address: contractAddress,
        abi: contractAbi,
        functionName: "claimRedPacket",
        args: [1n],
        account: user1, // user1é‡å¤é¢†å–
      });
      console.log("âœ… é‡å¤é¢†å–å¤„ç†æ­£ç¡®ï¼ˆsoft failï¼‰");
    } catch (error) {
      // å¦‚æœæŠ›å‡ºå¼‚å¸¸è¯´æ˜å®ç°æœ‰é—®é¢˜
      console.log("âŒ é‡å¤é¢†å–åº”è¯¥soft failè€Œä¸æ˜¯revert");
    }

    console.log("ğŸ‰ å®Œæ•´æµç¨‹æµ‹è¯•é€šè¿‡ï¼");
  });

  test("24å°æ—¶æå–åŠŸèƒ½æµ‹è¯•", async () => {
    const [owner, user1] = accounts;
    
    console.log("â° å¼€å§‹24å°æ—¶æå–åŠŸèƒ½æµ‹è¯•...");

    // åˆ›å»ºçº¢åŒ…
    await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "createRedPacket",
      args: ["æµ‹è¯•æå–", 3n, true],
      value: parseEther("0.6"),
      account: owner,
    });

    // éƒ¨åˆ†é¢†å–
    await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "claimRedPacket",
      args: [1n],
      account: user1,
    });

    // éªŒè¯24å°æ—¶å‰ä¸èƒ½æå–
    try {
      await walletClient.writeContract({
        address: contractAddress,
        abi: contractAbi,
        functionName: "withdraw",
        args: [1n],
        account: owner,
      });
      assert.fail("åº”è¯¥åœ¨24å°æ—¶å‰æ‹’ç»æå–");
    } catch (error: any) {
      assert(error.message.includes("Not expired yet"));
      console.log("âœ… 24å°æ—¶å‰æ­£ç¡®æ‹’ç»æå–");
    }

    // æ—¶é—´å¿«è¿›24å°æ—¶ (éœ€è¦ä½¿ç”¨hardhatç‰¹æ®Šæ–¹æ³•)
    await publicClient.request({
      method: 'evm_increaseTime',
      params: [24 * 60 * 60 + 1], // 24å°æ—¶+1ç§’
    });
    
    await publicClient.request({
      method: 'evm_mine',
    });

    // è·å–æå–å‰ä½™é¢
    const packetBefore = await publicClient.readContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "packets",
      args: [1n],
    });
    
    const ownerBalanceBefore = await publicClient.getBalance({
      address: owner,
    });

    // æ‰§è¡Œæå–
    const withdrawTx = await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "withdraw",
      args: [1n],
      account: owner,
    });

    const withdrawReceipt = await publicClient.waitForTransactionReceipt({
      hash: withdrawTx,
    });

    // éªŒè¯æå–ç»“æœ
    const ownerBalanceAfter = await publicClient.getBalance({
      address: owner,
    });

    const gasUsed = withdrawReceipt.gasUsed * withdrawReceipt.effectiveGasPrice;
    const netGain = ownerBalanceAfter - ownerBalanceBefore + gasUsed;
    
    assert.equal(netGain, packetBefore[3]); // æå–çš„é‡‘é¢åº”è¯¥ç­‰äºä¹‹å‰çš„ä½™é¢
    
    console.log(`ğŸ’° æå–é‡‘é¢: ${formatEther(netGain)} ETH`);
    console.log("âœ… 24å°æ—¶æå–åŠŸèƒ½æµ‹è¯•é€šè¿‡");
  });

  test("è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µæµ‹è¯•", async () => {
    const [owner, user1] = accounts;
    
    console.log("ğŸ§ª å¼€å§‹è¾¹ç•Œæ¡ä»¶æµ‹è¯•...");

    // æµ‹è¯•æœ€å°çº¢åŒ…
    await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "createRedPacket",
      args: ["æœ€å°çº¢åŒ…", 5n, true],
      value: 5n, // 5 weiï¼Œæ¯ä»½1 wei
      account: owner,
    });

    console.log("âœ… æœ€å°çº¢åŒ…åˆ›å»ºæˆåŠŸ");

    // æµ‹è¯•å¤§é¢çº¢åŒ…
    await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "createRedPacket",
      args: ["å¤§é¢çº¢åŒ…", 1000n, false],
      value: parseEther("100"),
      account: owner,
    });

    console.log("âœ… å¤§é¢çº¢åŒ…åˆ›å»ºæˆåŠŸ");

    // æµ‹è¯•æé•¿ç¥ç¦è¯­
    const longMessage = "æ­".repeat(200); // 200ä¸ªå­—ç¬¦
    await walletClient.writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "createRedPacket",
      args: [longMessage, 1n, true],
      value: parseEther("1"),
      account: owner,
    });

    console.log("âœ… æé•¿ç¥ç¦è¯­çº¢åŒ…åˆ›å»ºæˆåŠŸ");

    // æµ‹è¯•é”™è¯¯æƒ…å†µ
    try {
      await walletClient.writeContract({
        address: contractAddress,
        abi: contractAbi,
        functionName: "claimRedPacket",
        args: [999n], // ä¸å­˜åœ¨çš„çº¢åŒ…
        account: user1,
      });
      assert.fail("åº”è¯¥æ‹’ç»ä¸å­˜åœ¨çš„çº¢åŒ…");
    } catch (error: any) {
      assert(error.message.includes("does not exist"));
      console.log("âœ… æ­£ç¡®æ‹’ç»ä¸å­˜åœ¨çš„çº¢åŒ…");
    }

    console.log("ğŸ‰ è¾¹ç•Œæ¡ä»¶æµ‹è¯•å…¨éƒ¨é€šè¿‡ï¼");
  });

  test("Gasæ¶ˆè€—åˆ†æ", async () => {
    const [owner, user1, user2, user3] = accounts;
    
    console.log("â›½ å¼€å§‹Gasæ¶ˆè€—åˆ†æ...");

    // æµ‹è¯•ä¸åŒä»½æ•°çš„Gasæ¶ˆè€—
    const testCases = [1, 10, 100, 500];
    
    for (const count of testCases) {
      const tx = await walletClient.writeContract({
        address: contractAddress,
        abi: contractAbi,
        functionName: "createRedPacket",
        args: [`æµ‹è¯•${count}ä»½`, BigInt(count), false],
        value: parseEther("1"),
        account: owner,
      });

      const receipt = await publicClient.waitForTransactionReceipt({ hash: tx });
      console.log(`ğŸ“Š åˆ›å»º${count}ä»½çº¢åŒ…Gasæ¶ˆè€—: ${receipt.gasUsed}`);
      
      // Gasæ¶ˆè€—åº”è¯¥åˆç†
      assert(receipt.gasUsed < 300000n, `${count}ä»½çº¢åŒ…Gasæ¶ˆè€—è¿‡é«˜`);
    }

    console.log("âœ… Gasæ¶ˆè€—åˆ†æå®Œæˆ");
  });
});
```

### 4. è¿è¡Œæµ‹è¯•

```bash
# ç¼–è¯‘åˆçº¦
npx hardhat compile

# è¿è¡ŒSolidityæµ‹è¯•
npx hardhat test --grep solidity

# è¿è¡ŒNode.jsæµ‹è¯•
npx hardhat test --grep nodejs

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
npx hardhat test

# æŸ¥çœ‹æµ‹è¯•è¦†ç›–ç‡
npx hardhat coverage
```

### 5. æµ‹è¯•ç»“æœè§£è¯»

**æˆåŠŸç¤ºä¾‹è¾“å‡º**:
```
âœ… æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ
åˆçº¦åœ°å€: 0x5FbDB2315678afecb367f032d93F642f64180aa3

RedPacketSystemTest
  âœ… test_CreateRedPacket_Success (gas: 180324)
  âœ… test_ClaimRedPacket_EvenMode_Success (gas: 95432)
  âœ… test_ClaimRedPacket_RandomMode_Success (gas: 126789)
  âœ… test_Withdraw_After24Hours_Success (gas: 87634)
  
ğŸ“Š Gasæ¶ˆè€—ç»Ÿè®¡:
  - åˆ›å»ºçº¢åŒ…: ~180k gas
  - é¢†å–çº¢åŒ…: ~95k gas
  - æå–èµ„é‡‘: ~88k gas
  
ğŸ¯ æµ‹è¯•è¦†ç›–ç‡: 96.5%
```

---

## ğŸš€ ç¬¬äº”æ­¥ï¼šéƒ¨ç½²ä¸éªŒè¯å®æˆ˜

### 1. åˆ›å»ºéƒ¨ç½²è„šæœ¬

**åˆ›å»º `ignition/modules/RedPacketSystem.ts`**:

```typescript
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

/**
 * çº¢åŒ…ç³»ç»Ÿéƒ¨ç½²æ¨¡å—
 * ä½¿ç”¨Hardhat Ignitionè¿›è¡Œéƒ¨ç½²ç®¡ç†
 */
export default buildModule("RedPacketSystemModule", (m) => {
  // éƒ¨ç½²RedPacketSystemåˆçº¦
  const redPacketSystem = m.contract("RedPacketSystem", []);

  // å¯é€‰ï¼šè®¾ç½®åˆçº¦æ ‡ç­¾ï¼Œä¾¿äºç®¡ç†
  m.call(redPacketSystem, "packetCounter", [], {
    id: "verify_deployment"
  });

  return {
    redPacketSystem,
  };
});
```

### 2. æœ¬åœ°éƒ¨ç½²æµ‹è¯•

```bash
# å¯åŠ¨æœ¬åœ°Hardhatç½‘ç»œ
npx hardhat node

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯éƒ¨ç½²åˆ°æœ¬åœ°ç½‘ç»œ
npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network localhost

# éªŒè¯éƒ¨ç½²ç»“æœ
npx hardhat run scripts/verify-deployment.ts --network localhost
```

**åˆ›å»ºéªŒè¯è„šæœ¬ `scripts/verify-deployment.ts`**:

```typescript
import { createPublicClient, http } from "viem";
import { hardhat } from "viem/chains";

async function verifyLocalDeployment() {
  const publicClient = createPublicClient({
    chain: hardhat,
    transport: http("http://127.0.0.1:8545"),
  });

  // ä»Ignitionéƒ¨ç½²ç»“æœè·å–åˆçº¦åœ°å€
  const contractAddress = "0x5FbDB2315678afecb367f032d93F642f64180aa3"; // ç¤ºä¾‹åœ°å€
  
  console.log("ğŸ” éªŒè¯åˆçº¦éƒ¨ç½²...");
  
  // 1. æ£€æŸ¥åˆçº¦ä»£ç 
  const code = await publicClient.getBytecode({ 
    address: contractAddress as `0x${string}` 
  });
  
  if (code && code !== "0x") {
    console.log("âœ… åˆçº¦ä»£ç éƒ¨ç½²æˆåŠŸ");
    console.log(`ğŸ“ åˆçº¦åœ°å€: ${contractAddress}`);
    
    // 2. æ£€æŸ¥åˆå§‹çŠ¶æ€
    try {
      const counter = await publicClient.readContract({
        address: contractAddress as `0x${string}`,
        abi: [
          {
            "inputs": [],
            "name": "packetCounter",
            "outputs": [{"type": "uint256"}],
            "type": "function"
          }
        ],
        functionName: "packetCounter",
      });
      
      console.log(`ğŸ“Š åˆå§‹çº¢åŒ…è®¡æ•°å™¨: ${counter}`);
      console.log("âœ… åˆçº¦çŠ¶æ€æ­£å¸¸");
      
    } catch (error) {
      console.log("âŒ åˆçº¦çŠ¶æ€è¯»å–å¤±è´¥:", error);
    }
  } else {
    console.log("âŒ åˆçº¦éƒ¨ç½²å¤±è´¥");
  }
}

verifyLocalDeployment().catch(console.error);
```

### 3. Sepoliaæµ‹è¯•ç½‘éƒ¨ç½²

**Step 1: å‡†å¤‡ç¯å¢ƒå˜é‡**

```bash
# è®¾ç½®ç§é’¥ï¼ˆå®‰å…¨æ–¹å¼ï¼‰
npx hardhat keystore set SEPOLIA_PRIVATE_KEY

# è®¾ç½®RPC URL
npx hardhat keystore set SEPOLIA_RPC_URL

# è®¾ç½®Etherscan API Key
npx hardhat keystore set ETHERSCAN_API_KEY
```

**Step 2: æ‰§è¡Œéƒ¨ç½²**

```bash
# éƒ¨ç½²åˆ°Sepoliaæµ‹è¯•ç½‘
npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network sepolia

# ç­‰å¾…éƒ¨ç½²ç¡®è®¤...
# âœ… éƒ¨ç½²æˆåŠŸåä¼šæ˜¾ç¤ºåˆçº¦åœ°å€
```

**Step 3: åˆçº¦éªŒè¯**

```bash
# è‡ªåŠ¨éªŒè¯åˆçº¦æºç ï¼ˆéœ€è¦ç­‰å¾…å‡ åˆ†é’Ÿï¼‰
npx hardhat verify --network sepolia <åˆçº¦åœ°å€>

# æ‰‹åŠ¨æŒ‡å®šæ„é€ å‡½æ•°å‚æ•°ï¼ˆå¦‚æœæœ‰ï¼‰
npx hardhat verify --network sepolia <åˆçº¦åœ°å€> "constructor_arg1" "constructor_arg2"
```

### 4. éƒ¨ç½²åéªŒè¯å’Œæµ‹è¯•

**åˆ›å»ºç”Ÿäº§éªŒè¯è„šæœ¬ `scripts/production-test.ts`**:

```typescript
import { createPublicClient, createWalletClient, http, parseEther } from "viem";
import { sepolia } from "viem/chains";
import { privateKeyToAccount } from "viem/accounts";

async function productionTest() {
  // åˆå§‹åŒ–å®¢æˆ·ç«¯
  const publicClient = createPublicClient({
    chain: sepolia,
    transport: http(process.env.SEPOLIA_RPC_URL),
  });

  const account = privateKeyToAccount(process.env.SEPOLIA_PRIVATE_KEY as `0x${string}`);
  const walletClient = createWalletClient({
    account,
    chain: sepolia,
    transport: http(process.env.SEPOLIA_RPC_URL),
  });

  const contractAddress = "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f"; // å®é™…åœ°å€

  console.log("ğŸ§ª å¼€å§‹ç”Ÿäº§ç¯å¢ƒæµ‹è¯•...");
  console.log("ğŸŒ ç½‘ç»œ: Sepolia Testnet");
  console.log("ğŸ“ åˆçº¦åœ°å€:", contractAddress);

  // å®Œæ•´çš„ABIï¼ˆä»artifactsè·å–ï¼‰
  const abi = [
    // è¿™é‡Œåº”è¯¥åŒ…å«å®Œæ•´çš„ABIï¼Œä»ç¼–è¯‘ç»“æœè·å–
    {
      "inputs": [
        {"internalType": "string", "name": "_message", "type": "string"},
        {"internalType": "uint256", "name": "_count", "type": "uint256"},
        {"internalType": "bool", "name": "_isEven", "type": "bool"}
      ],
      "name": "createRedPacket",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    // ... å…¶ä»–ABIé¡¹
  ];

  try {
    // 1. æ£€æŸ¥è´¦æˆ·ä½™é¢
    const balance = await publicClient.getBalance({ address: account.address });
    console.log(`ğŸ’° è´¦æˆ·ä½™é¢: ${balance / BigInt(10**18)} ETH`);

    if (balance < parseEther("0.01")) {
      console.log("âŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆè·å–æµ‹è¯•å¸");
      return;
    }

    // 2. è¯»å–åˆçº¦çŠ¶æ€
    const counter = await publicClient.readContract({
      address: contractAddress as `0x${string}`,
      abi,
      functionName: "packetCounter",
    });

    console.log(`ğŸ“Š å½“å‰çº¢åŒ…è®¡æ•°å™¨: ${counter}`);

    // 3. åˆ›å»ºæµ‹è¯•çº¢åŒ…
    console.log("ğŸ§§ åˆ›å»ºæµ‹è¯•çº¢åŒ…...");
    const createTx = await walletClient.writeContract({
      address: contractAddress as `0x${string}`,
      abi,
      functionName: "createRedPacket",
      args: ["ç”Ÿäº§ç¯å¢ƒæµ‹è¯•çº¢åŒ…", 3n, false],
      value: parseEther("0.003"), // 0.003 ETH
    });

    console.log(`â³ ç­‰å¾…äº¤æ˜“ç¡®è®¤: ${createTx}`);
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: createTx 
    });

    if (receipt.status === 'success') {
      console.log("âœ… çº¢åŒ…åˆ›å»ºæˆåŠŸï¼");
      console.log(`â›½ Gasä½¿ç”¨é‡: ${receipt.gasUsed}`);
      console.log(`ğŸ”— äº¤æ˜“é“¾æ¥: https://sepolia.etherscan.io/tx/${createTx}`);

      // 4. éªŒè¯çº¢åŒ…æ•°æ®
      const newCounter = await publicClient.readContract({
        address: contractAddress as `0x${string}`,
        abi,
        functionName: "packetCounter",
      });

      console.log(`ğŸ“ˆ æ–°çš„çº¢åŒ…è®¡æ•°å™¨: ${newCounter}`);
      console.log("ğŸ‰ ç”Ÿäº§ç¯å¢ƒæµ‹è¯•å®Œæˆï¼");

    } else {
      console.log("âŒ äº¤æ˜“å¤±è´¥");
    }

  } catch (error) {
    console.error("âŒ æµ‹è¯•å¤±è´¥:", error);
  }
}

productionTest().catch(console.error);
```

### 5. éƒ¨ç½²æ£€æŸ¥æ¸…å•

**éƒ¨ç½²å‰æ£€æŸ¥**:
- [ ] åˆçº¦ä»£ç å·²å®Œæˆå¹¶é€šè¿‡æ‰€æœ‰æµ‹è¯•
- [ ] Gasä¼˜åŒ–å·²å®Œæˆï¼Œåˆ›å»ºçº¢åŒ… < 200k gas
- [ ] å®‰å…¨å®¡è®¡å·²å®Œæˆï¼ˆè‡³å°‘è‡ªæˆ‘å®¡è®¡ï¼‰
- [ ] ç¯å¢ƒå˜é‡å·²æ­£ç¡®é…ç½®
- [ ] éƒ¨ç½²è´¦æˆ·æœ‰è¶³å¤Ÿçš„ETHæ”¯ä»˜gas

**éƒ¨ç½²åéªŒè¯**:
- [ ] åˆçº¦åœ°å€å·²è®°å½•
- [ ] EtherscanéªŒè¯å·²å®Œæˆ
- [ ] åŸºæœ¬åŠŸèƒ½æµ‹è¯•é€šè¿‡
- [ ] äº‹ä»¶æ—¥å¿—æ­£å¸¸
- [ ] æƒé™æ§åˆ¶æ­£ç¡®

### 6. ç›‘æ§å’Œç»´æŠ¤

**åˆ›å»ºç›‘æ§è„šæœ¬ `scripts/monitor.ts`**:

```typescript
import { createPublicClient, http, formatEther } from "viem";
import { sepolia } from "viem/chains";

async function monitorContract() {
  const publicClient = createPublicClient({
    chain: sepolia,
    transport: http(process.env.SEPOLIA_RPC_URL),
  });

  const contractAddress = "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f";
  
  // ç›‘å¬äº‹ä»¶
  const unwatch = publicClient.watchContractEvent({
    address: contractAddress as `0x${string}`,
    abi: [
      {
        "anonymous": false,
        "inputs": [
          {"indexed": true, "name": "packetId", "type": "uint256"},
          {"indexed": true, "name": "creator", "type": "address"},
          {"indexed": false, "name": "message", "type": "string"},
          {"indexed": false, "name": "totalAmount", "type": "uint256"},
          {"indexed": false, "name": "totalCount", "type": "uint256"},
          {"indexed": false, "name": "isEven", "type": "bool"}
        ],
        "name": "PacketCreated",
        "type": "event"
      }
    ],
    eventName: 'PacketCreated',
    onLogs: (logs) => {
      logs.forEach((log) => {
        console.log("ğŸ§§ æ–°çº¢åŒ…åˆ›å»º:");
        console.log(`  ID: ${log.args.packetId}`);
        console.log(`  åˆ›å»ºè€…: ${log.args.creator}`);
        console.log(`  é‡‘é¢: ${formatEther(log.args.totalAmount)} ETH`);
        console.log(`  ä»½æ•°: ${log.args.totalCount}`);
        console.log(`  ç¥ç¦: ${log.args.message}`);
        console.log(`  æ¨¡å¼: ${log.args.isEven ? 'å‡åˆ†' : 'éšæœº'}`);
        console.log("---");
      });
    },
  });

  console.log("ğŸ‘€ å¼€å§‹ç›‘æ§åˆçº¦äº‹ä»¶...");
  
  // å®šæœŸæ£€æŸ¥åˆçº¦çŠ¶æ€
  setInterval(async () => {
    try {
      const counter = await publicClient.readContract({
        address: contractAddress as `0x${string}`,
        abi: [
          {
            "inputs": [],
            "name": "packetCounter", 
            "outputs": [{"type": "uint256"}],
            "type": "function"
          }
        ],
        functionName: "packetCounter",
      });
      
      console.log(`ğŸ“Š [${new Date().toISOString()}] æ€»çº¢åŒ…æ•°: ${counter}`);
    } catch (error) {
      console.error("âŒ çŠ¶æ€æ£€æŸ¥å¤±è´¥:", error);
    }
  }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
}

monitorContract().catch(console.error);
```

### 7. æ•…éšœæ’é™¤æŒ‡å—

**å¸¸è§éƒ¨ç½²é—®é¢˜**:

1. **Gasä¼°ç®—å¤±è´¥**:
   ```bash
   Error: Gas estimation failed
   ```
   - æ£€æŸ¥æ„é€ å‡½æ•°å‚æ•°
   - æ£€æŸ¥ç½‘ç»œè¿æ¥
   - å¢åŠ gasé™åˆ¶

2. **ç§é’¥é”™è¯¯**:
   ```bash
   Error: Invalid private key
   ```
   - ç¡®ä¿ç§é’¥æ ¼å¼æ­£ç¡®ï¼ˆ0xå¼€å¤´ï¼‰
   - æ£€æŸ¥ç¯å¢ƒå˜é‡è®¾ç½®

3. **ä½™é¢ä¸è¶³**:
   ```bash
   Error: Insufficient funds
   ```
   - æ£€æŸ¥è´¦æˆ·ETHä½™é¢
   - ä»æ°´é¾™å¤´è·å–æµ‹è¯•å¸

4. **éªŒè¯å¤±è´¥**:
   ```bash
   Error: Contract verification failed
   ```
   - ç­‰å¾…5-10åˆ†é’Ÿåé‡è¯•
   - æ£€æŸ¥Etherscan APIå¯†é’¥
   - ç¡®ä¿ç¼–è¯‘å™¨ç‰ˆæœ¬åŒ¹é…

**è°ƒè¯•å·¥å…·**:
```bash
# æŸ¥çœ‹äº¤æ˜“è¯¦æƒ…
npx hardhat run scripts/debug-transaction.ts --network sepolia

# æ£€æŸ¥åˆçº¦çŠ¶æ€
npx hardhat console --network sepolia
```

---

## ğŸ›¡ï¸ ç¬¬å…­æ­¥ï¼šå®‰å…¨ä¸ä¼˜åŒ–å®æˆ˜

### å®‰å…¨æ£€æŸ¥æ¸…å•

**é‡å…¥æ”»å‡»é˜²æŠ¤** âœ…:
```solidity
// âœ… æ­£ç¡®çš„CEIæ¨¡å¼
function claimRedPacket(uint256 _packetId) external {
    // Checks
    require(packet.owner != address(0), "Not exist");
    
    // Effects  
    hasClaimed[_packetId][msg.sender] = true;
    packet.balance -= amount;
    
    // Interactions
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
}
```

**æ•´æ•°æº¢å‡ºé˜²æŠ¤** âœ…:
```solidity
// Solidity 0.8+ è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
require(msg.value >= _count, "Amount must be at least 1 wei per packet");
```

**è®¿é—®æ§åˆ¶** âœ…:
```solidity
require(msg.sender == packet.owner, "Not the owner");
require(block.timestamp >= packet.creationTime + 24 hours, "Not expired yet");
```

### Gasä¼˜åŒ–æŠ€å·§

**å­˜å‚¨ä¼˜åŒ–**:
```solidity
// âœ… ä½¿ç”¨storageæŒ‡é’ˆå‡å°‘SLOAD
RedPacket storage packet = packets[_packetId];
packet.claimedCount++;
packet.balance -= amount;
```

**è®¡ç®—ä¼˜åŒ–**:
```solidity
// âœ… é¿å…é‡å¤è®¡ç®—
uint256 remainingCount = packet.totalCount - packet.claimedCount + 1;
```

---

## ğŸ“š çŸ¥è¯†æ€»ç»“ä¸è¿›é˜¶

### ä½ å·²ç»æŒæ¡çš„æ ¸å¿ƒæŠ€èƒ½

1. **æ™ºèƒ½åˆçº¦è®¾è®¡**:
   - æ•°æ®ç»“æ„ä¼˜åŒ–
   - äº‹ä»¶ç³»ç»Ÿè®¾è®¡
   - å‡½æ•°æƒé™æ§åˆ¶

2. **Solidityç¼–ç¨‹**:
   - å®‰å…¨ç¼–ç¨‹æ¨¡å¼
   - Gasä¼˜åŒ–æŠ€å·§
   - é”™è¯¯å¤„ç†æœºåˆ¶

3. **æµ‹è¯•é©±åŠ¨å¼€å‘**:
   - Foundryæµ‹è¯•æ¡†æ¶
   - Node.jsé›†æˆæµ‹è¯•
   - Gasæ¶ˆè€—åˆ†æ

4. **éƒ¨ç½²ä¸è¿ç»´**:
   - Hardhat Ignitionéƒ¨ç½²
   - åˆçº¦éªŒè¯æµç¨‹
   - ç›‘æ§ä¸æ•…éšœæ’é™¤

### è¿›é˜¶å­¦ä¹ æ–¹å‘

1. **é«˜çº§å®‰å…¨**:
   - å½¢å¼åŒ–éªŒè¯
   - å®‰å…¨å®¡è®¡å·¥å…·
   - å‡çº§æ¨¡å¼è®¾è®¡

2. **æ€§èƒ½ä¼˜åŒ–**:
   - å­˜å‚¨æ§½ä¼˜åŒ–
   - æ‰¹é‡æ“ä½œè®¾è®¡
   - Layer2é›†æˆ

3. **ç”Ÿäº§çº§éƒ¨ç½²**:
   - å¤šç¯å¢ƒç®¡ç†
   - CI/CDæµæ°´çº¿
   - ç›‘æ§å‘Šè­¦ç³»ç»Ÿ

**æ­å–œä½ ï¼ä½ å·²ç»å®Œæˆäº†æ™ºèƒ½åˆçº¦å¼€å‘çš„å®Œæ•´å­¦ä¹ ï¼** ğŸ‰

ç°åœ¨ä½ å¯ä»¥:
- ç‹¬ç«‹è®¾è®¡å’Œå¼€å‘æ™ºèƒ½åˆçº¦
- ç¼–å†™å®Œæ•´çš„æµ‹è¯•å¥—ä»¶
- éƒ¨ç½²åˆ°æµ‹è¯•ç½‘å’Œä¸»ç½‘
- è¿›è¡Œå®‰å…¨å®¡è®¡å’Œä¼˜åŒ–

ç»§ç»­å®è·µï¼Œæˆä¸ºWeb3å¼€å‘ä¸“å®¶ï¼ ğŸš€
â”‚   â”œâ”€â”€ claimRedPacket()     (é¢†å–çº¢åŒ…)
â”‚   â””â”€â”€ withdraw()           (æå–èµ„é‡‘)
â”œâ”€â”€ è¾…åŠ©åŠŸèƒ½
â”‚   â””â”€â”€ _getRandomAmount()   (éšæœºé‡‘é¢è®¡ç®—)
â””â”€â”€ äº‹ä»¶ç³»ç»Ÿ
    â”œâ”€â”€ PacketCreated
    â”œâ”€â”€ PacketClaimed
    â”œâ”€â”€ PacketEmpty
    â”œâ”€â”€ AlreadyClaimed
    â””â”€â”€ FundsWithdrawn
```

## ğŸ—ï¸ å¼€å‘ç¯å¢ƒæ­å»º

### 1. åˆå§‹åŒ–é¡¹ç›®

```bash
mkdir red-packet-contracts
cd red-packet-contracts
npm init -y
```

### 2. å®‰è£…Hardhatå’Œä¾èµ–

```bash
# å®‰è£…Hardhat 3 Beta
npm install --save-dev hardhat@^3.0.3

# å®‰è£…Hardhatå·¥å…·é“¾
npm install --save-dev @nomicfoundation/hardhat-toolbox-viem
npm install --save-dev @nomicfoundation/hardhat-ignition
npm install --save-dev @nomicfoundation/hardhat-verify

# å®‰è£…å…¶ä»–å¼€å‘ä¾èµ–
npm install --save-dev typescript @types/node
npm install --save-dev viem
npm install --save-dev forge-std

# å®‰è£…è¿è¡Œæ—¶ä¾èµ–
npm install dotenv
```

### 3. Hardhaté…ç½®

**hardhat.config.ts**:
```typescript
import type { HardhatUserConfig } from "hardhat/config";
import "dotenv/config";
import hardhatToolboxViemPlugin from "@nomicfoundation/hardhat-toolbox-viem";
import { configVariable } from "hardhat/config";
import "@nomicfoundation/hardhat-verify";

const config: HardhatUserConfig = {
  plugins: [hardhatToolboxViemPlugin],
  solidity: {
    profiles: {
      default: {
        version: "0.8.28",
      },
      production: {
        version: "0.8.28",
        settings: {
          optimizer: {
            enabled: true,
            runs: 200,
          },
        },
      },
    },
  },
  networks: {
    hardhatMainnet: {
      type: "edr-simulated",
      chainType: "l1",
    },
    sepolia: {
      type: "http",
      chainType: "l1",
      url: configVariable("SEPOLIA_RPC_URL"),
      accounts: [configVariable("SEPOLIA_PRIVATE_KEY")],
    },
  },
  verify: {
    etherscan: {
      apiKey: configVariable("ETHERSCAN_API_KEY"),
    },
  },
};

export default config;
```

**å…³é”®é…ç½®è¯´æ˜**:
- ä½¿ç”¨Solidity 0.8.28ï¼ŒåŒ…å«æœ€æ–°å®‰å…¨ç‰¹æ€§
- ç”Ÿäº§ç¯å¢ƒå¯ç”¨ä¼˜åŒ–å™¨ï¼Œruns=200å¹³è¡¡éƒ¨ç½²æˆæœ¬å’Œæ‰§è¡Œæˆæœ¬
- é…ç½®Sepoliaæµ‹è¯•ç½‘å’ŒEtherscanéªŒè¯
- ä½¿ç”¨configVariableå®‰å…¨ç®¡ç†ç§é’¥

### 4. ç¯å¢ƒå˜é‡é…ç½®

**.env**:
```bash
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID
SEPOLIA_PRIVATE_KEY=your_private_key_here
ETHERSCAN_API_KEY=your_etherscan_api_key
```

## ğŸ’¡ åˆçº¦è®¾è®¡ä¸å®ç°

### 1. æ•°æ®ç»“æ„è®¾è®¡

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract RedPacketSystem {
    // çº¢åŒ…ç»“æ„ä½“ - ç²¾å¿ƒè®¾è®¡çš„å­˜å‚¨å¸ƒå±€
    struct RedPacket {
        address owner;           // 20å­—èŠ‚ - åˆ›å»ºè€…åœ°å€
        string message;          // åŠ¨æ€é•¿åº¦ - ç¥ç¦è¯­
        uint256 totalAmount;     // 32å­—èŠ‚ - æ€»é‡‘é¢
        uint256 balance;         // 32å­—èŠ‚ - å‰©ä½™é‡‘é¢
        uint256 totalCount;      // 32å­—èŠ‚ - æ€»ä»½æ•°
        uint256 claimedCount;    // 32å­—èŠ‚ - å·²é¢†å–ä»½æ•°
        bool isEven;            // 1å­—èŠ‚ - æ˜¯å¦å‡åˆ†
        uint256 creationTime;    // 32å­—èŠ‚ - åˆ›å»ºæ—¶é—´
    }

    // å…¨å±€çŠ¶æ€å˜é‡
    uint256 public packetCounter;    // çº¢åŒ…IDè®¡æ•°å™¨
    
    // æ ¸å¿ƒå­˜å‚¨æ˜ å°„
    mapping(uint256 => RedPacket) public packets;           // packetId => RedPacket
    mapping(uint256 => mapping(address => bool)) public hasClaimed;  // é¢†å–çŠ¶æ€è®°å½•
}
```

**è®¾è®¡è€ƒè™‘**:
1. **å­˜å‚¨ä¼˜åŒ–**: å°†boolå’Œaddresså°½é‡æ”¾åœ¨ä¸€èµ·ï¼Œå‡å°‘å­˜å‚¨æ§½
2. **è®¿é—®æ•ˆç‡**: å¸¸ç”¨æ•°æ®æ”¾åœ¨å‰é¢ï¼Œå‡å°‘SLOADæ“ä½œ
3. **æ‰©å±•æ€§**: é¢„ç•™æ‰©å±•ç©ºé—´ï¼Œä¾¿äºåç»­å‡çº§
4. **å®‰å…¨æ€§**: ä½¿ç”¨åˆé€‚çš„æ•°æ®ç±»å‹ï¼Œé˜²æ­¢æº¢å‡º

### 2. äº‹ä»¶ç³»ç»Ÿè®¾è®¡

```solidity
// å®Œæ•´çš„äº‹ä»¶ç³»ç»Ÿï¼Œä¾¿äºå‰ç«¯ç›‘å¬å’Œå­å›¾ç´¢å¼•
event PacketCreated(
    uint256 indexed packetId,      // ç´¢å¼•ï¼šä¾¿äºæŒ‰çº¢åŒ…IDæŸ¥è¯¢
    address indexed creator,       // ç´¢å¼•ï¼šä¾¿äºæŒ‰åˆ›å»ºè€…æŸ¥è¯¢  
    string message,               // éç´¢å¼•ï¼šèŠ‚çœgas
    uint256 totalAmount,
    uint256 totalCount,
    bool isEven                   // æ–°å¢ï¼šåŒºåˆ†åˆ†å‘æ¨¡å¼
);

event PacketClaimed(
    uint256 indexed packetId,
    address indexed claimer,
    uint256 amount
);

event PacketEmpty(uint256 indexed packetId);

event AlreadyClaimed(
    uint256 indexed packetId, 
    address indexed claimer
);

event FundsWithdrawn(
    uint256 indexed packetId,
    address indexed owner,
    uint256 amount
);
```

**äº‹ä»¶è®¾è®¡åŸåˆ™**:
1. **ç´¢å¼•ç­–ç•¥**: æœ€å¤š3ä¸ªindexedå‚æ•°ï¼Œé€‰æ‹©æœ€å¸¸æŸ¥è¯¢çš„å­—æ®µ
2. **ä¿¡æ¯å®Œæ•´æ€§**: åŒ…å«å‰ç«¯æ¸²æŸ“éœ€è¦çš„æ‰€æœ‰ä¿¡æ¯
3. **Gasä¼˜åŒ–**: å¤§æ•°æ®ä¸åšç´¢å¼•ï¼ŒèŠ‚çœgas
4. **å‘åå…¼å®¹**: æ–°å¢å­—æ®µæ”¾åœ¨æœ«å°¾

### 3. æ ¸å¿ƒåŠŸèƒ½å®ç°

#### createRedPacket - åˆ›å»ºçº¢åŒ…

```solidity
/**
 * @dev åˆ›å»ºä¸€ä¸ªæ–°çº¢åŒ…
 * @param _message ç¥ç¦è¯­
 * @param _count çº¢åŒ…æ•°é‡  
 * @param _isEven æ˜¯å¦å‡åˆ†
 */
function createRedPacket(
    string memory _message,
    uint256 _count,
    bool _isEven
) external payable {
    // å‚æ•°éªŒè¯
    require(msg.value > 0, "RedPacket: Must send ETH to create");
    require(_count > 0, "RedPacket: Count must be greater than 0");
    require(
        msg.value >= _count,
        "RedPacket: Amount must be at least 1 wei per packet"
    );

    // ç”Ÿæˆæ–°çš„çº¢åŒ…ID
    uint256 packetId = ++packetCounter;
    
    // åˆ›å»ºçº¢åŒ…æ•°æ®
    packets[packetId] = RedPacket({
        owner: msg.sender,
        message: _message,
        totalAmount: msg.value,
        balance: msg.value,
        totalCount: _count,
        claimedCount: 0,
        isEven: _isEven,
        creationTime: block.timestamp
    });

    // å‘å‡ºåˆ›å»ºäº‹ä»¶
    emit PacketCreated(
        packetId,
        msg.sender,
        _message,
        msg.value,
        _count,
        _isEven
    );
}
```

**å®ç°è¦ç‚¹**:
1. **å‚æ•°éªŒè¯**: ä¸¥æ ¼éªŒè¯è¾“å…¥å‚æ•°ï¼Œé˜²æ­¢æ— æ•ˆæ•°æ®
2. **IDç®¡ç†**: ä½¿ç”¨é€’å¢è®¡æ•°å™¨ç”Ÿæˆå”¯ä¸€ID
3. **çŠ¶æ€åˆå§‹åŒ–**: æ­£ç¡®åˆå§‹åŒ–æ‰€æœ‰å­—æ®µ
4. **äº‹ä»¶å‘å‡º**: ç¡®ä¿äº‹ä»¶åŒ…å«å®Œæ•´ä¿¡æ¯

#### claimRedPacket - é¢†å–çº¢åŒ…

```solidity
/**
 * @dev æŠ¢çº¢åŒ…
 * @param _packetId çº¢åŒ…çš„ID
 */
function claimRedPacket(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId];

    // åŸºç¡€éªŒè¯
    require(packet.owner != address(0), "RedPacket: Not exist");
    require(
        packet.claimedCount < packet.totalCount,
        "RedPacket: No packets left"
    );
    
    // é‡å¤é¢†å–æ£€æŸ¥ - ä½¿ç”¨soft failè®¾è®¡
    if (hasClaimed[_packetId][msg.sender]) {
        emit AlreadyClaimed(_packetId, msg.sender);
        return; // è§¦å‘äº‹ä»¶ä½†ä¸revertï¼Œå¯¹å‰ç«¯æ›´å‹å¥½
    }

    // æ›´æ–°çŠ¶æ€
    hasClaimed[_packetId][msg.sender] = true;
    packet.claimedCount++;

    // è®¡ç®—é¢†å–é‡‘é¢
    uint256 amount;
    if (packet.claimedCount == packet.totalCount) {
        // æœ€åä¸€ä¸ªäººè·å¾—æ‰€æœ‰å‰©ä½™é‡‘é¢
        amount = packet.balance;
    } else {
        if (packet.isEven) {
            // å‡åˆ†æ¨¡å¼
            amount = packet.totalAmount / packet.totalCount;
        } else {
            // éšæœºæ¨¡å¼
            amount = _getRandomAmount(
                packet.balance,
                packet.totalCount - packet.claimedCount + 1
            );
        }
    }

    // é˜²æ­¢é‡‘é¢è¶…å‡ºä½™é¢
    if (amount > packet.balance) {
        amount = packet.balance;
    }

    packet.balance -= amount;

    // å®‰å…¨è½¬è´¦
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "RedPacket: Transfer failed");

    emit PacketClaimed(_packetId, msg.sender, amount);

    // çº¢åŒ…é¢†å®Œäº‹ä»¶
    if (packet.claimedCount == packet.totalCount) {
        emit PacketEmpty(_packetId);
    }
}
```

**æ ¸å¿ƒç®—æ³•è§£æ**:

1. **é‡‘é¢è®¡ç®—ç­–ç•¥**:
   - æœ€åä¸€äºº: è·å¾—æ‰€æœ‰å‰©ä½™é‡‘é¢ï¼Œç¡®ä¿èµ„é‡‘å®Œå…¨åˆ†é…
   - å‡åˆ†æ¨¡å¼: ç®€å•é™¤æ³•ï¼Œå¯èƒ½æœ‰å¾®å°ä½™é¢ç•™ç»™æœ€åä¸€äºº
   - éšæœºæ¨¡å¼: è°ƒç”¨éšæœºç®—æ³•ï¼Œä¿è¯å…¬å¹³æ€§

2. **çŠ¶æ€æ›´æ–°é¡ºåº**:
   - å…ˆæ ‡è®°å·²é¢†å– â†’ æ›´æ–°è®¡æ•° â†’ è®¡ç®—é‡‘é¢ â†’ æ›´æ–°ä½™é¢ â†’ è½¬è´¦
   - éµå¾ªCEIæ¨¡å¼(Checks-Effects-Interactions)

3. **é”™è¯¯å¤„ç†è®¾è®¡**:
   - é‡å¤é¢†å–ä½¿ç”¨soft failï¼Œæå‡ç”¨æˆ·ä½“éªŒ
   - è½¬è´¦å¤±è´¥ç›´æ¥revertï¼Œä¿è¯èµ„é‡‘å®‰å…¨

#### _getRandomAmount - éšæœºé‡‘é¢ç®—æ³•

```solidity
/**
 * @dev ç”Ÿæˆéšæœºé‡‘é¢ (å†…éƒ¨å‡½æ•°)
 * @param _balance å½“å‰ä½™é¢
 * @param _remainingCount å‰©ä½™ä»½æ•°
 */
function _getRandomAmount(
    uint256 _balance,
    uint256 _remainingCount
) private view returns (uint256) {
    if (_remainingCount == 0) return 0;
    
    // è®¡ç®—å¹³å‡å€¼
    uint256 avg = _balance / _remainingCount;
    
    // ç”Ÿæˆä¼ªéšæœºæ•°
    uint256 seed = uint256(
        keccak256(abi.encodePacked(block.timestamp, msg.sender, _balance))
    );
    uint256 random = (seed % (avg * 2)) + 1; // [1, avg*2]
    
    // ç¡®ä¿ä¸ºåç»­ç”¨æˆ·ä¿ç•™è‡³å°‘1wei
    uint256 maxAmount = _balance - (_remainingCount - 1);
    if (random > maxAmount) {
        random = maxAmount;
    }
    
    return random;
}
```

**ç®—æ³•è®¾è®¡æ€è·¯**:

1. **éšæœºæ€§æ¥æº**:
   - block.timestamp: æ—¶é—´æˆ³éšæœºæ€§
   - msg.sender: ç”¨æˆ·åœ°å€éšæœºæ€§
   - _balance: ä½™é¢éšæœºæ€§

2. **åˆ†å¸ƒç­–ç•¥**:
   - ä»¥å¹³å‡å€¼ä¸ºä¸­å¿ƒï¼ŒèŒƒå›´[1, avg*2]
   - ç¡®ä¿æ¯ä¸ªäººéƒ½èƒ½åˆ†åˆ°é’±ï¼Œæœ€å°1wei

3. **è¾¹ç•Œä¿æŠ¤**:
   - ä¸ºå‰©ä½™ç”¨æˆ·ä¿ç•™èµ„é‡‘
   - é˜²æ­¢æœ€åå‡ ä¸ªç”¨æˆ·æ— é’±å¯åˆ†

#### withdraw - èµ„é‡‘æå–

```solidity
/**
 * @dev åˆ›å»ºè€…åœ¨24å°æ—¶åå–å›å‰©ä½™é‡‘é¢
 * @param _packetId çº¢åŒ…ID
 */
function withdraw(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId];
    
    // æƒé™æ£€æŸ¥
    require(msg.sender == packet.owner, "RedPacket: Not owner");
    
    // æ—¶é—´æ£€æŸ¥
    require(
        block.timestamp > packet.creationTime + 24 hours,
        "RedPacket: Not expired yet"
    );
    
    // ä½™é¢æ£€æŸ¥
    require(packet.balance > 0, "RedPacket: No balance to withdraw");

    uint256 amountToWithdraw = packet.balance;
    packet.balance = 0; // å…ˆæ›´æ–°çŠ¶æ€ï¼Œé˜²æ­¢é‡å…¥

    // å®‰å…¨è½¬è´¦
    (bool success, ) = msg.sender.call{value: amountToWithdraw}("");
    require(success, "RedPacket: Withdraw failed");

    emit FundsWithdrawn(_packetId, msg.sender, amountToWithdraw);
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥ä¸å®ç°

### 1. æµ‹è¯•æ¶æ„è®¾è®¡

```
test/
â”œâ”€â”€ solidity/                 # Foundryå…¼å®¹çš„Solidityæµ‹è¯•
â”‚   â”œâ”€â”€ RedPacketSystem.t.sol
â”‚   â””â”€â”€ helpers/
â”‚       â””â”€â”€ TestHelpers.sol
â””â”€â”€ nodejs/                   # Node.jsé›†æˆæµ‹è¯•
    â”œâ”€â”€ RedPacketSystem.test.ts
    â””â”€â”€ fixtures/
        â””â”€â”€ deploy.ts
```

### 2. Solidityå•å…ƒæµ‹è¯•

**test/solidity/RedPacketSystem.t.sol**:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test} from "forge-std/Test.sol";
import {RedPacketSystem} from "../../contracts/RedPacketSystem.sol";

contract RedPacketSystemTest is Test {
    RedPacketSystem public redPacketSystem;
    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");

    function setUp() public {
        redPacketSystem = new RedPacketSystem();
        
        // ç»™æµ‹è¯•è´¦æˆ·ä¸€äº›ETH
        vm.deal(owner, 10 ether);
        vm.deal(user1, 1 ether);
        vm.deal(user2, 1 ether);
    }

    function testCreateRedPacket() public {
        vm.startPrank(owner);
        
        // æµ‹è¯•æˆåŠŸåˆ›å»º
        redPacketSystem.createRedPacket{value: 1 ether}("Happy New Year", 5, false);
        
        // éªŒè¯çŠ¶æ€
        (address packetOwner, string memory message, uint256 totalAmount, , uint256 totalCount, , bool isEven,) 
            = redPacketSystem.packets(1);
        
        assertEq(packetOwner, owner);
        assertEq(message, "Happy New Year");
        assertEq(totalAmount, 1 ether);
        assertEq(totalCount, 5);
        assertEq(isEven, false);
        
        vm.stopPrank();
    }

    function testCreateRedPacketFailures() public {
        vm.startPrank(owner);
        
        // æµ‹è¯•æ— ETHåˆ›å»º
        vm.expectRevert("RedPacket: Must send ETH to create");
        redPacketSystem.createRedPacket("test", 1, true);
        
        // æµ‹è¯•é›¶ä»½æ•°
        vm.expectRevert("RedPacket: Count must be greater than 0");
        redPacketSystem.createRedPacket{value: 1 ether}("test", 0, true);
        
        vm.stopPrank();
    }

    function testClaimRedPacket() public {
        // åˆ›å»ºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: 1 ether}("test", 2, true);
        
        // é¢†å–çº¢åŒ…
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        // éªŒè¯çŠ¶æ€
        assertTrue(redPacketSystem.hasClaimed(1, user1));
        
        // éªŒè¯ä½™é¢å˜åŒ–
        (, , , uint256 balance, , uint256 claimedCount, ,) = redPacketSystem.packets(1);
        assertEq(claimedCount, 1);
        assertLt(balance, 1 ether); // ä½™é¢åº”è¯¥å‡å°‘
    }

    function testPreventDuplicateClaim() public {
        // åˆ›å»ºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: 1 ether}("test", 2, true);
        
        // ç¬¬ä¸€æ¬¡é¢†å–
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
        
        // ç¬¬äºŒæ¬¡é¢†å–åº”è¯¥å‘å‡ºAlreadyClaimedäº‹ä»¶ä½†ä¸revert
        vm.expectEmit(true, true, false, false);
        emit AlreadyClaimed(1, user1);
        
        vm.prank(user1);
        redPacketSystem.claimRedPacket(1);
    }

    function testWithdrawAfterExpiry() public {
        // åˆ›å»ºçº¢åŒ…
        vm.prank(owner);
        redPacketSystem.createRedPacket{value: 1 ether}("test", 2, true);
        
        // æ—¶é—´å¿«è¿›24å°æ—¶
        vm.warp(block.timestamp + 24 hours + 1);
        
        // æå–èµ„é‡‘
        uint256 balanceBefore = owner.balance;
        vm.prank(owner);
        redPacketSystem.withdraw(1);
        
        // éªŒè¯ä½™é¢å˜åŒ–
        assertGt(owner.balance, balanceBefore);
    }
}
```

### 3. Node.jsé›†æˆæµ‹è¯•

**test/nodejs/RedPacketSystem.test.ts**:
```typescript
import { test, describe, beforeEach } from "node:test";
import { strict as assert } from "node:assert";
import { createPublicClient, createWalletClient, http, parseEther, formatEther } from "viem";
import { hardhat } from "viem/chains";
import { deployContract } from "./fixtures/deploy";

describe("RedPacketSystem Integration Tests", () => {
  let publicClient: any;
  let walletClient: any;
  let contractAddress: string;
  let accounts: string[];

  beforeEach(async () => {
    // åˆå§‹åŒ–å®¢æˆ·ç«¯
    publicClient = createPublicClient({
      chain: hardhat,
      transport: http(),
    });

    walletClient = createWalletClient({
      chain: hardhat,  
      transport: http(),
    });

    // è·å–æµ‹è¯•è´¦æˆ·
    accounts = await walletClient.getAddresses();

    // éƒ¨ç½²åˆçº¦
    const { address } = await deployContract(walletClient);
    contractAddress = address;
  });

  test("å®Œæ•´çš„çº¢åŒ…æµç¨‹", async () => {
    const [owner, user1, user2] = accounts;

    // 1. åˆ›å»ºçº¢åŒ…
    const createTx = await walletClient.writeContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "createRedPacket",
      args: ["æ–°å¹´å¿«ä¹", 2n, false],
      value: parseEther("1"),
      account: owner,
    });

    await publicClient.waitForTransactionReceipt({ hash: createTx });

    // 2. éªŒè¯çº¢åŒ…åˆ›å»º
    const packet = await publicClient.readContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "packets",
      args: [1n],
    });

    assert.equal(packet[0], owner); // owner
    assert.equal(packet[1], "æ–°å¹´å¿«ä¹"); // message
    assert.equal(packet[2], parseEther("1")); // totalAmount

    // 3. ç”¨æˆ·é¢†å–çº¢åŒ…
    const claimTx1 = await walletClient.writeContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "claimRedPacket",
      args: [1n],
      account: user1,
    });

    await publicClient.waitForTransactionReceipt({ hash: claimTx1 });

    // 4. éªŒè¯é¢†å–çŠ¶æ€
    const hasClaimed = await publicClient.readContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "hasClaimed",
      args: [1n, user1],
    });

    assert.equal(hasClaimed, true);
  });

  test("Gasä½¿ç”¨é‡æµ‹è¯•", async () => {
    const [owner] = accounts;

    const createTx = await walletClient.writeContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "createRedPacket",
      args: ["test", 10n, false],
      value: parseEther("1"),
      account: owner,
    });

    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: createTx 
    });

    console.log(`åˆ›å»ºçº¢åŒ…Gasä½¿ç”¨é‡: ${receipt.gasUsed}`);
    
    // éªŒè¯Gasä½¿ç”¨é‡åœ¨åˆç†èŒƒå›´å†…
    assert(receipt.gasUsed < 200000n, "åˆ›å»ºçº¢åŒ…Gasä½¿ç”¨é‡è¿‡é«˜");
  });
});
```

## ğŸš€ éƒ¨ç½²ä¸éªŒè¯

### 1. éƒ¨ç½²è„šæœ¬ç¼–å†™

**ignition/modules/RedPacketSystem.ts**:
```typescript
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

export default buildModule("RedPacketSystemModule", (m) => {
  // éƒ¨ç½²RedPacketSystemåˆçº¦
  const redPacketSystem = m.contract("RedPacketSystem", []);

  return {
    redPacketSystem,
  };
});
```

### 2. éƒ¨ç½²åˆ°Sepolia

```bash
# è®¾ç½®ç¯å¢ƒå˜é‡
npx hardhat keystore set SEPOLIA_PRIVATE_KEY
npx hardhat keystore set SEPOLIA_RPC_URL  
npx hardhat keystore set ETHERSCAN_API_KEY

# æ‰§è¡Œéƒ¨ç½²
npx hardhat ignition deploy ignition/modules/RedPacketSystem.ts --network sepolia

# éªŒè¯åˆçº¦
npx hardhat verify --network sepolia <CONTRACT_ADDRESS>
```

### 3. éƒ¨ç½²åéªŒè¯

```typescript
// scripts/verify-deployment.ts
import { createPublicClient, http } from "viem";
import { sepolia } from "viem/chains";

async function verifyDeployment() {
  const publicClient = createPublicClient({
    chain: sepolia,
    transport: http(process.env.SEPOLIA_RPC_URL),
  });

  const contractAddress = "0x4e659F1DB6E5475800A6E8d12F0f6dd25c65960f";

  // æ£€æŸ¥åˆçº¦æ˜¯å¦éƒ¨ç½²æˆåŠŸ
  const code = await publicClient.getBytecode({ 
    address: contractAddress 
  });
  
  if (code && code !== "0x") {
    console.log("âœ… åˆçº¦éƒ¨ç½²æˆåŠŸ");
    
    // æ£€æŸ¥packetCounteræ˜¯å¦ä¸º0
    const counter = await publicClient.readContract({
      address: contractAddress,
      abi: redPacketAbi,
      functionName: "packetCounter",
    });
    
    console.log(`ğŸ“Š å½“å‰çº¢åŒ…è®¡æ•°å™¨: ${counter}`);
  } else {
    console.log("âŒ åˆçº¦éƒ¨ç½²å¤±è´¥");
  }
}
```

## ğŸ›¡ï¸ å®‰å…¨è€ƒè™‘ä¸å®¡è®¡

### 1. å®‰å…¨å¨èƒåˆ†æ

**é‡å…¥æ”»å‡»é˜²æŠ¤**:
```solidity
// âŒ é”™è¯¯çš„å®ç°
function claimRedPacket(uint256 _packetId) external {
    uint256 amount = calculateAmount();
    (bool success, ) = msg.sender.call{value: amount}(""); // å…ˆè½¬è´¦
    require(success, "Transfer failed");
    
    packet.balance -= amount; // åæ›´æ–°çŠ¶æ€ - å±é™©!
}

// âœ… æ­£ç¡®çš„å®ç°
function claimRedPacket(uint256 _packetId) external {
    uint256 amount = calculateAmount();
    packet.balance -= amount; // å…ˆæ›´æ–°çŠ¶æ€
    
    (bool success, ) = msg.sender.call{value: amount}(""); // åè½¬è´¦
    require(success, "Transfer failed");
}
```

**æ•´æ•°æº¢å‡ºé˜²æŠ¤**:
```solidity
// Solidity 0.8+ è‡ªåŠ¨æ£€æŸ¥æº¢å‡ºï¼Œä½†ä»éœ€æ³¨æ„è¾¹ç•Œæƒ…å†µ
require(msg.value >= _count, "Amount must be at least 1 wei per packet");
require(_count > 0, "Count must be greater than 0");
```

**è®¿é—®æ§åˆ¶**:
```solidity
// åªæœ‰åˆ›å»ºè€…å¯ä»¥æå–
require(msg.sender == packet.owner, "RedPacket: Not owner");

// åªæœ‰åœ¨è¿‡æœŸåæ‰èƒ½æå–
require(
    block.timestamp > packet.creationTime + 24 hours,
    "RedPacket: Not expired yet"
);
```

### 2. Gasä¼˜åŒ–æŠ€å·§

**å­˜å‚¨ä¼˜åŒ–**:
```solidity
// âŒ Gasæ˜‚è´µçš„å†™æ³•
function inefficientUpdate(uint256 _packetId) external {
    packets[_packetId].claimedCount++;          // SSTORE
    packets[_packetId].balance -= amount;       // SSTORE  
}

// âœ… Gasä¼˜åŒ–çš„å†™æ³•
function efficientUpdate(uint256 _packetId) external {
    RedPacket storage packet = packets[_packetId]; // ä¸€æ¬¡SLOAD
    packet.claimedCount++;                         // SSTORE
    packet.balance -= amount;                      // SSTORE
}
```

**äº‹ä»¶ä¼˜åŒ–**:
```solidity
// æœ€å¤š3ä¸ªindexedå‚æ•°ï¼Œé€‰æ‹©æœ€é‡è¦çš„
event PacketClaimed(
    uint256 indexed packetId,  // ç”¨äºè¿‡æ»¤
    address indexed claimer,   // ç”¨äºè¿‡æ»¤
    uint256 amount            // ä¸ç´¢å¼•ï¼ŒèŠ‚çœgas
);
```

### 3. ä»£ç å®¡è®¡æ¸…å•

**åŠŸèƒ½æ€§å®¡è®¡**:
- [ ] æ‰€æœ‰å‡½æ•°éƒ½èƒ½æ­£ç¡®æ‰§è¡Œ
- [ ] è¾¹ç•Œæ¡ä»¶å¤„ç†æ­£ç¡®
- [ ] äº‹ä»¶å‘å‡ºå®Œæ•´
- [ ] çŠ¶æ€æ›´æ–°åŸå­æ€§

**å®‰å…¨æ€§å®¡è®¡**:
- [ ] æ— é‡å…¥æ”»å‡»é£é™©
- [ ] æ— æ•´æ•°æº¢å‡ºé£é™©  
- [ ] è®¿é—®æ§åˆ¶æ­£ç¡®
- [ ] éšæœºæ•°å®‰å…¨æ€§

**ç»æµæ¨¡å‹å®¡è®¡**:
- [ ] èµ„é‡‘æµå…¥æµå‡ºå¹³è¡¡
- [ ] æ— èµ„é‡‘é”å®šé£é™©
- [ ] æ¿€åŠ±æœºåˆ¶åˆç†

**Gasä¼˜åŒ–å®¡è®¡**:
- [ ] å­˜å‚¨è®¿é—®ä¼˜åŒ–
- [ ] è®¡ç®—å¤æ‚åº¦åˆç†
- [ ] äº‹ä»¶å‚æ•°ä¼˜åŒ–

## ğŸ“š çŸ¥è¯†æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯èƒ½åŠ›
1. **Solidityè¯­è¨€ç²¾é€š**: è¯­æ³•ã€æœ€ä½³å®è·µã€å®‰å…¨æ¨¡å¼
2. **æ™ºèƒ½åˆçº¦è®¾è®¡**: æ•°æ®ç»“æ„ã€çŠ¶æ€ç®¡ç†ã€äº‹ä»¶ç³»ç»Ÿ
3. **å®‰å…¨ç¼–ç¨‹**: é‡å…¥é˜²æŠ¤ã€æº¢å‡ºæ£€æŸ¥ã€è®¿é—®æ§åˆ¶
4. **Gasä¼˜åŒ–**: å­˜å‚¨å¸ƒå±€ã€è®¡ç®—ä¼˜åŒ–ã€äº‹ä»¶è®¾è®¡
5. **æµ‹è¯•é©±åŠ¨å¼€å‘**: å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€è¾¹ç•Œæµ‹è¯•

### å·¥å…·é“¾æŒæ¡
1. **Hardhat 3**: é…ç½®ã€ç¼–è¯‘ã€æµ‹è¯•ã€éƒ¨ç½²
2. **Foundry**: Solidityæµ‹è¯•ã€Gasåˆ†æ
3. **Viem**: ç°ä»£åŒ–çš„ä»¥å¤ªåŠäº¤äº’åº“
4. **Node.js Test Runner**: åŸç”Ÿæµ‹è¯•æ¡†æ¶

### æœ€ä½³å®è·µæ€»ç»“
1. **CEIæ¨¡å¼**: Checks-Effects-Interactions
2. **é˜²å¾¡æ€§ç¼–ç¨‹**: å‚æ•°éªŒè¯ã€è¾¹ç•Œæ£€æŸ¥ã€é”™è¯¯å¤„ç†
3. **æµ‹è¯•å…ˆè¡Œ**: æµ‹è¯•é©±åŠ¨å¼€å‘ï¼Œå®Œæ•´è¦†ç›–
4. **æ–‡æ¡£å®Œå–„**: æ³¨é‡Šæ¸…æ™°ã€æ–‡æ¡£å®Œæ•´
5. **ç‰ˆæœ¬æ§åˆ¶**: åˆç†çš„Gitå·¥ä½œæµ

é€šè¿‡è¿™ä¸ªæ™ºèƒ½åˆçº¦çš„å¼€å‘è¿‡ç¨‹ï¼Œæˆ‘ä»¬æŒæ¡äº†ä»éœ€æ±‚åˆ†æåˆ°éƒ¨ç½²éªŒè¯çš„å®Œæ•´æµç¨‹ï¼Œè¿™æ˜¯Web3å¼€å‘çš„æ ¸å¿ƒæŠ€èƒ½ã€‚